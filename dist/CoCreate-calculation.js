/*! For license information please see CoCreate-calculation.js.LICENSE.txt */
!function(n,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.CoCreate=t():(n.CoCreate=n.CoCreate||{},n.CoCreate.calculation=t())}(this,(function(){return(()=>{var __webpack_modules__={"./node_modules/@cocreate/action/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// -testing1\nconst CoCreateAction = {\n  attribute: 'data-actions',\n  actions: {},\n  selectedStage: [],\n  stageIndex: 0,\n  selectedElement: null,\n  \n  completedEventName: 'completedEvent',\n  \n  __init: function() {\n    this.actionButtonEvent()\n  },\n\n  actionButtonEvent: function() {\n    const self = this;\n    document.addEventListener('click', function(event) {\n      let btn = event.target;\n      if (!btn.getAttribute('data-actions')) {\n        btn = event.target.closest('[data-actions]');\n      }\n      if (!btn) return;\n      event.preventDefault();\n\n      let actions = (btn.getAttribute(self.attribute) || \"\").replace(/\\s/g, '').split(',');\n      if (actions.length == 0) return;\n      self.stageIndex = 0;\n      self.selectedStage = actions;\n      \n      //. run function\n      self.selectedElement = btn;\n      self.__runActionFunc();\n    })\n  },\n  \n  init: function({action, callback, endEvent}) {\n    this.registerEvent(action, callback, null, endEvent);\n  },\n  \n  /**\n   * key: string\n   * runFunc: function\n   * instance: object\n   * endEvent: string\n   **/\n  registerEvent: function(key, runFunc, instance, endEvent) {\n    if (this.actions[key]) {\n      return;\n    }\n    \n    this.actions[key] = {\n      key: key,\n      runFunc: runFunc,\n      instance: instance || window,\n      endEvent: endEvent\n    }\n    //. register events\n    \n    for (let __key in this.actions) {\n      if (__key != key && this.actions[__key]['endEvent'] === endEvent) {\n        return;\n      }\n    }\n    \n    //. register events\n    const _this = this;\n    document.addEventListener(endEvent, function(e) {\n      _this.__nextAction(endEvent, e.detail)\n    });\n  },\n  \n  __runActionFunc: function(data) {\n\n    if (this.stageIndex >= this.selectedStage.length) {\n\n      //. if latest case, it will be run aTag\n      if (this.stageIndex == this.selectedStage.length) {\n        this.__runAtag(this.selectedElement);        \n      }\n      return;\n    }\n    \n    const actionName = this.selectedStage[this.stageIndex];\n    //. run function\n    const action = this.actions[actionName];\n    if (action) {\n      if (action.runFunc) {\n        action.runFunc.call(null, this.selectedElement, data);\n      } else {\n        this.__nextAction(action.endEvent, {});\n      }\n    } else {\n      let status = this.__runSpecialAction(actionName, data);\n      if (status === \"next\") {\n        this.__moveNextAction();\n      }\n    }\n  },\n  \n  __nextAction: function(eventName, data) {\n    const key = this.selectedStage[this.stageIndex];\n    if (!key) {\n      return ;\n    }\n    if (eventName !== this.actions[key].endEvent) {\n      return;\n    }\n    this.__moveNextAction(data);\n  },\n  \n  __runAtag: function(button) {\n    var aTag = button.querySelector('a');\n          \n    if (aTag) {\n      // CoCreate.logic.setLinkProcess(aTag)\n    }\n  },\n  \n  //. special action\n  \n  __runSpecialAction: function(actionName, data) {\n    let matches = /(\\w+)\\{([a-zA-Z0-9_ \\-#$.]+)\\}/gm.exec(actionName)\n    \n    if (!matches || matches.length < 3) {\n      return \"next\";\n    }\n    \n    let type = matches[1], param = matches[2].trim()\n    if (!param) return \"next\";\n    \n    const self = this;\n    switch (type) {\n      case 'event':\n        console.log(\"Waiting Event....\");\n        document.addEventListener(param, (eventData) => {\n          console.log('Event Action (Received event from other section) ====== ' + param);\n          self.__moveNextAction(eventData);\n        }, { once: true })\n        break;\n      case 'timeout':\n        let delayTime = parseInt(param);\n        if (delayTime > 0) {\n          setTimeout(function() {\n            console.log(\"Timeout ======= \" + param)\n            self.__moveNextAction(data);\n          }, parseInt(param));\n        }\n        break;\n      case 'action':\n        let btn = document.querySelector(param);\n        if (btn) {\n          btn.click();\n        }\n        break;\n      default:\n        return \"next\";\n    }\n  },\n  \n  __moveNextAction: function(data) {\n    this.stageIndex ++;\n    this.__runActionFunc(data);\n  },\n}\n\n\nCoCreateAction.__init();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateAction);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvYWN0aW9uL3NyYy9pbmRleC5qcz9kYzQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSCxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2Q0FBNkM7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSwwQkFBMEIsdUJBQXVCOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUEsaUVBQWUsY0FBYyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvYWN0aW9uL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIC10ZXN0aW5nMVxuY29uc3QgQ29DcmVhdGVBY3Rpb24gPSB7XG4gIGF0dHJpYnV0ZTogJ2RhdGEtYWN0aW9ucycsXG4gIGFjdGlvbnM6IHt9LFxuICBzZWxlY3RlZFN0YWdlOiBbXSxcbiAgc3RhZ2VJbmRleDogMCxcbiAgc2VsZWN0ZWRFbGVtZW50OiBudWxsLFxuICBcbiAgY29tcGxldGVkRXZlbnROYW1lOiAnY29tcGxldGVkRXZlbnQnLFxuICBcbiAgX19pbml0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFjdGlvbkJ1dHRvbkV2ZW50KClcbiAgfSxcblxuICBhY3Rpb25CdXR0b25FdmVudDogZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgbGV0IGJ0biA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGlmICghYnRuLmdldEF0dHJpYnV0ZSgnZGF0YS1hY3Rpb25zJykpIHtcbiAgICAgICAgYnRuID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWFjdGlvbnNdJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJ0bikgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgbGV0IGFjdGlvbnMgPSAoYnRuLmdldEF0dHJpYnV0ZShzZWxmLmF0dHJpYnV0ZSkgfHwgXCJcIikucmVwbGFjZSgvXFxzL2csICcnKS5zcGxpdCgnLCcpO1xuICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgIHNlbGYuc3RhZ2VJbmRleCA9IDA7XG4gICAgICBzZWxmLnNlbGVjdGVkU3RhZ2UgPSBhY3Rpb25zO1xuICAgICAgXG4gICAgICAvLy4gcnVuIGZ1bmN0aW9uXG4gICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudCA9IGJ0bjtcbiAgICAgIHNlbGYuX19ydW5BY3Rpb25GdW5jKCk7XG4gICAgfSlcbiAgfSxcbiAgXG4gIGluaXQ6IGZ1bmN0aW9uKHthY3Rpb24sIGNhbGxiYWNrLCBlbmRFdmVudH0pIHtcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoYWN0aW9uLCBjYWxsYmFjaywgbnVsbCwgZW5kRXZlbnQpO1xuICB9LFxuICBcbiAgLyoqXG4gICAqIGtleTogc3RyaW5nXG4gICAqIHJ1bkZ1bmM6IGZ1bmN0aW9uXG4gICAqIGluc3RhbmNlOiBvYmplY3RcbiAgICogZW5kRXZlbnQ6IHN0cmluZ1xuICAgKiovXG4gIHJlZ2lzdGVyRXZlbnQ6IGZ1bmN0aW9uKGtleSwgcnVuRnVuYywgaW5zdGFuY2UsIGVuZEV2ZW50KSB7XG4gICAgaWYgKHRoaXMuYWN0aW9uc1trZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHRoaXMuYWN0aW9uc1trZXldID0ge1xuICAgICAga2V5OiBrZXksXG4gICAgICBydW5GdW5jOiBydW5GdW5jLFxuICAgICAgaW5zdGFuY2U6IGluc3RhbmNlIHx8IHdpbmRvdyxcbiAgICAgIGVuZEV2ZW50OiBlbmRFdmVudFxuICAgIH1cbiAgICAvLy4gcmVnaXN0ZXIgZXZlbnRzXG4gICAgXG4gICAgZm9yIChsZXQgX19rZXkgaW4gdGhpcy5hY3Rpb25zKSB7XG4gICAgICBpZiAoX19rZXkgIT0ga2V5ICYmIHRoaXMuYWN0aW9uc1tfX2tleV1bJ2VuZEV2ZW50J10gPT09IGVuZEV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8uIHJlZ2lzdGVyIGV2ZW50c1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICBfdGhpcy5fX25leHRBY3Rpb24oZW5kRXZlbnQsIGUuZGV0YWlsKVxuICAgIH0pO1xuICB9LFxuICBcbiAgX19ydW5BY3Rpb25GdW5jOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICBpZiAodGhpcy5zdGFnZUluZGV4ID49IHRoaXMuc2VsZWN0ZWRTdGFnZS5sZW5ndGgpIHtcblxuICAgICAgLy8uIGlmIGxhdGVzdCBjYXNlLCBpdCB3aWxsIGJlIHJ1biBhVGFnXG4gICAgICBpZiAodGhpcy5zdGFnZUluZGV4ID09IHRoaXMuc2VsZWN0ZWRTdGFnZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fX3J1bkF0YWcodGhpcy5zZWxlY3RlZEVsZW1lbnQpOyAgICAgICAgXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLnNlbGVjdGVkU3RhZ2VbdGhpcy5zdGFnZUluZGV4XTtcbiAgICAvLy4gcnVuIGZ1bmN0aW9uXG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25zW2FjdGlvbk5hbWVdO1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGlmIChhY3Rpb24ucnVuRnVuYykge1xuICAgICAgICBhY3Rpb24ucnVuRnVuYy5jYWxsKG51bGwsIHRoaXMuc2VsZWN0ZWRFbGVtZW50LCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19uZXh0QWN0aW9uKGFjdGlvbi5lbmRFdmVudCwge30pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3RhdHVzID0gdGhpcy5fX3J1blNwZWNpYWxBY3Rpb24oYWN0aW9uTmFtZSwgZGF0YSk7XG4gICAgICBpZiAoc3RhdHVzID09PSBcIm5leHRcIikge1xuICAgICAgICB0aGlzLl9fbW92ZU5leHRBY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFxuICBfX25leHRBY3Rpb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuc2VsZWN0ZWRTdGFnZVt0aGlzLnN0YWdlSW5kZXhdO1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXR1cm4gO1xuICAgIH1cbiAgICBpZiAoZXZlbnROYW1lICE9PSB0aGlzLmFjdGlvbnNba2V5XS5lbmRFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fbW92ZU5leHRBY3Rpb24oZGF0YSk7XG4gIH0sXG4gIFxuICBfX3J1bkF0YWc6IGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgIHZhciBhVGFnID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJ2EnKTtcbiAgICAgICAgICBcbiAgICBpZiAoYVRhZykge1xuICAgICAgLy8gQ29DcmVhdGUubG9naWMuc2V0TGlua1Byb2Nlc3MoYVRhZylcbiAgICB9XG4gIH0sXG4gIFxuICAvLy4gc3BlY2lhbCBhY3Rpb25cbiAgXG4gIF9fcnVuU3BlY2lhbEFjdGlvbjogZnVuY3Rpb24oYWN0aW9uTmFtZSwgZGF0YSkge1xuICAgIGxldCBtYXRjaGVzID0gLyhcXHcrKVxceyhbYS16QS1aMC05XyBcXC0jJC5dKylcXH0vZ20uZXhlYyhhY3Rpb25OYW1lKVxuICAgIFxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBcIm5leHRcIjtcbiAgICB9XG4gICAgXG4gICAgbGV0IHR5cGUgPSBtYXRjaGVzWzFdLCBwYXJhbSA9IG1hdGNoZXNbMl0udHJpbSgpXG4gICAgaWYgKCFwYXJhbSkgcmV0dXJuIFwibmV4dFwiO1xuICAgIFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICBjb25zb2xlLmxvZyhcIldhaXRpbmcgRXZlbnQuLi4uXCIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHBhcmFtLCAoZXZlbnREYXRhKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0V2ZW50IEFjdGlvbiAoUmVjZWl2ZWQgZXZlbnQgZnJvbSBvdGhlciBzZWN0aW9uKSA9PT09PT0gJyArIHBhcmFtKTtcbiAgICAgICAgICBzZWxmLl9fbW92ZU5leHRBY3Rpb24oZXZlbnREYXRhKTtcbiAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZW91dCc6XG4gICAgICAgIGxldCBkZWxheVRpbWUgPSBwYXJzZUludChwYXJhbSk7XG4gICAgICAgIGlmIChkZWxheVRpbWUgPiAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGltZW91dCA9PT09PT09IFwiICsgcGFyYW0pXG4gICAgICAgICAgICBzZWxmLl9fbW92ZU5leHRBY3Rpb24oZGF0YSk7XG4gICAgICAgICAgfSwgcGFyc2VJbnQocGFyYW0pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FjdGlvbic6XG4gICAgICAgIGxldCBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmFtKTtcbiAgICAgICAgaWYgKGJ0bikge1xuICAgICAgICAgIGJ0bi5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwibmV4dFwiO1xuICAgIH1cbiAgfSxcbiAgXG4gIF9fbW92ZU5leHRBY3Rpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLnN0YWdlSW5kZXggKys7XG4gICAgdGhpcy5fX3J1bkFjdGlvbkZ1bmMoZGF0YSk7XG4gIH0sXG59XG5cblxuQ29DcmVhdGVBY3Rpb24uX19pbml0KCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlQWN0aW9uOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/action/src/index.js\n")},"./node_modules/@cocreate/crdt/src/core.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var y_websocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-websocket */ \"./node_modules/y-websocket/src/y-websocket.js\");\n/* harmony import */ var y_indexeddb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-indexeddb */ \"./node_modules/y-indexeddb/src/y-indexeddb.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _cocreate_cursors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/cursors */ \"./node_modules/@cocreate/cursors/src/index.js\");\n\n\n\n\n\n\n\nconst debug = false;\n\nclass CoCreateYSocket {\n\tconstructor(org, ydoc) {\n\t\tthis.doc = ydoc;\n\t\tthis.orgName = org;\n\t\tthis.docs = {};\n\t\tthis._awarenessListener = null;\n\t\tthis.character = '_';\n\t\tthis.listenAwereness = function(){}\n\t}\n\t\n\tcreateDoc(id, element) {\n\t\tif (!id || id == \"\") {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tlet newInfo = this.parseType(id)\n\t\t// if(debug)\n\t\t// \tconsole.log(newInfo);\n\t\t\n\t\tconst newId = newInfo.id;\n\t\t\n\t\tif (this.docs[newId]) { \n\t\t\tif (element && !this.__checkExistElement(this.docs[newId].elements, element)) {\n\t\t\t\tthis.docs[newId].elements.push(element);\n\t\t\t}\n\n\t\t\tif (!this.docs[newId].types.some((type) => type === id)) {\n\t\t\t\t// register event\n\t\t\t\tthis.docs[newId].types.push(id);\n\t\t\t\tthis.registerUpdateEvent(this.docs[newId], id)\n\t\t\t\t\n\t\t\t}\n\t\t\treturn false;\n\t\t} \n\t\t\n\t\tconst yDoc = this.doc\n\t\t\n\t\tconst url_socket = this.__getSocketUrl();\n\t\t//draw cursor dinamially\n\t\t// new UserCursor(socketProvider);\n\n\t\t\t\n\t\tvar socketProvider = new y_websocket__WEBPACK_IMPORTED_MODULE_2__.WebsocketProvider(url_socket, newId, yDoc);\n\t\tlet indexeddbProvider = null;\n\t\tif (newInfo.document_id != \"null\") {\n\t\t\tindexeddbProvider = new y_indexeddb__WEBPACK_IMPORTED_MODULE_3__.IndexeddbPersistence(newId, this.doc)\n\t\t\tindexeddbProvider.whenSynced.then(() => {\n\t\t\t  console.log('loaded data from indexed db')\n\t\t\t})\n\t\t}\t\n\t\t\n\t\tlet awareness = socketProvider.awareness;\n\t\t\n\t\tthis._cursors = new Map();\n\t\t\n\t\tthis._awarenessListener = event => {\n\t\t  const f = clientId => {\n\t\t\tif (clientId !== this.doc.clientID) {\n\t\t\t  this.updateRemoteSelection(yDoc, id, yDoc.getText(id), this._cursors, clientId, awareness)\n\t\t\t}\n\t\t  }\n\t\t  event.added.forEach(f)\n\t\t  event.removed.forEach(f)\n\t\t  event.updated.forEach(f)\n\t\t}\n\t\t\n\t\tawareness.on('change', this._awarenessListener);\n\t\t/*\n\t\tawareness.getStates().forEach((aw, clientId) => {\n\t\t\tconsole.log(\"Update --\")\n        })\n        */\n        \n        this.docs[newId] = {\n\t\t\tid: newId,\n\t\t\tdoc: yDoc,\n\t\t\tsocket: socketProvider,\n\t\t\tawareness: awareness,\n\t\t\telements: element ? [element] : [],\n\t\t\ttypes: [id],\n\t\t\tindexeddb: indexeddbProvider\n\t\t}\n\t\tthis.registerUpdateEvent(this.docs[newId], id)\n\n\t\treturn true;\n\t}\n\t\n\tregisterUpdateEvent(docObject, id) {\n\t\tconst yDoc = docObject.doc;\n\t\tconst shardType = yDoc.getText(id)\n\t\tlet _this = this;\n\t\t\n\t\tshardType.observe((event) => {\n\t\t\t_this.__setTypeObserveEvent(event, docObject.elements, id);\n\t\t})\n\t}\n\t\n\t__checkExistElement(elements, element) {\n\t\tfor (var i = 0; i < elements.length; i++) {\n\t\t\tif (elements[i].isSameNode(element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t__getSocketUrl() {\n\t\tconsole.log(\"get_socket url\")\n\t\tlet w_location = window.location || window.parent.location;\n\t\tlet w_protocol = w_location.protocol;\n\t\tlet w_host = w_location.host;\n\t\tif (w_location.protocol === \"about:\") {\n\t\t\tw_protocol = w_location.protocol;\n\t\t\tw_host = document.referrer;\n\t\t}\n\t\tlet protocol = w_protocol === 'http:' ? 'ws' : 'wss';\n\n\t\tlet url_socket = `${protocol}://${w_host}:8080/`;\n\t\tif (window.config && window.config.host) {\n\t\t\tif (window.config.host.includes(\"://\")) {\n\t\t\t\turl_socket = `${window.config.host}/`;\n\t\t\t} else {\n\t\t\t\turl_socket = `${protocol}://${window.config.host}/`;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconsole.log(url_socket)\n\t\turl_socket += \"crdt/\";\n\t\t\n\t\treturn url_socket;\n\n\t}\n\t\n\t__setTypeObserveEvent(event, elements, id) {\n\t\tconsole.log('set crdt event', event.delta)\n\t\tif (!id) return;\n\n\t\tconst eventDelta = event.delta;\n\t\t\n\t\tif (eventDelta.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst info = JSON.parse(atob(id));\n\t\tlet is_save_value = false\n\t\t\n\t\tconst wholestring = event.target.toString()\n\t\tconst store_event = new CustomEvent('store-content-db', {\n\t\t\tdetail: wholestring\n\t\t})\n\t\t\n\t\tconst update_event = new CustomEvent('cocreate-crdt-update', {\n\t\t\tdetail: eventDelta\n\t\t})\n\t\telements.forEach((el) => {\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default().isReadAttr(el) && el.getAttribute('name') === info.name) {\n\t\t\t\tel.dispatchEvent(update_event)\n\t\t\t}\n\t\t})\n\t\t\t\n\t\t\n\t\tif (typeof info !== 'object') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (event.transaction.local) {\n\t\t\tif (elements.length == 0) {\n\t\t\t\tis_save_value = true;\n\t\t\t}\n\t\t\telements.forEach((el) => {\n\t\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default().isSaveAttr(el) && el.getAttribute('name') === info.name && info.document_id != \"null\") {\n\t\t\t\t\tis_save_value = true;\n\t\t\t\t\tel.dispatchEvent(store_event)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (is_save_value) {\n\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default().updateDocument({\n\t\t\t\t\tcollection: info.collection,\n\t\t\t\t\tdocument_id: info.document_id,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\t[info.name]: wholestring\n\t\t\t\t\t},\n\t\t\t\t\tmetadata: 'yjs-change'\n\t\t\t\t})\n\t\t\t}\n\t\t} else {\n\n\t\t}\n\t}\n\t\n\tdeleteDoc(id) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tdelete this.docs[info.id];\n\t\t}\n\t}\n\t\n\tgenerateDocName(collection, document_id, name) {\n\t\tconst info = {org: this.orgName, collection, document_id, name}\n\t\treturn btoa(JSON.stringify(info)); \n\t\t// return this.orgName + \"_\" + collection + \"_\" + document_id + \"_\" + name;\n\t}\n\t\n\tinsertData(id, index, content, attribute) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tif (attribute) {\n\t\t\t\tthis.docs[info.id].doc.getText(id).insert(index, content, attribute);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tthis.docs[info.id].doc.getText(id).insert(index, content);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdeleteData(id, index, length) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tthis.docs[info.id].doc.getText(id).delete(index, length);\n\t\t}\n\t}\n\t\n\tgetWholeString(id) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tconsole.log(\"!Get data\")\n\t\t\treturn this.docs[info.id].doc.getText(id).toString();\n\t\t} else {\n\t\t\treturn \"--\";\n\t\t}\n\t}\n\t\n\tupdateRemoteSelection (y, cm, type, cursors, clientId, awareness)  {\n\t\tif(debug)\n\t\t\t\tconsole.log(\"CHANGE ---- DOCID \",this.doc.clientID,' OTHER CLIENTEID ',clientId)\n\t\tif(clientId !== this.doc.clientID){\n\t\t\t\n\t\t\t\t\t//console.log(\"TEXT -> updateRemoteSelection \",clientId,awareness,cursor)\n\t\t\t\t\t//console.log(\"AW status\",awareness.getLocalState())\n\t\t\t\t\t  // destroy current text mark\n\t\t\t\t\t  const m = cursors.get(clientId)\n\t\t\t\t\t  if (m !== undefined) {\n\t\t\t\t\t\tm.caret.clear()\n\t\t\t\t\t\tif (m.sel !== null) {\n\t\t\t\t\t\t  m.sel.clear()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcursors.delete(clientId)\n\t\t\t\t\t  }\n\t\t\t\t\t  // redraw caret and selection for clientId\n\t\t\t\t\t  const aw = awareness.getStates().get(clientId);\n\t\t\t\t\t  if(debug)\n\t\t\t\t\t\tconsole.log(aw)\n\t\t\t\t\t  if (aw === undefined) {\n\t\t\t\t\t\t  if(debug)\n\t\t\t\t\t\t\tconsole.log(\" Cursor OUT \",clientId)\n\t\t\t\t\t\t   //awareness.setLocalStateField('cursor', null);\n\t\t\t\t\t\t   let elements = document.querySelectorAll('[id*=\"socket_'+clientId+'\"]');\n\t\t\t\t\t\t\telements.forEach(function (element, index, array) {\n\t\t\t\t\t\t\t\telement.parentNode.removeChild(element);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tlet sel_elements = document.querySelectorAll('[id*=\"sel-'+clientId+'\"]');\n\t\t\t\t\t\t\t  sel_elements.forEach(function (sel_element, index, array) {\n\t\t\t\t\t\t\t\tsel_element.parentNode.removeChild(sel_element);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t  /*\n\t\t\t\t\t\t   let element = document.getElementById(\"socket_\"+clientId)\n\t\t\t\t\t\t   let sel_element = document.getElementById(\"sel-\"+clientId)\n\t\t\t\t\t\t   if(element)\n\t\t\t\t\t\t\telement.parentNode.removeChild(element);\n\t\t\t\t\t\t\tif(sel_element)\n\t\t\t\t\t\t\tsel_element.parentNode.removeChild(sel_element);\n\t\t\t\t\t\t   */\n\t\t\t\t\t\treturn\n\t\t\t\t\t  }\n\t\t\t\t\t  const user = aw.user || {}\n\t\t\t\t\t  if (user.color == null) {\n\t\t\t\t\t\tuser.color = '#ffa500'\n\t\t\t\t\t  }\n\t\t\t\t\t  if (user.name == null) {\n\t\t\t\t\t\tuser.name = `User: ${clientId}`\n\t\t\t\t\t  }\n\t\t\t\t\t  const cursor = aw.cursor\n\t\t\t\t\t  if(debug)\n\t\t\t\t\t\tconsole.log(\"Cursor \",cursor)\n\t\t\t\t\t  if (cursor == null || cursor.anchor == null || cursor.head == null) {\n\t\t\t\t\t\t  //let element = document.getElementById(\"socket_\"+clientId)\n\t\t\t\t\t\t  let elements = document.querySelectorAll('[id*=\"socket_'+clientId+'\"]');\n\t\t\t\t\t\t  elements.forEach(function (element, index, array) {\n\t\t\t\t\t\t\telement.parentNode.removeChild(element);\n\t\t\t\t\t\t  })\n\t\t\t\t\t\t\n\t\t\t\t\t\t//let sel_element = document.getElementById(\"sel-\"+clientId)  \n\t\t\t\t\t\tlet sel_elements = document.querySelectorAll('[id*=\"sel-'+clientId+'\"]');\n\t\t\t\t\t\t  sel_elements.forEach(function (sel_element, index, array) {\n\t\t\t\t\t\t\tsel_element.parentNode.removeChild(sel_element);\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t  }\n\t\t\t\t\n\t\t\t\t\t  const anchor = yjs__WEBPACK_IMPORTED_MODULE_4__.createAbsolutePositionFromRelativePosition(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(cursor.anchor), y)\n\t\t\t\t\t  const head = yjs__WEBPACK_IMPORTED_MODULE_4__.createAbsolutePositionFromRelativePosition(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(cursor.head), y)\n\t\t\t\t\t  //CoCreate.cursors.draw_cursor(1,11,12,66,{},true);\n\t\t\t\t\t  if(debug){\n\t\t\t\t\t\t  console.log(\"PRE Draw Cursor \")\n\t\t\t\t\t\t  console.log(\"anchor  \",anchor , \" head \",head,' Type ',type)\n\t\t\t\t\t\t  console.log(\"anchor  Type\",anchor.type === type)\n\t\t\t\t\t\t  console.log(\"anchor  Type\",head.type === type)\n\t\t\t\t\t  }\n\t\t\t\t\t  //if (anchor !== null && head !== null && anchor.type === type && head.type === type) {\n\t\t\t\t\t  if (anchor !== null && head !== null ) {\n\t\t\t\t\t\tlet from, to;\n\t\t\t\t\t\tif (head.index < anchor.index) {\n\t\t\t\t\t\t  from = head.index\n\t\t\t\t\t\t  to = anchor.index\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(debug)\n\t\t\t\t\t\t\t\tconsole.log(anchor.index)\n\t\t\t\t\t\t  from = anchor.index\n\t\t\t\t\t\t  to = head.index\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(debug)\n\t\t\t\t\t\t\tconsole.log(\"Draw Cursor \",from,to,clientId,aw.user)\n\t\t\t\t\t\tlet t_info = this.parseTypeName(cursor.anchor['tname']);\n\t\t\t\t\t\tlet id_mirror = t_info.document_id + t_info.name+'--mirror-div';\n\t\t\t\t\t\tlet json = {};\n\t\t\t\t\t\tlet selector = '[data-collection=\"'+t_info.collection+'\"][data-document_id=\"'+t_info.document_id+'\"][name=\"'+t_info.name+'\"]'\n\t\t\t\t\t\tselector += ':not(.codemirror):not(.quill):not(.monaco)';\n\t\t\t\t\t\tlet elements = document.querySelectorAll(selector);\n\t\t\t\t\t\tlet that = this;\n\t\t\t\t\t\telements.forEach(function (element, index, array) {\n\t\t\t\t\t\t\tjson = {\n\t\t\t\t\t\t\t\telement:element,\n\t\t\t\t\t\t\t\tstartPosition:from,\n\t\t\t\t\t\t\t\tselector:selector,\n\t\t\t\t\t\t\t\tendPositon:to,\n\t\t\t\t\t\t\t\tclientId : clientId,\n\t\t\t\t\t\t\t\tuser:{\n\t\t\t\t\t\t\t\t\t'color':user.color,\n\t\t\t\t\t\t\t\t\t'name':user.name\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tconsole.log(json)\n\t\t\t\t\t\t\t_cocreate_cursors__WEBPACK_IMPORTED_MODULE_1__.default.draw_cursor(json);\n\t\t\t\t\t\t\t//sent custom position\n\t\t\t\t\t\t\tthat.listen(json);\n\t\t\t\t\t\t});\n\t\t\t\t\t  }\n\t\t}\n\t}\n\t\n\tchangeListenAwereness(callback){\n\t\tthis.listenAwereness = callback;\n\t}\n\t\n\tlisten(json){\n\t\tthis.listenAwereness.apply(this,[json])\n\t}\n\t\n\tdestroyObserver(id, element) {\n\t\tconst info = this.parseType(id)\n\t\tthis.docs[info.id].doc.getText(id).unobserve((event) => {});\n\t\t\n\t\tthis.docs[info.id].socket.awareness.off('change', this._awarenessListener);\n\t}\n\t\n\tgetProvider(id){\n\t\tconst info = this.parseType(id)\n\t\tif (!this.docs[info.id]) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.docs[info.id].socket;\n\t}\n\t\n\tgetType(id){\n\t\tconst info = this.parseType(id)\n\t\tif (!this.docs[info.id]) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.docs[info.id].doc.getText(id);\n\t}\n\n\tsetCursorNull(id){\n\t\tconst info = this.parseType(id)\n\t\tif (!this.docs[info.id]) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tthis.docs[info.id].socket.awareness.setLocalStateField('cursor', null);\n\t}\n\t\n\tsetPositionYJS(id, from, to) {\n\t\tconst info = this.parseType(id)\n\t\tconst type = this.getType(id);\n\t\t//console.log(\"Type \",type)\n\t\tif (!type) {\n\t\t\treturn;\n\t\t}\n\t\tvar anchor = yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromTypeIndex(type, from)\n\t\tvar head = yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromTypeIndex(type, to)\n\t\t\n\t\tif(debug)\n\t\t\tconsole.log(\"Sending Cursor \",{\n\t\t\t\tanchor,\n\t\t\t\thead\n\t\t\t},{'to':to,'from':from,'info.id':info.id})\n\t\t\n\t\tthis.docs[info.id].socket.awareness.setLocalStateField('cursor', {\n\t\t\tanchor,\n\t\t\thead\n\t\t})\n\t\t/*\n\t\tif(debug)\n\t\t\tconsole.log(\"Cursor Send\")\n\t\t\t*/\n\t}\n\t\n\t//send Position Custom\n\tsendPosition(json) {\n\t\tlet collection = json['collection'];\n\t\tlet document_id = json['document_id'];\n\t\tlet name = json['name'];\n\t\tlet from = json['startPosition'];\n\t\tlet to = json['endPositon'];\n\t\tlet id = this.generateID(config.organization_Id, collection, document_id, name);\n\t\tthis.setPositionYJS(id,from,to);\n\t}\n\t\n\tgenerateID(org, collection, document_id, name) {\n\t\tconst info = {org, collection, document_id, name}\n\t\treturn btoa(JSON.stringify(info));        \n\t}\n\t\n\tparseTypeName(name) {\n\t\tconst data = JSON.parse(atob(name));\n\t\treturn data;\n\t}\n\t\n\tparseType(id) {\n\t\tlet data = JSON.parse(atob(id));\n\t\t\n\t\tlet newId = {org: data.org, collection: data.collection, document_id: data.document_id}\n\t\treturn {\n\t\t\tid: btoa(JSON.stringify(newId)),\n\t\t\tname: data.name,\n\t\t\tdocument_id: data.document_id\n\t\t}\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateYSocket);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3JkdC9zcmMvY29yZS5qcz8yZGZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ3dCO0FBQ3VCO0FBQzZCO0FBQ25DO0FBQ007O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSwyQkFBMkIsMERBQWlCO0FBQzVDO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQW9CO0FBQy9DO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUyxLQUFLLE9BQU87QUFDM0M7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsSUFBSTtBQUNKLG9CQUFvQixTQUFTLEtBQUssbUJBQW1CO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPLHVFQUFlO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLElBQUksMkVBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQixvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHNCQUFzQiwyRUFBNEMsQ0FBQywrREFBZ0M7QUFDbkcsb0JBQW9CLDJFQUE0QyxDQUFDLCtEQUFnQztBQUNqRyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLE9BQU8sa0VBQTJCO0FBQ2xDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9FQUFxQztBQUNwRCxhQUFhLG9FQUFxQzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsc0NBQXNDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQixvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3JkdC9zcmMvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBXZWJzb2NrZXRQcm92aWRlciB9IGZyb20gJ3ktd2Vic29ja2V0J1xuaW1wb3J0IHsgZmV0Y2hVcGRhdGVzLCBzdG9yZVN0YXRlLCBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gJ3ktaW5kZXhlZGRiJ1xuaW1wb3J0IGNydWQgZnJvbSAnQGNvY3JlYXRlL2NydWQtY2xpZW50JztcbmltcG9ydCBDb0NyZWF0ZUN1cnNvcnMgZnJvbSAnQGNvY3JlYXRlL2N1cnNvcnMnXG5cbmNvbnN0IGRlYnVnID0gZmFsc2U7XG5cbmNsYXNzIENvQ3JlYXRlWVNvY2tldCB7XG5cdGNvbnN0cnVjdG9yKG9yZywgeWRvYykge1xuXHRcdHRoaXMuZG9jID0geWRvYztcblx0XHR0aGlzLm9yZ05hbWUgPSBvcmc7XG5cdFx0dGhpcy5kb2NzID0ge307XG5cdFx0dGhpcy5fYXdhcmVuZXNzTGlzdGVuZXIgPSBudWxsO1xuXHRcdHRoaXMuY2hhcmFjdGVyID0gJ18nO1xuXHRcdHRoaXMubGlzdGVuQXdlcmVuZXNzID0gZnVuY3Rpb24oKXt9XG5cdH1cblx0XG5cdGNyZWF0ZURvYyhpZCwgZWxlbWVudCkge1xuXHRcdGlmICghaWQgfHwgaWQgPT0gXCJcIikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdGxldCBuZXdJbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0Ly8gaWYoZGVidWcpXG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhuZXdJbmZvKTtcblx0XHRcblx0XHRjb25zdCBuZXdJZCA9IG5ld0luZm8uaWQ7XG5cdFx0XG5cdFx0aWYgKHRoaXMuZG9jc1tuZXdJZF0pIHsgXG5cdFx0XHRpZiAoZWxlbWVudCAmJiAhdGhpcy5fX2NoZWNrRXhpc3RFbGVtZW50KHRoaXMuZG9jc1tuZXdJZF0uZWxlbWVudHMsIGVsZW1lbnQpKSB7XG5cdFx0XHRcdHRoaXMuZG9jc1tuZXdJZF0uZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLmRvY3NbbmV3SWRdLnR5cGVzLnNvbWUoKHR5cGUpID0+IHR5cGUgPT09IGlkKSkge1xuXHRcdFx0XHQvLyByZWdpc3RlciBldmVudFxuXHRcdFx0XHR0aGlzLmRvY3NbbmV3SWRdLnR5cGVzLnB1c2goaWQpO1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyVXBkYXRlRXZlbnQodGhpcy5kb2NzW25ld0lkXSwgaWQpXG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gXG5cdFx0XG5cdFx0Y29uc3QgeURvYyA9IHRoaXMuZG9jXG5cdFx0XG5cdFx0Y29uc3QgdXJsX3NvY2tldCA9IHRoaXMuX19nZXRTb2NrZXRVcmwoKTtcblx0XHQvL2RyYXcgY3Vyc29yIGRpbmFtaWFsbHlcblx0XHQvLyBuZXcgVXNlckN1cnNvcihzb2NrZXRQcm92aWRlcik7XG5cblx0XHRcdFxuXHRcdHZhciBzb2NrZXRQcm92aWRlciA9IG5ldyBXZWJzb2NrZXRQcm92aWRlcih1cmxfc29ja2V0LCBuZXdJZCwgeURvYyk7XG5cdFx0bGV0IGluZGV4ZWRkYlByb3ZpZGVyID0gbnVsbDtcblx0XHRpZiAobmV3SW5mby5kb2N1bWVudF9pZCAhPSBcIm51bGxcIikge1xuXHRcdFx0aW5kZXhlZGRiUHJvdmlkZXIgPSBuZXcgSW5kZXhlZGRiUGVyc2lzdGVuY2UobmV3SWQsIHRoaXMuZG9jKVxuXHRcdFx0aW5kZXhlZGRiUHJvdmlkZXIud2hlblN5bmNlZC50aGVuKCgpID0+IHtcblx0XHRcdCAgY29uc29sZS5sb2coJ2xvYWRlZCBkYXRhIGZyb20gaW5kZXhlZCBkYicpXG5cdFx0XHR9KVxuXHRcdH1cdFxuXHRcdFxuXHRcdGxldCBhd2FyZW5lc3MgPSBzb2NrZXRQcm92aWRlci5hd2FyZW5lc3M7XG5cdFx0XG5cdFx0dGhpcy5fY3Vyc29ycyA9IG5ldyBNYXAoKTtcblx0XHRcblx0XHR0aGlzLl9hd2FyZW5lc3NMaXN0ZW5lciA9IGV2ZW50ID0+IHtcblx0XHQgIGNvbnN0IGYgPSBjbGllbnRJZCA9PiB7XG5cdFx0XHRpZiAoY2xpZW50SWQgIT09IHRoaXMuZG9jLmNsaWVudElEKSB7XG5cdFx0XHQgIHRoaXMudXBkYXRlUmVtb3RlU2VsZWN0aW9uKHlEb2MsIGlkLCB5RG9jLmdldFRleHQoaWQpLCB0aGlzLl9jdXJzb3JzLCBjbGllbnRJZCwgYXdhcmVuZXNzKVxuXHRcdFx0fVxuXHRcdCAgfVxuXHRcdCAgZXZlbnQuYWRkZWQuZm9yRWFjaChmKVxuXHRcdCAgZXZlbnQucmVtb3ZlZC5mb3JFYWNoKGYpXG5cdFx0ICBldmVudC51cGRhdGVkLmZvckVhY2goZilcblx0XHR9XG5cdFx0XG5cdFx0YXdhcmVuZXNzLm9uKCdjaGFuZ2UnLCB0aGlzLl9hd2FyZW5lc3NMaXN0ZW5lcik7XG5cdFx0Lypcblx0XHRhd2FyZW5lc3MuZ2V0U3RhdGVzKCkuZm9yRWFjaCgoYXcsIGNsaWVudElkKSA9PiB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlVwZGF0ZSAtLVwiKVxuICAgICAgICB9KVxuICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgdGhpcy5kb2NzW25ld0lkXSA9IHtcblx0XHRcdGlkOiBuZXdJZCxcblx0XHRcdGRvYzogeURvYyxcblx0XHRcdHNvY2tldDogc29ja2V0UHJvdmlkZXIsXG5cdFx0XHRhd2FyZW5lc3M6IGF3YXJlbmVzcyxcblx0XHRcdGVsZW1lbnRzOiBlbGVtZW50ID8gW2VsZW1lbnRdIDogW10sXG5cdFx0XHR0eXBlczogW2lkXSxcblx0XHRcdGluZGV4ZWRkYjogaW5kZXhlZGRiUHJvdmlkZXJcblx0XHR9XG5cdFx0dGhpcy5yZWdpc3RlclVwZGF0ZUV2ZW50KHRoaXMuZG9jc1tuZXdJZF0sIGlkKVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdHJlZ2lzdGVyVXBkYXRlRXZlbnQoZG9jT2JqZWN0LCBpZCkge1xuXHRcdGNvbnN0IHlEb2MgPSBkb2NPYmplY3QuZG9jO1xuXHRcdGNvbnN0IHNoYXJkVHlwZSA9IHlEb2MuZ2V0VGV4dChpZClcblx0XHRsZXQgX3RoaXMgPSB0aGlzO1xuXHRcdFxuXHRcdHNoYXJkVHlwZS5vYnNlcnZlKChldmVudCkgPT4ge1xuXHRcdFx0X3RoaXMuX19zZXRUeXBlT2JzZXJ2ZUV2ZW50KGV2ZW50LCBkb2NPYmplY3QuZWxlbWVudHMsIGlkKTtcblx0XHR9KVxuXHR9XG5cdFxuXHRfX2NoZWNrRXhpc3RFbGVtZW50KGVsZW1lbnRzLCBlbGVtZW50KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGVsZW1lbnRzW2ldLmlzU2FtZU5vZGUoZWxlbWVudCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0X19nZXRTb2NrZXRVcmwoKSB7XG5cdFx0Y29uc29sZS5sb2coXCJnZXRfc29ja2V0IHVybFwiKVxuXHRcdGxldCB3X2xvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uIHx8IHdpbmRvdy5wYXJlbnQubG9jYXRpb247XG5cdFx0bGV0IHdfcHJvdG9jb2wgPSB3X2xvY2F0aW9uLnByb3RvY29sO1xuXHRcdGxldCB3X2hvc3QgPSB3X2xvY2F0aW9uLmhvc3Q7XG5cdFx0aWYgKHdfbG9jYXRpb24ucHJvdG9jb2wgPT09IFwiYWJvdXQ6XCIpIHtcblx0XHRcdHdfcHJvdG9jb2wgPSB3X2xvY2F0aW9uLnByb3RvY29sO1xuXHRcdFx0d19ob3N0ID0gZG9jdW1lbnQucmVmZXJyZXI7XG5cdFx0fVxuXHRcdGxldCBwcm90b2NvbCA9IHdfcHJvdG9jb2wgPT09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG5cblx0XHRsZXQgdXJsX3NvY2tldCA9IGAke3Byb3RvY29sfTovLyR7d19ob3N0fTo4MDgwL2A7XG5cdFx0aWYgKHdpbmRvdy5jb25maWcgJiYgd2luZG93LmNvbmZpZy5ob3N0KSB7XG5cdFx0XHRpZiAod2luZG93LmNvbmZpZy5ob3N0LmluY2x1ZGVzKFwiOi8vXCIpKSB7XG5cdFx0XHRcdHVybF9zb2NrZXQgPSBgJHt3aW5kb3cuY29uZmlnLmhvc3R9L2A7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR1cmxfc29ja2V0ID0gYCR7cHJvdG9jb2x9Oi8vJHt3aW5kb3cuY29uZmlnLmhvc3R9L2A7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnNvbGUubG9nKHVybF9zb2NrZXQpXG5cdFx0dXJsX3NvY2tldCArPSBcImNyZHQvXCI7XG5cdFx0XG5cdFx0cmV0dXJuIHVybF9zb2NrZXQ7XG5cblx0fVxuXHRcblx0X19zZXRUeXBlT2JzZXJ2ZUV2ZW50KGV2ZW50LCBlbGVtZW50cywgaWQpIHtcblx0XHRjb25zb2xlLmxvZygnc2V0IGNyZHQgZXZlbnQnLCBldmVudC5kZWx0YSlcblx0XHRpZiAoIWlkKSByZXR1cm47XG5cblx0XHRjb25zdCBldmVudERlbHRhID0gZXZlbnQuZGVsdGE7XG5cdFx0XG5cdFx0aWYgKGV2ZW50RGVsdGEubGVuZ3RoID09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgaW5mbyA9IEpTT04ucGFyc2UoYXRvYihpZCkpO1xuXHRcdGxldCBpc19zYXZlX3ZhbHVlID0gZmFsc2Vcblx0XHRcblx0XHRjb25zdCB3aG9sZXN0cmluZyA9IGV2ZW50LnRhcmdldC50b1N0cmluZygpXG5cdFx0Y29uc3Qgc3RvcmVfZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3N0b3JlLWNvbnRlbnQtZGInLCB7XG5cdFx0XHRkZXRhaWw6IHdob2xlc3RyaW5nXG5cdFx0fSlcblx0XHRcblx0XHRjb25zdCB1cGRhdGVfZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NvY3JlYXRlLWNyZHQtdXBkYXRlJywge1xuXHRcdFx0ZGV0YWlsOiBldmVudERlbHRhXG5cdFx0fSlcblx0XHRlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuXHRcdFx0aWYgKGNydWQuaXNSZWFkQXR0cihlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKCduYW1lJykgPT09IGluZm8ubmFtZSkge1xuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KHVwZGF0ZV9ldmVudClcblx0XHRcdH1cblx0XHR9KVxuXHRcdFx0XG5cdFx0XG5cdFx0aWYgKHR5cGVvZiBpbmZvICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC50cmFuc2FjdGlvbi5sb2NhbCkge1xuXHRcdFx0aWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdGlzX3NhdmVfdmFsdWUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcblx0XHRcdFx0aWYgKGNydWQuaXNTYXZlQXR0cihlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKCduYW1lJykgPT09IGluZm8ubmFtZSAmJiBpbmZvLmRvY3VtZW50X2lkICE9IFwibnVsbFwiKSB7XG5cdFx0XHRcdFx0aXNfc2F2ZV92YWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChzdG9yZV9ldmVudClcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdFx0aWYgKGlzX3NhdmVfdmFsdWUpIHtcblx0XHRcdFx0Y3J1ZC51cGRhdGVEb2N1bWVudCh7XG5cdFx0XHRcdFx0Y29sbGVjdGlvbjogaW5mby5jb2xsZWN0aW9uLFxuXHRcdFx0XHRcdGRvY3VtZW50X2lkOiBpbmZvLmRvY3VtZW50X2lkLFxuXHRcdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRcdFtpbmZvLm5hbWVdOiB3aG9sZXN0cmluZ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bWV0YWRhdGE6ICd5anMtY2hhbmdlJ1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHR9XG5cdH1cblx0XG5cdGRlbGV0ZURvYyhpZCkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAodGhpcy5kb2NzW2luZm8uaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5kb2NzW2luZm8uaWRdO1xuXHRcdH1cblx0fVxuXHRcblx0Z2VuZXJhdGVEb2NOYW1lKGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lKSB7XG5cdFx0Y29uc3QgaW5mbyA9IHtvcmc6IHRoaXMub3JnTmFtZSwgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWV9XG5cdFx0cmV0dXJuIGJ0b2EoSlNPTi5zdHJpbmdpZnkoaW5mbykpOyBcblx0XHQvLyByZXR1cm4gdGhpcy5vcmdOYW1lICsgXCJfXCIgKyBjb2xsZWN0aW9uICsgXCJfXCIgKyBkb2N1bWVudF9pZCArIFwiX1wiICsgbmFtZTtcblx0fVxuXHRcblx0aW5zZXJ0RGF0YShpZCwgaW5kZXgsIGNvbnRlbnQsIGF0dHJpYnV0ZSkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAodGhpcy5kb2NzW2luZm8uaWRdKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCkuaW5zZXJ0KGluZGV4LCBjb250ZW50LCBhdHRyaWJ1dGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCkuaW5zZXJ0KGluZGV4LCBjb250ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdGRlbGV0ZURhdGEoaWQsIGluZGV4LCBsZW5ndGgpIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKHRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0dGhpcy5kb2NzW2luZm8uaWRdLmRvYy5nZXRUZXh0KGlkKS5kZWxldGUoaW5kZXgsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdFxuXHRnZXRXaG9sZVN0cmluZyhpZCkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAodGhpcy5kb2NzW2luZm8uaWRdKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIiFHZXQgZGF0YVwiKVxuXHRcdFx0cmV0dXJuIHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCkudG9TdHJpbmcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiLS1cIjtcblx0XHR9XG5cdH1cblx0XG5cdHVwZGF0ZVJlbW90ZVNlbGVjdGlvbiAoeSwgY20sIHR5cGUsIGN1cnNvcnMsIGNsaWVudElkLCBhd2FyZW5lc3MpICB7XG5cdFx0aWYoZGVidWcpXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiQ0hBTkdFIC0tLS0gRE9DSUQgXCIsdGhpcy5kb2MuY2xpZW50SUQsJyBPVEhFUiBDTElFTlRFSUQgJyxjbGllbnRJZClcblx0XHRpZihjbGllbnRJZCAhPT0gdGhpcy5kb2MuY2xpZW50SUQpe1xuXHRcdFx0XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIlRFWFQgLT4gdXBkYXRlUmVtb3RlU2VsZWN0aW9uIFwiLGNsaWVudElkLGF3YXJlbmVzcyxjdXJzb3IpXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkFXIHN0YXR1c1wiLGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkpXG5cdFx0XHRcdFx0ICAvLyBkZXN0cm95IGN1cnJlbnQgdGV4dCBtYXJrXG5cdFx0XHRcdFx0ICBjb25zdCBtID0gY3Vyc29ycy5nZXQoY2xpZW50SWQpXG5cdFx0XHRcdFx0ICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRtLmNhcmV0LmNsZWFyKClcblx0XHRcdFx0XHRcdGlmIChtLnNlbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ICBtLnNlbC5jbGVhcigpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJzb3JzLmRlbGV0ZShjbGllbnRJZClcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIC8vIHJlZHJhdyBjYXJldCBhbmQgc2VsZWN0aW9uIGZvciBjbGllbnRJZFxuXHRcdFx0XHRcdCAgY29uc3QgYXcgPSBhd2FyZW5lc3MuZ2V0U3RhdGVzKCkuZ2V0KGNsaWVudElkKTtcblx0XHRcdFx0XHQgIGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYXcpXG5cdFx0XHRcdFx0ICBpZiAoYXcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0ICBpZihkZWJ1Zylcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCIgQ3Vyc29yIE9VVCBcIixjbGllbnRJZClcblx0XHRcdFx0XHRcdCAgIC8vYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywgbnVsbCk7XG5cdFx0XHRcdFx0XHQgICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWQqPVwic29ja2V0XycrY2xpZW50SWQrJ1wiXScpO1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRsZXQgc2VsX2VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkKj1cInNlbC0nK2NsaWVudElkKydcIl0nKTtcblx0XHRcdFx0XHRcdFx0ICBzZWxfZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VsX2VsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbF9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsX2VsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0ICAvKlxuXHRcdFx0XHRcdFx0ICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvY2tldF9cIitjbGllbnRJZClcblx0XHRcdFx0XHRcdCAgIGxldCBzZWxfZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VsLVwiK2NsaWVudElkKVxuXHRcdFx0XHRcdFx0ICAgaWYoZWxlbWVudClcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRpZihzZWxfZWxlbWVudClcblx0XHRcdFx0XHRcdFx0c2VsX2VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxfZWxlbWVudCk7XG5cdFx0XHRcdFx0XHQgICAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICBjb25zdCB1c2VyID0gYXcudXNlciB8fCB7fVxuXHRcdFx0XHRcdCAgaWYgKHVzZXIuY29sb3IgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dXNlci5jb2xvciA9ICcjZmZhNTAwJ1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdCAgaWYgKHVzZXIubmFtZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR1c2VyLm5hbWUgPSBgVXNlcjogJHtjbGllbnRJZH1gXG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICBjb25zdCBjdXJzb3IgPSBhdy5jdXJzb3Jcblx0XHRcdFx0XHQgIGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJDdXJzb3IgXCIsY3Vyc29yKVxuXHRcdFx0XHRcdCAgaWYgKGN1cnNvciA9PSBudWxsIHx8IGN1cnNvci5hbmNob3IgPT0gbnVsbCB8fCBjdXJzb3IuaGVhZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHQgIC8vbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvY2tldF9cIitjbGllbnRJZClcblx0XHRcdFx0XHRcdCAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkKj1cInNvY2tldF8nK2NsaWVudElkKydcIl0nKTtcblx0XHRcdFx0XHRcdCAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0XHRcdCAgfSlcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly9sZXQgc2VsX2VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlbC1cIitjbGllbnRJZCkgIFxuXHRcdFx0XHRcdFx0bGV0IHNlbF9lbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJzZWwtJytjbGllbnRJZCsnXCJdJyk7XG5cdFx0XHRcdFx0XHQgIHNlbF9lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxfZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdHNlbF9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsX2VsZW1lbnQpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcblx0XHRcdFx0XHQgIGNvbnN0IGFuY2hvciA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnNvci5hbmNob3IpLCB5KVxuXHRcdFx0XHRcdCAgY29uc3QgaGVhZCA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnNvci5oZWFkKSwgeSlcblx0XHRcdFx0XHQgIC8vQ29DcmVhdGUuY3Vyc29ycy5kcmF3X2N1cnNvcigxLDExLDEyLDY2LHt9LHRydWUpO1xuXHRcdFx0XHRcdCAgaWYoZGVidWcpe1xuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhcIlBSRSBEcmF3IEN1cnNvciBcIilcblx0XHRcdFx0XHRcdCAgY29uc29sZS5sb2coXCJhbmNob3IgIFwiLGFuY2hvciAsIFwiIGhlYWQgXCIsaGVhZCwnIFR5cGUgJyx0eXBlKVxuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhcImFuY2hvciAgVHlwZVwiLGFuY2hvci50eXBlID09PSB0eXBlKVxuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhcImFuY2hvciAgVHlwZVwiLGhlYWQudHlwZSA9PT0gdHlwZSlcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIC8vaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsICYmIGFuY2hvci50eXBlID09PSB0eXBlICYmIGhlYWQudHlwZSA9PT0gdHlwZSkge1xuXHRcdFx0XHRcdCAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bGV0IGZyb20sIHRvO1xuXHRcdFx0XHRcdFx0aWYgKGhlYWQuaW5kZXggPCBhbmNob3IuaW5kZXgpIHtcblx0XHRcdFx0XHRcdCAgZnJvbSA9IGhlYWQuaW5kZXhcblx0XHRcdFx0XHRcdCAgdG8gPSBhbmNob3IuaW5kZXhcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGFuY2hvci5pbmRleClcblx0XHRcdFx0XHRcdCAgZnJvbSA9IGFuY2hvci5pbmRleFxuXHRcdFx0XHRcdFx0ICB0byA9IGhlYWQuaW5kZXhcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRyYXcgQ3Vyc29yIFwiLGZyb20sdG8sY2xpZW50SWQsYXcudXNlcilcblx0XHRcdFx0XHRcdGxldCB0X2luZm8gPSB0aGlzLnBhcnNlVHlwZU5hbWUoY3Vyc29yLmFuY2hvclsndG5hbWUnXSk7XG5cdFx0XHRcdFx0XHRsZXQgaWRfbWlycm9yID0gdF9pbmZvLmRvY3VtZW50X2lkICsgdF9pbmZvLm5hbWUrJy0tbWlycm9yLWRpdic7XG5cdFx0XHRcdFx0XHRsZXQganNvbiA9IHt9O1xuXHRcdFx0XHRcdFx0bGV0IHNlbGVjdG9yID0gJ1tkYXRhLWNvbGxlY3Rpb249XCInK3RfaW5mby5jb2xsZWN0aW9uKydcIl1bZGF0YS1kb2N1bWVudF9pZD1cIicrdF9pbmZvLmRvY3VtZW50X2lkKydcIl1bbmFtZT1cIicrdF9pbmZvLm5hbWUrJ1wiXSdcblx0XHRcdFx0XHRcdHNlbGVjdG9yICs9ICc6bm90KC5jb2RlbWlycm9yKTpub3QoLnF1aWxsKTpub3QoLm1vbmFjbyknO1xuXHRcdFx0XHRcdFx0bGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHRcdFx0XHRsZXQgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0anNvbiA9IHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50OmVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRQb3NpdGlvbjpmcm9tLFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdG9yOnNlbGVjdG9yLFxuXHRcdFx0XHRcdFx0XHRcdGVuZFBvc2l0b246dG8sXG5cdFx0XHRcdFx0XHRcdFx0Y2xpZW50SWQgOiBjbGllbnRJZCxcblx0XHRcdFx0XHRcdFx0XHR1c2VyOntcblx0XHRcdFx0XHRcdFx0XHRcdCdjb2xvcic6dXNlci5jb2xvcixcblx0XHRcdFx0XHRcdFx0XHRcdCduYW1lJzp1c2VyLm5hbWVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGpzb24pXG5cdFx0XHRcdFx0XHRcdENvQ3JlYXRlQ3Vyc29ycy5kcmF3X2N1cnNvcihqc29uKTtcblx0XHRcdFx0XHRcdFx0Ly9zZW50IGN1c3RvbSBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHR0aGF0Lmxpc3Rlbihqc29uKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdCAgfVxuXHRcdH1cblx0fVxuXHRcblx0Y2hhbmdlTGlzdGVuQXdlcmVuZXNzKGNhbGxiYWNrKXtcblx0XHR0aGlzLmxpc3RlbkF3ZXJlbmVzcyA9IGNhbGxiYWNrO1xuXHR9XG5cdFxuXHRsaXN0ZW4oanNvbil7XG5cdFx0dGhpcy5saXN0ZW5Bd2VyZW5lc3MuYXBwbHkodGhpcyxbanNvbl0pXG5cdH1cblx0XG5cdGRlc3Ryb3lPYnNlcnZlcihpZCwgZWxlbWVudCkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHR0aGlzLmRvY3NbaW5mby5pZF0uZG9jLmdldFRleHQoaWQpLnVub2JzZXJ2ZSgoZXZlbnQpID0+IHt9KTtcblx0XHRcblx0XHR0aGlzLmRvY3NbaW5mby5pZF0uc29ja2V0LmF3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIHRoaXMuX2F3YXJlbmVzc0xpc3RlbmVyKTtcblx0fVxuXHRcblx0Z2V0UHJvdmlkZXIoaWQpe1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAoIXRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmRvY3NbaW5mby5pZF0uc29ja2V0O1xuXHR9XG5cdFxuXHRnZXRUeXBlKGlkKXtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKCF0aGlzLmRvY3NbaW5mby5pZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kb2NzW2luZm8uaWRdLmRvYy5nZXRUZXh0KGlkKTtcblx0fVxuXG5cdHNldEN1cnNvck51bGwoaWQpe1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAoIXRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5zb2NrZXQuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywgbnVsbCk7XG5cdH1cblx0XG5cdHNldFBvc2l0aW9uWUpTKGlkLCBmcm9tLCB0bykge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGlkKTtcblx0XHQvL2NvbnNvbGUubG9nKFwiVHlwZSBcIix0eXBlKVxuXHRcdGlmICghdHlwZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgYW5jaG9yID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCBmcm9tKVxuXHRcdHZhciBoZWFkID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCB0bylcblx0XHRcblx0XHRpZihkZWJ1Zylcblx0XHRcdGNvbnNvbGUubG9nKFwiU2VuZGluZyBDdXJzb3IgXCIse1xuXHRcdFx0XHRhbmNob3IsXG5cdFx0XHRcdGhlYWRcblx0XHRcdH0seyd0byc6dG8sJ2Zyb20nOmZyb20sJ2luZm8uaWQnOmluZm8uaWR9KVxuXHRcdFxuXHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5zb2NrZXQuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywge1xuXHRcdFx0YW5jaG9yLFxuXHRcdFx0aGVhZFxuXHRcdH0pXG5cdFx0Lypcblx0XHRpZihkZWJ1Zylcblx0XHRcdGNvbnNvbGUubG9nKFwiQ3Vyc29yIFNlbmRcIilcblx0XHRcdCovXG5cdH1cblx0XG5cdC8vc2VuZCBQb3NpdGlvbiBDdXN0b21cblx0c2VuZFBvc2l0aW9uKGpzb24pIHtcblx0XHRsZXQgY29sbGVjdGlvbiA9IGpzb25bJ2NvbGxlY3Rpb24nXTtcblx0XHRsZXQgZG9jdW1lbnRfaWQgPSBqc29uWydkb2N1bWVudF9pZCddO1xuXHRcdGxldCBuYW1lID0ganNvblsnbmFtZSddO1xuXHRcdGxldCBmcm9tID0ganNvblsnc3RhcnRQb3NpdGlvbiddO1xuXHRcdGxldCB0byA9IGpzb25bJ2VuZFBvc2l0b24nXTtcblx0XHRsZXQgaWQgPSB0aGlzLmdlbmVyYXRlSUQoY29uZmlnLm9yZ2FuaXphdGlvbl9JZCwgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUpO1xuXHRcdHRoaXMuc2V0UG9zaXRpb25ZSlMoaWQsZnJvbSx0byk7XG5cdH1cblx0XG5cdGdlbmVyYXRlSUQob3JnLCBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSkge1xuXHRcdGNvbnN0IGluZm8gPSB7b3JnLCBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZX1cblx0XHRyZXR1cm4gYnRvYShKU09OLnN0cmluZ2lmeShpbmZvKSk7ICAgICAgICBcblx0fVxuXHRcblx0cGFyc2VUeXBlTmFtZShuYW1lKSB7XG5cdFx0Y29uc3QgZGF0YSA9IEpTT04ucGFyc2UoYXRvYihuYW1lKSk7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblx0XG5cdHBhcnNlVHlwZShpZCkge1xuXHRcdGxldCBkYXRhID0gSlNPTi5wYXJzZShhdG9iKGlkKSk7XG5cdFx0XG5cdFx0bGV0IG5ld0lkID0ge29yZzogZGF0YS5vcmcsIGNvbGxlY3Rpb246IGRhdGEuY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQ6IGRhdGEuZG9jdW1lbnRfaWR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiBidG9hKEpTT04uc3RyaW5naWZ5KG5ld0lkKSksXG5cdFx0XHRuYW1lOiBkYXRhLm5hbWUsXG5cdFx0XHRkb2N1bWVudF9pZDogZGF0YS5kb2N1bWVudF9pZFxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZVlTb2NrZXQ7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crdt/src/core.js\n")},"./node_modules/@cocreate/crdt/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/@cocreate/crdt/src/core.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n\nclass CoCreateCRDTClass extends _core_js__WEBPACK_IMPORTED_MODULE_0__.default \n{\n  constructor(org, doc) {\n    super(org, doc)\n  }\n\n  /*\n  crdt.init({\n    collection: \"module\",\n    document_id: \"\",\n    name: \"\",\n    element: dom_object,\n    metadata: \"xxxx\"\n  })\n  */\n  init(info) {\n    try {\n      this.__validateKeysJson(info, ['collection', 'document_id', 'name']);\n      \n      const id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n\n      if (!id) return;\n      const status = this.createDoc(id, info.element)\n      console.log(\"InitCrdt\")\n    } catch(e) {\n      console.log('Invalid param', e);\n    }\n  }\n\n  /*. init data function\n  crdt.replaceText({\n    collection: \"module\",\n    document_id: \"\",\n    name: \"\",\n    value: \"\",\n    updateCrud: true | false,\n    element: dom_object,\n    metadata: \"xxxx\"\n  })\n  */\n  \n  replaceText(info){\n    if (!info) return;\n    \n    const id = this.__getYDocId(info.collection, info.document_id, info.name)\n    if (!id) return;\n\n    if (info.updateCrud != false) info.updateCrud = true;\n    \n    if (this.getType(id) ) {\n      let oldData = this.getType(id).toString();\n      let textValue = info.value.toString();\n      if (oldData && oldData.length > 0) {\n        this.deleteData(id, 0, Math.max(oldData.length, textValue.length));\n      }\n      this.insertData(id, 0, textValue);\n    }\n    if (info.updateCrud) {\n      _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().updateDocument({\n        collection: info.collection,\n        document_id: info.document_id,\n        data: {[info.name]: info.value},\n        element: info.element,\n        metadata:info.metadata,\n        namespace: info.namespace,\n        room: info.room,\n        broadcast: info.broadcast,\n        upsert: info.upsert,\n        broadcast_sender: info.broadcast_sender\n      })\n    }\n  }\n  \n  /*\n  crdt.insertText({\n  \tcollection: 'module_activities',\n  \tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n  \tname: 'name',\n  \tvalue: 'T',\n  \tposition: '8',\n  \tattributes: {bold: true}\n  })\n  */\n  insertText(info) {\n      try {\n        this.__validateKeysJson(info,['collection','document_id','name','value','position']);\n        let id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n        if (id) {\n          this.insertData(id, info['position'], info['value'].toString(), info['attributes']);\n        }\n      }\n      catch (e) {\n        console.error(e); \n      }\n  }\n  \n  \n  /*\n  crdt.deleteText({\n  \tcollection: 'module_activities',\n  \tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n  \tname: 'name',\n  \tposition: '8',\n  \tlength: 2,\n  })\n  */\n  deleteText(info) {\n    try{\n      this.__validateKeysJson(info,['collection','document_id','name', 'position','length']);\n      let id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n      if (id) {\n        this.deleteData(id, info['position'], info['length']);\n      }\n    }\n    catch (e) {\n      console.error(e); \n    }\n  }\n  \n  \n  /*\n  crdt.getText({\n  \tcollection: 'module_activities',\n  \tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n  \tname: 'name'\n  })\n  */\n  getText(info) {\n    try{\n      this.__validateKeysJson(info,['collection','document_id','name']);\n      let id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n      if (id) {\n        return this.getWholeString(id);\n      } else {\n        return \"\";\n      }\n    }\n    catch (e) {\n      console.error(e); \n      return \"\";\n    }\n  }\n\n  \n  /* \n  crdt.getPosition(function(data))\n  crdt.getPosition(function(data){console.log(\" EScuchando ahora  \",data)})\n  */\n  getPosition(callback){\n  if(typeof miFuncion === 'function')\n    this.changeListenAwereness(callback);\n  else\n    console.error('Callback should be a function')\n  }\n \n  __getYDocId(collection, document_id, name) {\n    if (!_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().checkValue(collection) || \n        !_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().checkValue(document_id) || \n        !_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().checkValue(name)) \n    {\n      return null;\n    }\n    return this.generateID(config.organization_Id, collection, document_id, name);\n  }\n  \n  __validateKeysJson(json,rules){\n    let keys_json = Object.keys(json);\n    keys_json.forEach(key=>{\n      const index = rules.indexOf(key);\n      if(index != -1)\n        rules.splice(index, 1);\n    });\n    if( rules.length )\n      throw \"Requires the following \"+ rules.toString();\n  }\n}\n\nlet CoCreateCrdt = null;\nif (!window.CoCreateCrdt) {\n  const crdtDoc = new yjs__WEBPACK_IMPORTED_MODULE_2__.Doc();\n  CoCreateCrdt = new CoCreateCRDTClass(config.organization_Id, crdtDoc);\n  window.Y = yjs__WEBPACK_IMPORTED_MODULE_2__;\n  window.CoCreateCrdt = CoCreateCrdt;\n} else {\n  CoCreateCrdt = window.CoCreateCrdt;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateCrdt);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3JkdC9zcmMvaW5kZXguanM/M2I1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUNmO0FBQ2lCOzs7QUFHekMsZ0NBQWdDLDZDQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJFQUFtQjtBQUN6QjtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQ0FBa0Msd0NBQXdDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx1RUFBZTtBQUN4QixTQUFTLHVFQUFlO0FBQ3hCLFNBQVMsdUVBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixvQ0FBSztBQUMzQjtBQUNBLGFBQWEsZ0NBQUM7QUFDZDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLGlFQUFlLFlBQVksRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3JkdC9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29DcmVhdGVZU29ja2V0IGZyb20gXCIuL2NvcmUuanNcIlxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgY3J1ZCBmcm9tICdAY29jcmVhdGUvY3J1ZC1jbGllbnQnO1xuXG5cbmNsYXNzIENvQ3JlYXRlQ1JEVENsYXNzIGV4dGVuZHMgQ29DcmVhdGVZU29ja2V0IFxue1xuICBjb25zdHJ1Y3RvcihvcmcsIGRvYykge1xuICAgIHN1cGVyKG9yZywgZG9jKVxuICB9XG5cbiAgLypcbiAgY3JkdC5pbml0KHtcbiAgICBjb2xsZWN0aW9uOiBcIm1vZHVsZVwiLFxuICAgIGRvY3VtZW50X2lkOiBcIlwiLFxuICAgIG5hbWU6IFwiXCIsXG4gICAgZWxlbWVudDogZG9tX29iamVjdCxcbiAgICBtZXRhZGF0YTogXCJ4eHh4XCJcbiAgfSlcbiAgKi9cbiAgaW5pdChpbmZvKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX192YWxpZGF0ZUtleXNKc29uKGluZm8sIFsnY29sbGVjdGlvbicsICdkb2N1bWVudF9pZCcsICduYW1lJ10pO1xuICAgICAgXG4gICAgICBjb25zdCBpZCA9IHRoaXMuX19nZXRZRG9jSWQoaW5mb1snY29sbGVjdGlvbiddLCBpbmZvWydkb2N1bWVudF9pZCddLCBpbmZvWyduYW1lJ10pXG5cbiAgICAgIGlmICghaWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuY3JlYXRlRG9jKGlkLCBpbmZvLmVsZW1lbnQpXG4gICAgICBjb25zb2xlLmxvZyhcIkluaXRDcmR0XCIpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBwYXJhbScsIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qLiBpbml0IGRhdGEgZnVuY3Rpb25cbiAgY3JkdC5yZXBsYWNlVGV4dCh7XG4gICAgY29sbGVjdGlvbjogXCJtb2R1bGVcIixcbiAgICBkb2N1bWVudF9pZDogXCJcIixcbiAgICBuYW1lOiBcIlwiLFxuICAgIHZhbHVlOiBcIlwiLFxuICAgIHVwZGF0ZUNydWQ6IHRydWUgfCBmYWxzZSxcbiAgICBlbGVtZW50OiBkb21fb2JqZWN0LFxuICAgIG1ldGFkYXRhOiBcInh4eHhcIlxuICB9KVxuICAqL1xuICBcbiAgcmVwbGFjZVRleHQoaW5mbyl7XG4gICAgaWYgKCFpbmZvKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgaWQgPSB0aGlzLl9fZ2V0WURvY0lkKGluZm8uY29sbGVjdGlvbiwgaW5mby5kb2N1bWVudF9pZCwgaW5mby5uYW1lKVxuICAgIGlmICghaWQpIHJldHVybjtcblxuICAgIGlmIChpbmZvLnVwZGF0ZUNydWQgIT0gZmFsc2UpIGluZm8udXBkYXRlQ3J1ZCA9IHRydWU7XG4gICAgXG4gICAgaWYgKHRoaXMuZ2V0VHlwZShpZCkgKSB7XG4gICAgICBsZXQgb2xkRGF0YSA9IHRoaXMuZ2V0VHlwZShpZCkudG9TdHJpbmcoKTtcbiAgICAgIGxldCB0ZXh0VmFsdWUgPSBpbmZvLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAob2xkRGF0YSAmJiBvbGREYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5kZWxldGVEYXRhKGlkLCAwLCBNYXRoLm1heChvbGREYXRhLmxlbmd0aCwgdGV4dFZhbHVlLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnNlcnREYXRhKGlkLCAwLCB0ZXh0VmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaW5mby51cGRhdGVDcnVkKSB7XG4gICAgICBjcnVkLnVwZGF0ZURvY3VtZW50KHtcbiAgICAgICAgY29sbGVjdGlvbjogaW5mby5jb2xsZWN0aW9uLFxuICAgICAgICBkb2N1bWVudF9pZDogaW5mby5kb2N1bWVudF9pZCxcbiAgICAgICAgZGF0YToge1tpbmZvLm5hbWVdOiBpbmZvLnZhbHVlfSxcbiAgICAgICAgZWxlbWVudDogaW5mby5lbGVtZW50LFxuICAgICAgICBtZXRhZGF0YTppbmZvLm1ldGFkYXRhLFxuICAgICAgICBuYW1lc3BhY2U6IGluZm8ubmFtZXNwYWNlLFxuICAgICAgICByb29tOiBpbmZvLnJvb20sXG4gICAgICAgIGJyb2FkY2FzdDogaW5mby5icm9hZGNhc3QsXG4gICAgICAgIHVwc2VydDogaW5mby51cHNlcnQsXG4gICAgICAgIGJyb2FkY2FzdF9zZW5kZXI6IGluZm8uYnJvYWRjYXN0X3NlbmRlclxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgXG4gIC8qXG4gIGNyZHQuaW5zZXJ0VGV4dCh7XG4gIFx0Y29sbGVjdGlvbjogJ21vZHVsZV9hY3Rpdml0aWVzJyxcbiAgXHRkb2N1bWVudF9pZDogJzVlNDgwMmNlM2VkOTZkMzhlNzFmYzdlNScsXG4gIFx0bmFtZTogJ25hbWUnLFxuICBcdHZhbHVlOiAnVCcsXG4gIFx0cG9zaXRpb246ICc4JyxcbiAgXHRhdHRyaWJ1dGVzOiB7Ym9sZDogdHJ1ZX1cbiAgfSlcbiAgKi9cbiAgaW5zZXJ0VGV4dChpbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9fdmFsaWRhdGVLZXlzSnNvbihpbmZvLFsnY29sbGVjdGlvbicsJ2RvY3VtZW50X2lkJywnbmFtZScsJ3ZhbHVlJywncG9zaXRpb24nXSk7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuX19nZXRZRG9jSWQoaW5mb1snY29sbGVjdGlvbiddLCBpbmZvWydkb2N1bWVudF9pZCddLCBpbmZvWyduYW1lJ10pXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0RGF0YShpZCwgaW5mb1sncG9zaXRpb24nXSwgaW5mb1sndmFsdWUnXS50b1N0cmluZygpLCBpbmZvWydhdHRyaWJ1dGVzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpOyBcbiAgICAgIH1cbiAgfVxuICBcbiAgXG4gIC8qXG4gIGNyZHQuZGVsZXRlVGV4dCh7XG4gIFx0Y29sbGVjdGlvbjogJ21vZHVsZV9hY3Rpdml0aWVzJyxcbiAgXHRkb2N1bWVudF9pZDogJzVlNDgwMmNlM2VkOTZkMzhlNzFmYzdlNScsXG4gIFx0bmFtZTogJ25hbWUnLFxuICBcdHBvc2l0aW9uOiAnOCcsXG4gIFx0bGVuZ3RoOiAyLFxuICB9KVxuICAqL1xuICBkZWxldGVUZXh0KGluZm8pIHtcbiAgICB0cnl7XG4gICAgICB0aGlzLl9fdmFsaWRhdGVLZXlzSnNvbihpbmZvLFsnY29sbGVjdGlvbicsJ2RvY3VtZW50X2lkJywnbmFtZScsICdwb3NpdGlvbicsJ2xlbmd0aCddKTtcbiAgICAgIGxldCBpZCA9IHRoaXMuX19nZXRZRG9jSWQoaW5mb1snY29sbGVjdGlvbiddLCBpbmZvWydkb2N1bWVudF9pZCddLCBpbmZvWyduYW1lJ10pXG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVEYXRhKGlkLCBpbmZvWydwb3NpdGlvbiddLCBpbmZvWydsZW5ndGgnXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpOyBcbiAgICB9XG4gIH1cbiAgXG4gIFxuICAvKlxuICBjcmR0LmdldFRleHQoe1xuICBcdGNvbGxlY3Rpb246ICdtb2R1bGVfYWN0aXZpdGllcycsXG4gIFx0ZG9jdW1lbnRfaWQ6ICc1ZTQ4MDJjZTNlZDk2ZDM4ZTcxZmM3ZTUnLFxuICBcdG5hbWU6ICduYW1lJ1xuICB9KVxuICAqL1xuICBnZXRUZXh0KGluZm8pIHtcbiAgICB0cnl7XG4gICAgICB0aGlzLl9fdmFsaWRhdGVLZXlzSnNvbihpbmZvLFsnY29sbGVjdGlvbicsJ2RvY3VtZW50X2lkJywnbmFtZSddKTtcbiAgICAgIGxldCBpZCA9IHRoaXMuX19nZXRZRG9jSWQoaW5mb1snY29sbGVjdGlvbiddLCBpbmZvWydkb2N1bWVudF9pZCddLCBpbmZvWyduYW1lJ10pXG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2hvbGVTdHJpbmcoaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpOyBcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxuXG4gIFxuICAvKiBcbiAgY3JkdC5nZXRQb3NpdGlvbihmdW5jdGlvbihkYXRhKSlcbiAgY3JkdC5nZXRQb3NpdGlvbihmdW5jdGlvbihkYXRhKXtjb25zb2xlLmxvZyhcIiBFU2N1Y2hhbmRvIGFob3JhICBcIixkYXRhKX0pXG4gICovXG4gIGdldFBvc2l0aW9uKGNhbGxiYWNrKXtcbiAgaWYodHlwZW9mIG1pRnVuY2lvbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aGlzLmNoYW5nZUxpc3RlbkF3ZXJlbmVzcyhjYWxsYmFjayk7XG4gIGVsc2VcbiAgICBjb25zb2xlLmVycm9yKCdDYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbicpXG4gIH1cbiBcbiAgX19nZXRZRG9jSWQoY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUpIHtcbiAgICBpZiAoIWNydWQuY2hlY2tWYWx1ZShjb2xsZWN0aW9uKSB8fCBcbiAgICAgICAgIWNydWQuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkgfHwgXG4gICAgICAgICFjcnVkLmNoZWNrVmFsdWUobmFtZSkpIFxuICAgIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUlEKGNvbmZpZy5vcmdhbml6YXRpb25fSWQsIGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lKTtcbiAgfVxuICBcbiAgX192YWxpZGF0ZUtleXNKc29uKGpzb24scnVsZXMpe1xuICAgIGxldCBrZXlzX2pzb24gPSBPYmplY3Qua2V5cyhqc29uKTtcbiAgICBrZXlzX2pzb24uZm9yRWFjaChrZXk9PntcbiAgICAgIGNvbnN0IGluZGV4ID0gcnVsZXMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYoaW5kZXggIT0gLTEpXG4gICAgICAgIHJ1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSk7XG4gICAgaWYoIHJ1bGVzLmxlbmd0aCApXG4gICAgICB0aHJvdyBcIlJlcXVpcmVzIHRoZSBmb2xsb3dpbmcgXCIrIHJ1bGVzLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxubGV0IENvQ3JlYXRlQ3JkdCA9IG51bGw7XG5pZiAoIXdpbmRvdy5Db0NyZWF0ZUNyZHQpIHtcbiAgY29uc3QgY3JkdERvYyA9IG5ldyBZLkRvYygpO1xuICBDb0NyZWF0ZUNyZHQgPSBuZXcgQ29DcmVhdGVDUkRUQ2xhc3MoY29uZmlnLm9yZ2FuaXphdGlvbl9JZCwgY3JkdERvYyk7XG4gIHdpbmRvdy5ZID0gWTtcbiAgd2luZG93LkNvQ3JlYXRlQ3JkdCA9IENvQ3JlYXRlQ3JkdDtcbn0gZWxzZSB7XG4gIENvQ3JlYXRlQ3JkdCA9IHdpbmRvdy5Db0NyZWF0ZUNyZHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlQ3JkdDtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crdt/src/index.js\n")},"./node_modules/@cocreate/crud-client/src/crud.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// import {getCommonParams, getCommonParamsExtend, generateSocketClient} from \"@cocreate/socket-client/src/common-fun.js\"\n\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! @cocreate/socket-client/src/common-fun.js */ \"./node_modules/@cocreate/socket-client/src/common-fun.js\"), __webpack_require__(/*! ./utils.crud.js */ \"./node_modules/@cocreate/crud-client/src/utils.crud.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(commonFunc, utilsCrud) {\n        \treturn factory(window, commonFunc, utilsCrud)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== 'undefined' ? self : this, function (wnd, commonFunc, utilsCrud) {\n  \n  const CoCreateCRUD = {\n    socket: null,\n    setSocket: function(socket) {\n      this.socket = socket;\n    },\n\n    readDocumentList(info){\n      if( !info ) return;\n      let request_data = commonFunc.getCommonParams();\n      if (!info.collection || !info.operator) {\n        return;\n      }\n      \n      request_data = {...request_data, ...info};\n      \n      this.socket.send('readDocumentList', request_data);\n    },\n    \n    createDocument: function(info) {\n      if (info === null) {\n        return;\n      }\n      let commonData = commonFunc.getCommonParamsExtend(info);\n      let request_data = {...info, ...commonData};\n  \n      let data = info.data || {};\n      \n      if (!data['organization_id']) {\n        data['organization_id'] = wnd.config.organization_Id\n      }\n      if (info['data']) {\n        data = {...data, ...info['data']}\n      }\n      \n      //. rebuild data\n      request_data['data'] = data;\n  \n      const room = commonFunc.generateSocketClient(info.namespace, info.room);\n      this.socket.send('createDocument', request_data, room);\n    },\n    \n    updateDocument: function(info) {\n      if (!info || !utilsCrud.checkDocumentId(info['document_id'])) return;\n      \n      let commonData = commonFunc.getCommonParamsExtend(info);\n      \n      let request_data = {...info, ...commonData};\n      \n      if( typeof info['data'] === 'object' ) {\n        request_data['set'] = info['data']\n      }\n      if( Array.isArray(info['delete_fields']) ) request_data['unset'] = info['delete_fields'];\n      \n      if(!request_data['set'] && !request_data['unset']) return;\n      \n      if (info.broadcast === false) {\n        request_data['broadcast'] = false;\n      }\n      \n      /** socket parameters **/\n      if (info['broadcast_sender'] === undefined) {\n        request_data['broadcast_sender'] = true;\n      }\n      \n      const room = commonFunc.generateSocketClient(info.namespace, info.room);\n      this.socket.send('updateDocument', request_data, room);\n    },\n    \n    readDocument: function(info) {\n      if (info === null) {\n        return;\n      }\n      \n      if (!info || !utilsCrud.checkDocumentId(info['document_id'])) {\n        return;\n      }\n      \n      let commonData = commonFunc.getCommonParamsExtend(info);\n      let request_data = {...info, ...commonData};\n      console.log(request_data)\n      this.socket.send('readDocument', request_data);\n    },\n    \n    \n    deleteDocument: function(info) {\n      if (!info || !utilsCrud.checkDocumentId(info['document_id'])) {\n        return;\n      }\n      \n      let commonData = commonFunc.getCommonParamsExtend(info);\n      let request_data = {...info, ...commonData};\n      \n      const room = commonFunc.generateSocketClient(info.namespace, info.room);\n      this.socket.send('deleteDocument', request_data, room);\n    },\n  \n  \n   /** export / import db functions **/\n    exportCollection: function(info) {\n      if (info === null) return;\n  \n      let request_data = commonFunc.getCommonParamsExtend(info);\n      request_data['collection'] = info['collection'];\n      request_data['export_type'] = info['export_type'];\n  \n      request_data['metadata'] = info['metadata']\n      this.socket.send('exportDB', request_data);\n    },\n    \n    importCollection: function(info) {\n      const {file} = info;\n      if (info === null || !(file instanceof wnd.File)) return;\n  \n      const extension = file.name.split(\".\").pop();\n      \n      if (!['json','csv'].some((item) => item === extension)) return;\n  \n      let request_data = commonFunc.getCommonParamsExtend(info)\n      request_data['collection'] = info['collection']\n      request_data['import_type'] = extension;\n      this.socket.send('importDB', request_data)\n      this.socket.sendFile(file);\n    },\n    \n    listen: function(message, fun) {\n      this.socket.listen(message, fun);\n    },\n    \n    listenAsync: function(eventname) {\n      return this.socket.listenAsync(eventname);\n    },\n  \n  \tcreateSocket: function(host, namespace) {\n  \t\tif (namespace) {\n  \t\t\tthis.socket.create({\n  \t\t\t\tnamespace: namespace, \n  \t\t\t\troom: null,\n  \t\t\t\thost: host\n  \t\t\t});\n  \t\t\tthis.socket.setGlobalScope(namespace);\n  \t\t} else {\n  \t\t\tthis.socket.create({\n  \t\t\t\tnamespace: null, \n  \t\t\t\troom: null,\n  \t\t\t\thost: host\n  \t\t\t});\n  \t\t}\n  \t},\n  \t\n  \t...utilsCrud\n  }\n  \n  return CoCreateCRUD;\n}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL2NydWQuanM/YzQzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyRUFBVyw2REFBNkQ7O0FBRXhFO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLGlDQUFPLENBQUMsZ0lBQTJDLEVBQUUsb0dBQWlCLENBQUMsbUNBQUU7QUFDakY7QUFDQSxTQUFTO0FBQUEsa0dBQUM7QUFDVixLQUFLLE1BQU0sRUFVUjtBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL2NydWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQge2dldENvbW1vblBhcmFtcywgZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kLCBnZW5lcmF0ZVNvY2tldENsaWVudH0gZnJvbSBcIkBjb2NyZWF0ZS9zb2NrZXQtY2xpZW50L3NyYy9jb21tb24tZnVuLmpzXCJcblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wiQGNvY3JlYXRlL3NvY2tldC1jbGllbnQvc3JjL2NvbW1vbi1mdW4uanNcIiwgXCIuL3V0aWxzLmNydWQuanNcIl0sIGZ1bmN0aW9uKGNvbW1vbkZ1bmMsIHV0aWxzQ3J1ZCkge1xuICAgICAgICBcdHJldHVybiBmYWN0b3J5KHdpbmRvdywgY29tbW9uRnVuYywgdXRpbHNDcnVkKVxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBsZXQgd25kID0ge1xuICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICBGaWxlOiB7fVxuICAgICAgfVxuICAgICAgY29uc3QgY29tbW9uRnVuYyA9IHJlcXVpcmUoXCJAY29jcmVhdGUvc29ja2V0LWNsaWVudC9zcmMvY29tbW9uLWZ1bi5qc1wiKVxuICAgICAgY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5jcnVkLmpzXCIpXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkod25kLCBjb21tb25GdW5jLCB1dGlscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSh3aW5kb3csIHJvb3RbXCJAY29jcmVhdGUvc29ja2V0LWNsaWVudC9zcmMvY29tbW9uLWZ1bi5qc1wiXSwgcm9vdFtcIi4vdXRpbHMuY3J1ZC5qc1wiXSk7XG4gIH1cbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uICh3bmQsIGNvbW1vbkZ1bmMsIHV0aWxzQ3J1ZCkge1xuICBcbiAgY29uc3QgQ29DcmVhdGVDUlVEID0ge1xuICAgIHNvY2tldDogbnVsbCxcbiAgICBzZXRTb2NrZXQ6IGZ1bmN0aW9uKHNvY2tldCkge1xuICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgfSxcblxuICAgIHJlYWREb2N1bWVudExpc3QoaW5mbyl7XG4gICAgICBpZiggIWluZm8gKSByZXR1cm47XG4gICAgICBsZXQgcmVxdWVzdF9kYXRhID0gY29tbW9uRnVuYy5nZXRDb21tb25QYXJhbXMoKTtcbiAgICAgIGlmICghaW5mby5jb2xsZWN0aW9uIHx8ICFpbmZvLm9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVxdWVzdF9kYXRhID0gey4uLnJlcXVlc3RfZGF0YSwgLi4uaW5mb307XG4gICAgICBcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ3JlYWREb2N1bWVudExpc3QnLCByZXF1ZXN0X2RhdGEpO1xuICAgIH0sXG4gICAgXG4gICAgY3JlYXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjb21tb25EYXRhID0gY29tbW9uRnVuYy5nZXRDb21tb25QYXJhbXNFeHRlbmQoaW5mbyk7XG4gICAgICBsZXQgcmVxdWVzdF9kYXRhID0gey4uLmluZm8sIC4uLmNvbW1vbkRhdGF9O1xuICBcbiAgICAgIGxldCBkYXRhID0gaW5mby5kYXRhIHx8IHt9O1xuICAgICAgXG4gICAgICBpZiAoIWRhdGFbJ29yZ2FuaXphdGlvbl9pZCddKSB7XG4gICAgICAgIGRhdGFbJ29yZ2FuaXphdGlvbl9pZCddID0gd25kLmNvbmZpZy5vcmdhbml6YXRpb25fSWRcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvWydkYXRhJ10pIHtcbiAgICAgICAgZGF0YSA9IHsuLi5kYXRhLCAuLi5pbmZvWydkYXRhJ119XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vLiByZWJ1aWxkIGRhdGFcbiAgICAgIHJlcXVlc3RfZGF0YVsnZGF0YSddID0gZGF0YTtcbiAgXG4gICAgICBjb25zdCByb29tID0gY29tbW9uRnVuYy5nZW5lcmF0ZVNvY2tldENsaWVudChpbmZvLm5hbWVzcGFjZSwgaW5mby5yb29tKTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ2NyZWF0ZURvY3VtZW50JywgcmVxdWVzdF9kYXRhLCByb29tKTtcbiAgICB9LFxuICAgIFxuICAgIHVwZGF0ZURvY3VtZW50OiBmdW5jdGlvbihpbmZvKSB7XG4gICAgICBpZiAoIWluZm8gfHwgIXV0aWxzQ3J1ZC5jaGVja0RvY3VtZW50SWQoaW5mb1snZG9jdW1lbnRfaWQnXSkpIHJldHVybjtcbiAgICAgIFxuICAgICAgbGV0IGNvbW1vbkRhdGEgPSBjb21tb25GdW5jLmdldENvbW1vblBhcmFtc0V4dGVuZChpbmZvKTtcbiAgICAgIFxuICAgICAgbGV0IHJlcXVlc3RfZGF0YSA9IHsuLi5pbmZvLCAuLi5jb21tb25EYXRhfTtcbiAgICAgIFxuICAgICAgaWYoIHR5cGVvZiBpbmZvWydkYXRhJ10gPT09ICdvYmplY3QnICkge1xuICAgICAgICByZXF1ZXN0X2RhdGFbJ3NldCddID0gaW5mb1snZGF0YSddXG4gICAgICB9XG4gICAgICBpZiggQXJyYXkuaXNBcnJheShpbmZvWydkZWxldGVfZmllbGRzJ10pICkgcmVxdWVzdF9kYXRhWyd1bnNldCddID0gaW5mb1snZGVsZXRlX2ZpZWxkcyddO1xuICAgICAgXG4gICAgICBpZighcmVxdWVzdF9kYXRhWydzZXQnXSAmJiAhcmVxdWVzdF9kYXRhWyd1bnNldCddKSByZXR1cm47XG4gICAgICBcbiAgICAgIGlmIChpbmZvLmJyb2FkY2FzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3QnXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiogc29ja2V0IHBhcmFtZXRlcnMgKiovXG4gICAgICBpZiAoaW5mb1snYnJvYWRjYXN0X3NlbmRlciddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3Rfc2VuZGVyJ10gPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByb29tID0gY29tbW9uRnVuYy5nZW5lcmF0ZVNvY2tldENsaWVudChpbmZvLm5hbWVzcGFjZSwgaW5mby5yb29tKTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ3VwZGF0ZURvY3VtZW50JywgcmVxdWVzdF9kYXRhLCByb29tKTtcbiAgICB9LFxuICAgIFxuICAgIHJlYWREb2N1bWVudDogZnVuY3Rpb24oaW5mbykge1xuICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWluZm8gfHwgIXV0aWxzQ3J1ZC5jaGVja0RvY3VtZW50SWQoaW5mb1snZG9jdW1lbnRfaWQnXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgY29tbW9uRGF0YSA9IGNvbW1vbkZ1bmMuZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kKGluZm8pO1xuICAgICAgbGV0IHJlcXVlc3RfZGF0YSA9IHsuLi5pbmZvLCAuLi5jb21tb25EYXRhfTtcbiAgICAgIGNvbnNvbGUubG9nKHJlcXVlc3RfZGF0YSlcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ3JlYWREb2N1bWVudCcsIHJlcXVlc3RfZGF0YSk7XG4gICAgfSxcbiAgICBcbiAgICBcbiAgICBkZWxldGVEb2N1bWVudDogZnVuY3Rpb24oaW5mbykge1xuICAgICAgaWYgKCFpbmZvIHx8ICF1dGlsc0NydWQuY2hlY2tEb2N1bWVudElkKGluZm9bJ2RvY3VtZW50X2lkJ10pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgbGV0IGNvbW1vbkRhdGEgPSBjb21tb25GdW5jLmdldENvbW1vblBhcmFtc0V4dGVuZChpbmZvKTtcbiAgICAgIGxldCByZXF1ZXN0X2RhdGEgPSB7Li4uaW5mbywgLi4uY29tbW9uRGF0YX07XG4gICAgICBcbiAgICAgIGNvbnN0IHJvb20gPSBjb21tb25GdW5jLmdlbmVyYXRlU29ja2V0Q2xpZW50KGluZm8ubmFtZXNwYWNlLCBpbmZvLnJvb20pO1xuICAgICAgdGhpcy5zb2NrZXQuc2VuZCgnZGVsZXRlRG9jdW1lbnQnLCByZXF1ZXN0X2RhdGEsIHJvb20pO1xuICAgIH0sXG4gIFxuICBcbiAgIC8qKiBleHBvcnQgLyBpbXBvcnQgZGIgZnVuY3Rpb25zICoqL1xuICAgIGV4cG9ydENvbGxlY3Rpb246IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGlmIChpbmZvID09PSBudWxsKSByZXR1cm47XG4gIFxuICAgICAgbGV0IHJlcXVlc3RfZGF0YSA9IGNvbW1vbkZ1bmMuZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kKGluZm8pO1xuICAgICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ107XG4gICAgICByZXF1ZXN0X2RhdGFbJ2V4cG9ydF90eXBlJ10gPSBpbmZvWydleHBvcnRfdHlwZSddO1xuICBcbiAgICAgIHJlcXVlc3RfZGF0YVsnbWV0YWRhdGEnXSA9IGluZm9bJ21ldGFkYXRhJ11cbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ2V4cG9ydERCJywgcmVxdWVzdF9kYXRhKTtcbiAgICB9LFxuICAgIFxuICAgIGltcG9ydENvbGxlY3Rpb246IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGNvbnN0IHtmaWxlfSA9IGluZm87XG4gICAgICBpZiAoaW5mbyA9PT0gbnVsbCB8fCAhKGZpbGUgaW5zdGFuY2VvZiB3bmQuRmlsZSkpIHJldHVybjtcbiAgXG4gICAgICBjb25zdCBleHRlbnNpb24gPSBmaWxlLm5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgXG4gICAgICBpZiAoIVsnanNvbicsJ2NzdiddLnNvbWUoKGl0ZW0pID0+IGl0ZW0gPT09IGV4dGVuc2lvbikpIHJldHVybjtcbiAgXG4gICAgICBsZXQgcmVxdWVzdF9kYXRhID0gY29tbW9uRnVuYy5nZXRDb21tb25QYXJhbXNFeHRlbmQoaW5mbylcbiAgICAgIHJlcXVlc3RfZGF0YVsnY29sbGVjdGlvbiddID0gaW5mb1snY29sbGVjdGlvbiddXG4gICAgICByZXF1ZXN0X2RhdGFbJ2ltcG9ydF90eXBlJ10gPSBleHRlbnNpb247XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKCdpbXBvcnREQicsIHJlcXVlc3RfZGF0YSlcbiAgICAgIHRoaXMuc29ja2V0LnNlbmRGaWxlKGZpbGUpO1xuICAgIH0sXG4gICAgXG4gICAgbGlzdGVuOiBmdW5jdGlvbihtZXNzYWdlLCBmdW4pIHtcbiAgICAgIHRoaXMuc29ja2V0Lmxpc3RlbihtZXNzYWdlLCBmdW4pO1xuICAgIH0sXG4gICAgXG4gICAgbGlzdGVuQXN5bmM6IGZ1bmN0aW9uKGV2ZW50bmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0Lmxpc3RlbkFzeW5jKGV2ZW50bmFtZSk7XG4gICAgfSxcbiAgXG4gIFx0Y3JlYXRlU29ja2V0OiBmdW5jdGlvbihob3N0LCBuYW1lc3BhY2UpIHtcbiAgXHRcdGlmIChuYW1lc3BhY2UpIHtcbiAgXHRcdFx0dGhpcy5zb2NrZXQuY3JlYXRlKHtcbiAgXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZSwgXG4gIFx0XHRcdFx0cm9vbTogbnVsbCxcbiAgXHRcdFx0XHRob3N0OiBob3N0XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLnNvY2tldC5zZXRHbG9iYWxTY29wZShuYW1lc3BhY2UpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5zb2NrZXQuY3JlYXRlKHtcbiAgXHRcdFx0XHRuYW1lc3BhY2U6IG51bGwsIFxuICBcdFx0XHRcdHJvb206IG51bGwsXG4gIFx0XHRcdFx0aG9zdDogaG9zdFxuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9LFxuICBcdFxuICBcdC4uLnV0aWxzQ3J1ZFxuICB9XG4gIFxuICByZXR1cm4gQ29DcmVhdGVDUlVEO1xufSkpO1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crud-client/src/crud.js\n")},"./node_modules/@cocreate/crud-client/src/index.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! @cocreate/socket-client */ \"./node_modules/@cocreate/socket-client/src/index.js\"), __webpack_require__(/*! @cocreate/crud-client/src/crud.js */ \"./node_modules/@cocreate/crud-client/src/crud.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(CoCreateSocket, CoCreateCRUD) {\n        \treturn factory(true, CoCreateSocket, CoCreateCRUD)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== 'undefined' ? self : this, function (isBrowser, CoCreateSocket, CoCreateCRUD) {\n  if (isBrowser) {\n    let crud_socket = new CoCreateSocket('ws');\n    CoCreateCRUD.setSocket(crud_socket);\n    CoCreateCRUD.createSocket(window.config.host ? window.config.host : window.location.hostname, window.config.organization_Id)\n  } \n  return CoCreateCRUD;\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL2luZGV4LmpzPzVlYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsaUNBQU8sQ0FBQyx5R0FBeUIsRUFBRSxnSEFBbUMsQ0FBQyxtQ0FBRTtBQUNqRjtBQUNBLFNBQVM7QUFBQSxrR0FBQztBQUNWLEtBQUssTUFBTSxFQVVSO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRztBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wiQGNvY3JlYXRlL3NvY2tldC1jbGllbnRcIiwgXCJAY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL2NydWQuanNcIl0sIGZ1bmN0aW9uKENvQ3JlYXRlU29ja2V0LCBDb0NyZWF0ZUNSVUQpIHtcbiAgICAgICAgXHRyZXR1cm4gZmFjdG9yeSh0cnVlLCBDb0NyZWF0ZVNvY2tldCwgQ29DcmVhdGVDUlVEKVxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBsZXQgd25kID0ge1xuICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICBGaWxlOiB7fVxuICAgICAgfVxuICAgICAgY29uc3QgQ29DcmVhdGVDUlVEID0gcmVxdWlyZShcIkBjb2NyZWF0ZS9jcnVkLWNsaWVudC9zcmMvY3J1ZC5qc1wiKVxuICAgICAgY29uc3QgQ29DcmVhdGVTb2NrZXQgPSByZXF1aXJlKFwiQGNvY3JlYXRlL3NvY2tldC1jbGllbnRcIilcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWxzZSwgQ29DcmVhdGVTb2NrZXQsIENvQ3JlYXRlQ1JVRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSh0cnVlLCByb290W1wiQGNvY3JlYXRlL3NvY2tldC1jbGllbnRcIl0sIHJvb3RbXCJAY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL2NydWQuanNcIl0pO1xuICB9XG59KHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAoaXNCcm93c2VyLCBDb0NyZWF0ZVNvY2tldCwgQ29DcmVhdGVDUlVEKSB7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBsZXQgY3J1ZF9zb2NrZXQgPSBuZXcgQ29DcmVhdGVTb2NrZXQoJ3dzJyk7XG4gICAgQ29DcmVhdGVDUlVELnNldFNvY2tldChjcnVkX3NvY2tldCk7XG4gICAgQ29DcmVhdGVDUlVELmNyZWF0ZVNvY2tldCh3aW5kb3cuY29uZmlnLmhvc3QgPyB3aW5kb3cuY29uZmlnLmhvc3QgOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIHdpbmRvdy5jb25maWcub3JnYW5pemF0aW9uX0lkKVxuICB9IFxuICByZXR1cm4gQ29DcmVhdGVDUlVEO1xufSkpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crud-client/src/index.js\n")},"./node_modules/@cocreate/crud-client/src/utils.crud.js":function(module,exports){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        \treturn factory()\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== 'undefined' ? self : this, function () {\n  \n  function \t__mergeObject(target, source) \n  {\n  \ttarget = target || {};\n  \tfor (let key of Object.keys(source)) {\n  \t\tif (source[key] instanceof Object) {\n  \t\t\tObject.assign(source[key], __mergeObject(target[key], source[key]))\n  \t\t}\n  \t}\n  \t\n  \tObject.assign(target || {}, source)\n  \treturn target\n  }\n  \n  function __createObject(data, path) \n  {\n  \tif (!path) return data;\n  \t\n  \tlet keys = path.split('.')\n  \tlet newObject = data;\n  \n  \tfor (var  i = keys.length - 1; i >= 0; i--) {\n  \t\tnewObject = {[keys[i]]: newObject}\t\t\t\t\n  \t}\n  \treturn newObject;\n  }\n  \n  function __createArray(key, data)\n  {\n    try {\n      let item = /([\\w\\W]+)\\[(\\d+)\\]/gm.exec(key)\n      if (item && item.length == 3) {\n        let arrayKey = item[1];\n        let index = parseInt(item[2]);\n        \n        if (!data[arrayKey] || !Array.isArray(data[arrayKey])) {\n          data[arrayKey] = [];\n        } \n        data[arrayKey][index] = data[key];\n        delete data[key];\n        key = arrayKey;\n      }\n    } catch {\n      console.log('create array error');\n    }\n    return key;\n  }\n  \n  function isObject(item) {\n    return (!!item) && (item.constructor === Object);\n  }\n  function isArray(item) {\n    return (!!item) && (item.constructor === Array);\n  }\n  \n  function decodeObject(data) {\n    let keys = Object.keys(data)\n    let objectData = {};\n    \n    keys.forEach((k) => {\n      k = __createArray(k, data);\n      if (k.split('.').length > 1) {\n        let newData = __createObject(data[k], k);\n        delete data[k];\n        \n        objectData = __mergeObject(objectData, newData);\n      } else {\n        objectData[k] = data[k];\n      }\n    })\n    return objectData;\n  }\n  \n  function encodeObject(data) {\n    let keys = Object.keys(data);\n    let newData = {};\n    keys.forEach((k) => {\n      let data_value = data[k];\n      if (isObject(data[k])) {\n        let new_obj = encodeObject(data[k]);\n        \n        let newKeys = Object.keys(new_obj);\n        newKeys.forEach((newKey) => {\n          let value = new_obj[newKey];\n          newKey = k + \".\" + newKey;\n          newData[newKey] = value;\n        })\n        \n      } else if (isArray(data_value)){\n        data_value.forEach((v, index) => {\n          newData[`${k}[${index}]`] = v;\n        })\n      } else {\n        newData[k] = data[k];\n      }\n    })\n    return newData;\n  }\n  \n  function getAttr(el) {\n    if (!el) return\n  \n    let collection = el.getAttribute('data-collection')\n    let document_id = el.getAttribute('data-document_id')\n    let name = el.getAttribute('name')\n    return { collection, document_id, name }\n  }\n  \n  function getFlagAttr(el) {\n    if (!el) return {}\n    let is_realtime = isRealtimeAttr(el);\n    let is_save = isSaveAttr(el);\n    let is_read = isReadAttr(el);\n    let is_update = isUpdateAttr(el);\n    return { is_realtime, is_save, is_read, is_update }\n  }\n  \n  const isReadAttr = (el) => ( __isValueOfAttr(el, 'data-read_value'));\n  const isSaveAttr = (el) => ( __isValueOfAttr(el, 'data-save_value'));\n  const isUpdateAttr = (el) => ( __isValueOfAttr(el, 'data-update_value'));\n  // const isRealtimeAttr = (el) => ( __isValueOfAttr(el, 'data-realtime'));\n  const isRealtimeAttr = (el) => {\n    if (!el) return false\n    let flag = el.getAttribute('data-realtime') == \"false\" ? false : true;\n    return flag\n  };\n  \n  function __isValueOfAttr(el, attr) {\n    if (!el) return false;\n    let flag = el.getAttribute(attr) === \"false\" ? false : true;\n    return flag\n  }\n  \n  function checkValue(value) {\n    if (!value) return false;\n    if (/{{\\s*([\\w\\W]+)\\s*}}/g.test(value)) {\n      return false;\n    }\n  \n    return true;\n  }\n  \n  function isJsonString(str_data) {\n    try {\n      let json_data = JSON.parse(str_data);\n      if (typeof json_data === \"object\" && json_data != null) {\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n    catch (e) {\n      return false;\n    }\n  }\n  \n  function isCRDT(input) {\n    const { collection, document_id, name } = getAttr(input)\n    \n    if (isJsonString(collection)) return false;\n    if (isJsonString(name)) return false;\n  \n    if ((input.tagName === \"INPUT\" && [\"text\", \"email\", \"tel\", \"url\"].includes(input.type)) || input.tagName === \"TEXTAREA\") {\n      \n      if (!name) return false;\n      if (!isRealtimeAttr(input)) return false;\n      if (input.getAttribute(\"data-unique\") === \"true\") return false;\n      if (input.type === 'password') return false;\n      if (!isReadAttr(input)) return false;\n      return true;\n      \n    }\n    return false;\n  }\n  \n  function checkDocumentId(document_id) {\n    try {\n      if (!document_id) return false;\n      if (document_id.toLowerCase() === \"null\") return false;\n      return true;\n    } catch(error) {\n      return false;\n    }\n  }\n  \n  \n  return {\n    decodeObject,\n    encodeObject,\n    getAttr,\n    getFlagAttr,\n    isRealtimeAttr,\n    isReadAttr,\n    isSaveAttr,\n    isUpdateAttr,\n    checkValue,\n    isCRDT,\n    checkDocumentId\n  }\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL3V0aWxzLmNydWQuanM/MTU3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxpQ0FBTyxFQUFFLG1DQUFFO0FBQ25CO0FBQ0EsU0FBUztBQUFBLGtHQUFDO0FBQ1YsS0FBSyxNQUFNLEVBS1I7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekMsaUJBQWlCLHFCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0EscUJBQXFCLEVBQUUsR0FBRyxNQUFNO0FBQ2hDLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdDQUFnQzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcnVkLWNsaWVudC9zcmMvdXRpbHMuY3J1ZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgXHRyZXR1cm4gZmFjdG9yeSgpXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICB9XG59KHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIFxuICBmdW5jdGlvbiBcdF9fbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UpIFxuICB7XG4gIFx0dGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICBcdGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gIFx0XHRpZiAoc291cmNlW2tleV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgXHRcdFx0T2JqZWN0LmFzc2lnbihzb3VyY2Vba2V5XSwgX19tZXJnZU9iamVjdCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pKVxuICBcdFx0fVxuICBcdH1cbiAgXHRcbiAgXHRPYmplY3QuYXNzaWduKHRhcmdldCB8fCB7fSwgc291cmNlKVxuICBcdHJldHVybiB0YXJnZXRcbiAgfVxuICBcbiAgZnVuY3Rpb24gX19jcmVhdGVPYmplY3QoZGF0YSwgcGF0aCkgXG4gIHtcbiAgXHRpZiAoIXBhdGgpIHJldHVybiBkYXRhO1xuICBcdFxuICBcdGxldCBrZXlzID0gcGF0aC5zcGxpdCgnLicpXG4gIFx0bGV0IG5ld09iamVjdCA9IGRhdGE7XG4gIFxuICBcdGZvciAodmFyICBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICBcdFx0bmV3T2JqZWN0ID0ge1trZXlzW2ldXTogbmV3T2JqZWN0fVx0XHRcdFx0XG4gIFx0fVxuICBcdHJldHVybiBuZXdPYmplY3Q7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIF9fY3JlYXRlQXJyYXkoa2V5LCBkYXRhKVxuICB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBpdGVtID0gLyhbXFx3XFxXXSspXFxbKFxcZCspXFxdL2dtLmV4ZWMoa2V5KVxuICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGggPT0gMykge1xuICAgICAgICBsZXQgYXJyYXlLZXkgPSBpdGVtWzFdO1xuICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUludChpdGVtWzJdKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZGF0YVthcnJheUtleV0gfHwgIUFycmF5LmlzQXJyYXkoZGF0YVthcnJheUtleV0pKSB7XG4gICAgICAgICAgZGF0YVthcnJheUtleV0gPSBbXTtcbiAgICAgICAgfSBcbiAgICAgICAgZGF0YVthcnJheUtleV1baW5kZXhdID0gZGF0YVtrZXldO1xuICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgICBrZXkgPSBhcnJheUtleTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIGNvbnNvbGUubG9nKCdjcmVhdGUgYXJyYXkgZXJyb3InKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICAgIHJldHVybiAoISFpdGVtKSAmJiAoaXRlbS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiBpc0FycmF5KGl0ZW0pIHtcbiAgICByZXR1cm4gKCEhaXRlbSkgJiYgKGl0ZW0uY29uc3RydWN0b3IgPT09IEFycmF5KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gZGVjb2RlT2JqZWN0KGRhdGEpIHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gICAgbGV0IG9iamVjdERhdGEgPSB7fTtcbiAgICBcbiAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgIGsgPSBfX2NyZWF0ZUFycmF5KGssIGRhdGEpO1xuICAgICAgaWYgKGsuc3BsaXQoJy4nKS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxldCBuZXdEYXRhID0gX19jcmVhdGVPYmplY3QoZGF0YVtrXSwgayk7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tdO1xuICAgICAgICBcbiAgICAgICAgb2JqZWN0RGF0YSA9IF9fbWVyZ2VPYmplY3Qob2JqZWN0RGF0YSwgbmV3RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3REYXRhW2tdID0gZGF0YVtrXTtcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBvYmplY3REYXRhO1xuICB9XG4gIFxuICBmdW5jdGlvbiBlbmNvZGVPYmplY3QoZGF0YSkge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgbGV0IG5ld0RhdGEgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgIGxldCBkYXRhX3ZhbHVlID0gZGF0YVtrXTtcbiAgICAgIGlmIChpc09iamVjdChkYXRhW2tdKSkge1xuICAgICAgICBsZXQgbmV3X29iaiA9IGVuY29kZU9iamVjdChkYXRhW2tdKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3X29iaik7XG4gICAgICAgIG5ld0tleXMuZm9yRWFjaCgobmV3S2V5KSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gbmV3X29ialtuZXdLZXldO1xuICAgICAgICAgIG5ld0tleSA9IGsgKyBcIi5cIiArIG5ld0tleTtcbiAgICAgICAgICBuZXdEYXRhW25ld0tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YV92YWx1ZSkpe1xuICAgICAgICBkYXRhX3ZhbHVlLmZvckVhY2goKHYsIGluZGV4KSA9PiB7XG4gICAgICAgICAgbmV3RGF0YVtgJHtrfVske2luZGV4fV1gXSA9IHY7XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEYXRhW2tdID0gZGF0YVtrXTtcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG4gIFxuICBmdW5jdGlvbiBnZXRBdHRyKGVsKSB7XG4gICAgaWYgKCFlbCkgcmV0dXJuXG4gIFxuICAgIGxldCBjb2xsZWN0aW9uID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKVxuICAgIGxldCBkb2N1bWVudF9pZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpXG4gICAgbGV0IG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgIHJldHVybiB7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gZ2V0RmxhZ0F0dHIoZWwpIHtcbiAgICBpZiAoIWVsKSByZXR1cm4ge31cbiAgICBsZXQgaXNfcmVhbHRpbWUgPSBpc1JlYWx0aW1lQXR0cihlbCk7XG4gICAgbGV0IGlzX3NhdmUgPSBpc1NhdmVBdHRyKGVsKTtcbiAgICBsZXQgaXNfcmVhZCA9IGlzUmVhZEF0dHIoZWwpO1xuICAgIGxldCBpc191cGRhdGUgPSBpc1VwZGF0ZUF0dHIoZWwpO1xuICAgIHJldHVybiB7IGlzX3JlYWx0aW1lLCBpc19zYXZlLCBpc19yZWFkLCBpc191cGRhdGUgfVxuICB9XG4gIFxuICBjb25zdCBpc1JlYWRBdHRyID0gKGVsKSA9PiAoIF9faXNWYWx1ZU9mQXR0cihlbCwgJ2RhdGEtcmVhZF92YWx1ZScpKTtcbiAgY29uc3QgaXNTYXZlQXR0ciA9IChlbCkgPT4gKCBfX2lzVmFsdWVPZkF0dHIoZWwsICdkYXRhLXNhdmVfdmFsdWUnKSk7XG4gIGNvbnN0IGlzVXBkYXRlQXR0ciA9IChlbCkgPT4gKCBfX2lzVmFsdWVPZkF0dHIoZWwsICdkYXRhLXVwZGF0ZV92YWx1ZScpKTtcbiAgLy8gY29uc3QgaXNSZWFsdGltZUF0dHIgPSAoZWwpID0+ICggX19pc1ZhbHVlT2ZBdHRyKGVsLCAnZGF0YS1yZWFsdGltZScpKTtcbiAgY29uc3QgaXNSZWFsdGltZUF0dHIgPSAoZWwpID0+IHtcbiAgICBpZiAoIWVsKSByZXR1cm4gZmFsc2VcbiAgICBsZXQgZmxhZyA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScpID09IFwiZmFsc2VcIiA/IGZhbHNlIDogdHJ1ZTtcbiAgICByZXR1cm4gZmxhZ1xuICB9O1xuICBcbiAgZnVuY3Rpb24gX19pc1ZhbHVlT2ZBdHRyKGVsLCBhdHRyKSB7XG4gICAgaWYgKCFlbCkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBmbGFnID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHRydWU7XG4gICAgcmV0dXJuIGZsYWdcbiAgfVxuICBcbiAgZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoL3t7XFxzKihbXFx3XFxXXSspXFxzKn19L2cudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICBmdW5jdGlvbiBpc0pzb25TdHJpbmcoc3RyX2RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGpzb25fZGF0YSA9IEpTT04ucGFyc2Uoc3RyX2RhdGEpO1xuICAgICAgaWYgKHR5cGVvZiBqc29uX2RhdGEgPT09IFwib2JqZWN0XCIgJiYganNvbl9kYXRhICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gaXNDUkRUKGlucHV0KSB7XG4gICAgY29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSB9ID0gZ2V0QXR0cihpbnB1dClcbiAgICBcbiAgICBpZiAoaXNKc29uU3RyaW5nKGNvbGxlY3Rpb24pKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGlzSnNvblN0cmluZyhuYW1lKSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgICBpZiAoKGlucHV0LnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBbXCJ0ZXh0XCIsIFwiZW1haWxcIiwgXCJ0ZWxcIiwgXCJ1cmxcIl0uaW5jbHVkZXMoaW5wdXQudHlwZSkpIHx8IGlucHV0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghaXNSZWFsdGltZUF0dHIoaW5wdXQpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS11bmlxdWVcIikgPT09IFwidHJ1ZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3Bhc3N3b3JkJykgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFpc1JlYWRBdHRyKGlucHV0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICBmdW5jdGlvbiBjaGVja0RvY3VtZW50SWQoZG9jdW1lbnRfaWQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFkb2N1bWVudF9pZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGRvY3VtZW50X2lkLnRvTG93ZXJDYXNlKCkgPT09IFwibnVsbFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGVPYmplY3QsXG4gICAgZW5jb2RlT2JqZWN0LFxuICAgIGdldEF0dHIsXG4gICAgZ2V0RmxhZ0F0dHIsXG4gICAgaXNSZWFsdGltZUF0dHIsXG4gICAgaXNSZWFkQXR0cixcbiAgICBpc1NhdmVBdHRyLFxuICAgIGlzVXBkYXRlQXR0cixcbiAgICBjaGVja1ZhbHVlLFxuICAgIGlzQ1JEVCxcbiAgICBjaGVja0RvY3VtZW50SWRcbiAgfVxuXG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crud-client/src/utils.crud.js\n")},"./node_modules/@cocreate/cursors/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\");\n/* harmony import */ var _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/utils */ \"./node_modules/@cocreate/utils/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _cocreate_input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @cocreate/input */ \"./node_modules/@cocreate/input/src/index.js\");\n/* harmony import */ var _CoCreate_cursors_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CoCreate-cursors.css */ \"./node_modules/@cocreate/cursors/src/CoCreate-cursors.css\");\n/*global Element*/\n\n\n\n\n\n\n\n/**Uso esta variable para mostrar errores en caso que no este en prod*/\n\nvar element_multicursors = document.querySelectorAll('input,textarea,[contenteditable]')\n\n//console.log(element_multicursors)\nvar debug = false\nvar enviroment_prod = true\nvar properties = ['boxSizing','borderTopWidth','borderRightWidth','borderBottomWidth','borderLeftWidth','paddingTop','paddingRight','paddingBottom','paddingLeft','marginTop','marginRight','marginBottom','marginLeft','fontStyle','fontVariant','fontWeight','fontStretch','fontSize','lineHeight','fontFamily','textAlign','textTransform','textIndent','textDecoration','letterSpacing','wordSpacing','textRendering','webkitWritingMode','textTransform','textIndent','overflowWrap'];\nvar length_uuid = 30;\n\n\nclass CocreateUtilsCursor{\n  \n  static print(message,debug) {\n    debug = debug || false;\n    if(debug)\n      console.log(message)\n  }\n  \n  static generateUUID(length=null) {\n    var d = new Date().getTime();\n    var d2 = (performance && performance.now && (performance.now()*1000)) || 0;//Time in microseconds since page-load or 0 if unsupported\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16;\n        if(d > 0){\n            var r = (d + r)%16 | 0;\n            d = Math.floor(d/16);\n        } else {\n            var r = (d2 + r)%16 | 0;\n            d2 = Math.floor(d2/16);\n        }\n        return (c=='x' ? r : (r&0x7|0x8)).toString(16);\n    });\n    if(length!=null){\n      uuid = uuid.substr(0,length)\n    }\n    return uuid;\n  }\n  \n}\n\nvar getParents = function (elem, selector) {\n\n// \tif (!Element.prototype.matches) {\n// \t\tElement.prototype.matches =\n// \t\t\tElement.prototype.matchesSelector ||\n// \t\t\tElement.prototype.mozMatchesSelector ||\n// \t\t\tElement.prototype.msMatchesSelector ||\n// \t\t\tElement.prototype.oMatchesSelector ||\n// \t\t\tElement.prototype.webkitMatchesSelector ||\n// \t\t\tfunction(s) {\n// \t\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s),\n// \t\t\t\t\ti = matches.length;\n// \t\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n// \t\t\t\treturn i > -1;\n// \t\t\t};\n// \t}\n}\n\nvar mirrorDiv, computed, style, computedParentElement;\n\nvar getCaretCoordinates = function (element, position_start, position_end) {\n  // mirrored div\n  let name = element.getAttribute('name')\n  let document_id = element.getAttribute('data-document_id') || '';\n  if(document_id == ''){\n    return false;\n  }\n  var ID_MIRROR = element.dataset['mirror_id']; //document_id + name +  '--mirror-div';\n  mirrorDiv = document.getElementById(ID_MIRROR);\n  var add_class_scroll = (element.className.indexOf('floating-label') == -1) ? false : true;\n\n  if (!mirrorDiv) {\n    mirrorDiv = document.createElement('div');\n    mirrorDiv.id = ID_MIRROR;//document_id +name+ '--mirror-div';\n      mirrorDiv.className = (enviroment_prod) ? 'mirror_color mirror_scroll mirror-width-scroll' : 'mirror-width-scroll';\n    //document.body.appendChild(mirrorDiv);\n    element.insertAdjacentElement('afterend',mirrorDiv);\n  }\n\n  var scrollwidth = element.offsetWidth - element.scrollWidth;\n\n  style = mirrorDiv.style;\n  computed = getComputedStyle(element);\n  computedParentElement = getComputedStyle(element.parentElement);\n  let margin_top = parseInt(computed['marginTop'])\n  let margin_left = parseInt(computed['marginLeft'])\n\n  if (element.nodeName !== 'INPUT'){\n    style.wordWrap = 'break-word';  // only for textarea-s\n    style.whiteSpace = 'pre-wrap';\n  }else{\n    style.whiteSpace = 'pre';\n  }\n  // position off-screen\n  style.position = 'absolute';  // required to return coordinates properly\n  \n  var rect = element.getBoundingClientRect(); // get Position from element\n  \n  \n  let scrrollTop_browser = document.documentElement.scrollTop\n  \n  //style.top = ((rect.top+scrrollTop_browser)-1) - (parseInt(computed['marginTop']) - parseInt(computed['borderTopWidth']) ) + 'px'//parseInt(computed.borderTopWidth) + 'px'; //  element.offsetTop + parseInt(computed.borderTopWidth) + 'px';\n  //style.top = computedParentElement['top'];\n  style.top = element.offsetTop+'px';\n  //style.left = rect.left - (parseInt(computed['marginLeft']) -  parseInt(computed['borderLeftWidth']) ) + 'px'//parseInt(computed.borderLeftWidth) + 'px'   // margin_left+\"px\";//\"400px\";\n  //style.left =  computedParentElement['left'];\n  style.left = element.offsetLeft+'px';\n  style.width = rect.width+'px';// - (parseInt(computed.borderLeftWidth) + parseInt(computed.borderRightWidth)) + 'px'   // margin_left+\"px\";//\"400px\";\n  style.height = rect.height+'px';// - (parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth)) + 'px'   // margin_left+\"px\";//\"400px\";\n  style.visibility ='visible'\n  properties.forEach(function (prop) {\n    if(['left','top'].indexOf(prop.toLowerCase()) === -1)\n    style[prop] = computed[prop];\n  });\n  \n  style.overflowX ='auto';\n  style.overflowY ='hidden';\n  style.margin = '0px'\n  //style.padding = '0px'\n  style.border = computed['border'];\n  style.borderColor = 'transparent';\n  /* \n  if(element.nodeName.toLowerCase()=='input'){\n    style.overflowX ='auto';\n    style.overflowY ='hidden';\n  }else{\n    style.overflow=\"visible\"\n  }*/\n  \n  // style.paddingRight = (parseInt(style.paddingRight) + scrollwidth - parseInt(computed.borderRightWidth)) +'px';\n  let cursor_container = mirrorDiv.querySelectorAll('.cursor-container');\n  let selectors_by_users = mirrorDiv.querySelectorAll('.selectors_by_users');\n  let value_element = (['TEXTAREA','INPUT'].indexOf(element.nodeName)==-1) ?element.innerHTML :element.value;\n\n  mirrorDiv.textContent = value_element.substring(0, position_start);\n  if (element.nodeName === 'INPUT')\n    mirrorDiv.textContent = mirrorDiv.textContent.replace(/\\s/g, \"\\u00a0\");\n  var span = document.createElement('span');\n  span.id = element.nodeName + 'span_selections';\n  let value_span = value_element.substring(position_start,position_end) || ''\n  span.textContent = value_span;  // || because a completely empty faux span doesn't render at all\n  //span.style.backgroundColor = \"lightgrey\";\n  mirrorDiv.appendChild(span);\n  \n  if(cursor_container){\n      cursor_container.forEach(function (child_cursor, index, array) {\n        mirrorDiv.appendChild(child_cursor);\n    })\n  }\n  \n  if(selectors_by_users){\n    selectors_by_users.forEach(function (child_selection, index, array) {\n        mirrorDiv.appendChild(child_selection);\n    })\n  }\n  \n  let value_end = value_element.substring(position_end)  || '';\n  var span_end = document.createElement('span');\n  mirrorDiv.appendChild(span_end);\n  span_end.textContent = value_end;\n  var rect = element.getBoundingClientRect(); // get Position from element\n  var coordinates = {\n    start : {\n        top: span.offsetTop,\n        left:  span.offsetLeft\n    },\n    end : {\n        top: span_end.offsetTop, //+ parseInt(computed['borderTopWidth']),\n        left:  span_end.offsetLeft // + parseInt(computed['borderLeftWidth'])\n    }\n  };\n\n  return coordinates;\n}\n\nfunction getStyle(el,styleProp)\n{\n    if (window.getComputedStyle)\n        var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);\n    return y;\n}\n\n\nfunction getDocument(collection,module_id){\n  _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().readDocument({\n    'collection': collection,\n    'document_id': module_id\n  })\n}\n\n_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().listen('readDocument', function(data) {\n    let cursor = document.querySelector('.cursor-flag[data-document_id=\"'+data['document_id']+'\"]')\n    if (cursor)\n      cursor.innerHTML = data.result[cursor.getAttribute('name')]\n})\n\n\nfunction draw_cursor(json){\n        CocreateUtilsCursor.print([\"draw Cursor \",json],debug)\n        let element = json['element'];\n        let activate_cursor = (element.dataset['cursors'])?element.dataset['mirror_id']:true;\n        if(activate_cursor){\n          let start = json['startPosition']\n          let end = json['endPositon']\n          let socket_id = json['clientId']\n          let document_id = element.getAttribute('data-document_id') || '';\n          if(document_id!=''){\n            CocreateUtilsCursor.print(\"action document_id \" + document_id,debug)\n            if( typeof element.dataset['mirror_id'] == 'undefined' || element.dataset['mirror_id'] == '')\n                element.dataset['mirror_id'] = CocreateUtilsCursor.generateUUID(length_uuid)\n            let coordinates = getCaretCoordinates(element,start,end);\n            if(!coordinates)\n              return false;\n            let name = element.getAttribute('name')\n            let id_mirror = element.dataset['mirror_id']; //document_id+name+'--mirror-div'\n            let mi_mirror = document.getElementById(id_mirror)\n            let cursor = false;\n            let selection_user = false;\n            let identify = '_'+id_mirror;\n            let user = (typeof(json) != 'undefined' && json.hasOwnProperty('user')) ? json.user : false\n            let user_id = (typeof(json) != 'undefined' && json.hasOwnProperty('user_id') ) ?  user.user_id : false\n            if (socket_id){\n               //if(data && data.hasOwnProperty('id_mirror')){\n                 var cursores_other_elements = document.querySelectorAll('#socket_'+socket_id+identify)\n                 cursores_other_elements.forEach(function(child_cursor, index, array){\n                   if(child_cursor.parentElement.getAttribute('id') != id_mirror){\n                     CocreateUtilsCursor.print(\"remove old cursor others elements\",debug)\n                      child_cursor.remove()\n                   }\n                 })\n               //}\n                 cursor = mi_mirror.querySelector('.cursor-container#socket_'+socket_id+identify);\n                 if(!cursor  && json.hasOwnProperty('user')){\n                    if(user){\n                      CocreateUtilsCursor.print(\"Create Cursor\",debug)\n                      let cursor_template = '<div style=\"color:blue;\" class=\"cursor-container\" \\\n                                                  id=\"socket_'+socket_id+identify+'\" \\\n                                                  ><div class=\"cursor\" \\\n                                                  style=\"background-color:'+user.color+'\"></div>\\\n                                                  <div class=\"cursor-flag\" data-collection=\"users\" \\\n                                                  name=\"name\" \\\n                                                  data-user_name=\"'+user.name+'\" \\\n                                                  data-user_color=\"'+user.color+'\" \\\n                                                  data-socket_id=\"'+socket_id+'\" \\\n                                                  data-id_mirror=\"'+id_mirror+'\" \\\n                                                  data-document_id=\"'+user_id+'\" \\\n                                                  style=\"background-color:'+user.color+'\" \\\n                                                  flag>'+user.name+'</div></div>';\n                      mi_mirror.innerHTML = cursor_template + mi_mirror.innerHTML;\n                      \n                    }\n                    if(user_id){\n                     // si tiene user_id actualiza el nombre del cursor usando crud\n                      _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().readDocument({\n                        'collection' : 'users', \n                        'document_id': user_id\n                      })\n                   }\n                 }\n              cursor = mi_mirror.querySelector('.cursor-container#socket_'+socket_id+identify);\n            }\n            if(cursor){\n              CocreateUtilsCursor.print([\"Update Cursor\",cursor,coordinates],debug)\n              let font_size = getStyle(element,'font-size')\n              font_size = parseFloat(font_size.substring(0,font_size.length-2));\n              let cursor_height = ( (font_size * 112.5) / 100)\n              let my_cursor = cursor.querySelector('.cursor')\n              cursor.dataset.start = start\n              cursor.dataset.end = end\n              cursor.dataset.socket_id = socket_id\n              /*cursor.dataset.user_name = user.name\n              cursor.dataset.user_color = user.color*/\n  \n              cursor.style[\"top\"] = coordinates.end.top+\"px\"; \n              \n              cursor.style[\"width\"] = \"2px\";  //2px\n              my_cursor.style[\"height\"] = cursor_height+\"px\"; \n              cursor.style[\"left\"] = coordinates.end.left+\"px\"; \n              \n              //add selections\n                selection_user = document.getElementById('sel-'+socket_id+identify);\n                if((start != end) && user ){\n                      selection_user = document.getElementById('sel-'+socket_id+identify)\n                      if(selection_user){\n                        selection_user.remove()\n                      }\n                        var scrollwidth = element.offsetWidth - element.scrollWidth;\n                        var padding_right = parseInt(getComputedStyle(element)[\"paddingRight\"])\n                        selection_user = document.createElement('span');\n                        selection_user.id = 'sel-'+socket_id+identify;\n                        selection_user.className='selectors_by_users'\n                        let style_mirror = getComputedStyle(mi_mirror)\n                        selection_user.style[\"position\"] = \"absolute\"; \n                        selection_user.style[\"top\"] = style_mirror.paddingTop; \n                        selection_user.style[\"left\"] = style_mirror.paddingLeft; \n                        selection_user.style[\"padding-right\"] = scrollwidth+padding_right+\"px\"; \n                        mi_mirror.insertBefore(selection_user, mi_mirror.firstChild);\n                      let selection_span_by_user = document.createElement('span');\n                      selection_span_by_user.id = 'selection-'+socket_id+identify;\n                      selection_span_by_user.style.backgroundColor = user.color;\n                      let value_element = (['TEXTAREA','INPUT'].indexOf(element.nodeName)==-1) ?element.innerHTML :element.value;\n                      selection_user.textContent = value_element.substring(0, start);\n                      let value_span_selection = value_element.substring(start,end) || ''\n                      console.log(\"Selection \",value_span_selection,start,end)\n                      //selection_span_by_user.style.opacity = 0.5;\n                      selection_span_by_user.textContent = value_span_selection;\n                      selection_user.appendChild(selection_span_by_user)\n                }//end Selections\n                else{\n                  if(selection_user){\n                    selection_user.remove()\n                  }\n                }\n            }\n          }//end if document_id\n        }//end activate_cursors\n}//draw_cursor\n\nfunction refresh_mirror(element){\n  var id_mirror = ''\n  let document_id = element.getAttribute('data-document_id') || '';\n  if(document_id!=''){\n    name = element.getAttribute('name')\n    if(element.dataset['mirror_id'])\n      id_mirror = element.dataset['mirror_id']\n      else \n      return;\n    //console.log(\"Refresh \",id_mirror)\n    var mi_mirror = document.getElementById(id_mirror)\n    CocreateUtilsCursor.print([\"refresh_mirror \",mi_mirror],debug)\n    var selector_element = element.nodeName+\"[name='\"+name+\"'][data-document_id='\"+document_id+\"']\"\n    CocreateUtilsCursor.print([\"selector -> \"+selector_element],debug)\n    \n      if(mi_mirror){\n        computed = getComputedStyle(element);\n        style = mi_mirror.style\n        style.width = element.offsetWidth - (parseInt(computed.borderLeftWidth) + parseInt(computed.borderRightWidth)) + 'px'\n        style.height = element.offsetHeight - (parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth)) + 'px'\n        var cursor_container = mi_mirror.querySelectorAll('.cursor-container');\n        cursor_container.forEach(function (child_cursor, index, array) {\n          //console.log(\"REdraw cursor\")\n        let child = child_cursor.querySelector('.cursor-flag');\n        let dataset_child = child.dataset;\n        let dataset = child_cursor.dataset;\n          draw_cursor({\n                            element:element,\n                            startPosition:dataset.start,\n                            endPositon:dataset.end,\n                            clientId : dataset.socket_id,\n                            user:{\n                                'color':dataset_child.user_color,\n                                'name':dataset.user_name\n                                },\n                        });\n        })\n      }\n  }//end document\n}//end verify \n\nElement.prototype.remove = function() {\n  if (this.parentElement) {\n    this.parentElement.removeChild(this);\n  }\n}\n\nfunction recalculate_local_cursors(element,count){\n          CocreateUtilsCursor.print(\"count \"+count,debug)\n          let my_start = ( ! element.hasAttribute('contenteditable'))  ? element.selectionStart : parseInt(element.getAttribute(\"selection_start\"));\n          //let my_start   = element.selectionStart\n          let name = element.getAttribute('name') || '';\n          let document_id = element.getAttribute('data-document_id') || '';\n          let collection = element.getAttribute('data-collection') || '';\n          let selector = '[data-collection=\"'+collection+'\"][data-document_id=\"'+document_id+'\"][name=\"'+name+'\"]'\n          let id_mirror = element.dataset['mirror_id']; //let id_mirror = document_id+name+'--mirror-div';\n          let mirrorDiv = document.getElementById(id_mirror);\n          let cursor_container = (mirrorDiv) ? mirrorDiv.querySelectorAll('.cursor-container') : null;\n          if(cursor_container){\n              let containers_cursors = [];\n              cursor_container.forEach(function (child_cursor, index, array) {\n                  let start = parseInt(child_cursor.getAttribute('data-start'));\n                  let user_name = child_cursor.getAttribute('data-user_name');\n                    CocreateUtilsCursor.print([\"my_start local\",my_start,'start cursor '+user_name+\" = \",start],debug)\n                  if(start > my_start && containers_cursors.indexOf(user_name) == -1 ){\n                    CocreateUtilsCursor.print(\"Es mayor\",debug)\n                    let end = parseInt(child_cursor.getAttribute('data-end'));\n                    let pos_start = start+count;\n                    let pos_end = end+count;\n                    CocreateUtilsCursor.print(['pos_start',pos_start,'pos_end',pos_end],debug)\n                    let dataset = child_cursor.querySelector('.cursor-flag').dataset\n                    let clientId = dataset.socket_id;\n                    let json = {\n                                element:element,\n                                startPosition:pos_start,\n                                endPositon:pos_end,\n                                clientId:clientId,\n                                'user':{\n                                    'color':dataset.user_color,\n                                    'name':dataset.user_name\n                                    },\n                            }\n                    CocreateUtilsCursor.print([\"sent Draw Cursor \",json],debug)\n                    draw_cursor(json);\n                    containers_cursors.push(user_name);\n                  }\n                  \n                //mirrorDiv.appendChild(child_cursor);\n            })\n          }\n}\n\nfunction initCursorEl(element){\n  let formulario = getParents(element,'form')\n          let realtime = element.hasAttribute('data-realtime') ? element.getAttribute('data-realtime') : 'true';\n          if( realtime =='true' ||  (formulario && formulario.getAttribute('data-realtime') =='true' ) ){\n            if(realtime =='false')\n                      return false;\n                  CocreateUtilsCursor.print([\"Init Events \",element],debug)\n                  /*\n                  element.addEventListener('input',function(event){\n                      let start = element.selectionStart;\n                      let end = element.selectionEnd;\n                      let coordinates = getCaretCoordinates(element,start,end);\n                      let count = 0;\n                      switch(event.inputType){\n                        case 'insertText':\n                          count = 1;\n                        break;\n                        case 'insertFromPaste':\n                         // count = event.clipboardData.getData('Text').length\n                        break;\n                        case 'deleteContentBackward':\n                        //case 'insertFromPaste':\n                          count = -1;\n                        break;\n                      }\n                      if(count)\n                        recalculate_local_cursors(this,count)\n                  },false)\n                  */\n                    element.addEventListener('scroll',function(){\n                      CocreateUtilsCursor.print([\"Move Scroll \",element],true)\n                      let name = element.getAttribute('name')\n                      let document_id = element.getAttribute('data-document_id') || '';\n                      let id_mirror = element.dataset['mirror_id'];\n                      let mi_mirror = document.getElementById(id_mirror)\n                      if(mi_mirror){\n                        mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                      }\n                    },false)\n                    \n                    //resize\n                    function outputsize() {\n                      element_multicursors.forEach(function (element_for, index, array) {\n                              let name = element_for.getAttribute('name')\n                              let id_mirror = element.dataset['mirror_id']; \n                              CocreateUtilsCursor.print([\"Resize id_mirror -> \"+id_mirror],debug)\n                              let mi_mirror = document.getElementById(id_mirror)\n                              if(mi_mirror){\n                                mi_mirror.style[\"width\"] = element_for.offsetWidth+\"px\";\n                                mi_mirror.style[\"height\"] = element_for.offsetHeight+\"px\";\n                                //var isFocused = (document.activeElement === element_for);\n                                //verify_cursor(element_for,isFocused)\n                                var isFocused = (document.activeElement === element);\n                                if(isFocused)\n                                  getCaretCoordinates(element,element.selectionStart,element.selectionEnd)\n                                refresh_mirror(element)\n                              }\n                        })\n                    }\n                    new ResizeObserver(outputsize).observe(element)\n                  //if (element.nodeName == 'INPUT'){\n                    element.addEventListener('mousemove',function(event){\n                        let name = element.getAttribute('name')\n                        let document_id = element.getAttribute('data-document_id')\n                        let id_mirror = element.dataset['mirror_id'];\n                        let mi_mirror = document.getElementById(id_mirror)\n                        if(mi_mirror)\n                          mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                    });\n                    \n                    element.addEventListener('focusout',function(event){\n                        let name = element.getAttribute('name')\n                        let document_id = element.getAttribute('data-document_id') || '';\n                        let id_mirror = element.dataset['mirror_id'];\n                        let mi_mirror = document.getElementById(id_mirror)\n                        if(mi_mirror)\n                          mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                    })\n                    \n                    element.addEventListener('keydown',function(event){\n                      //console.log(\"keydown L,T => \",element.scrollLeft,element.scrollTop)\n                         let name = element.getAttribute('name')\n                         let id_mirror = element.dataset['mirror_id'];\n                          let mi_mirror = document.getElementById(id_mirror)\n                          if(mi_mirror){\n                            mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);  \n                            refresh_mirror(element)\n                          }\n                    });\n                    \n                    \n                    element.addEventListener('keyup',function(event){\n                      //console.log(\"keyup L,T => \",element.scrollLeft,element.scrollTop)\n                       let name = element.getAttribute('name')\n                       let id_mirror = element.dataset['mirror_id'];\n                        let mi_mirror = document.getElementById(id_mirror)\n                        if(mi_mirror)\n                          mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                    })\n                    \n                  //}\n          }//end if realtime TRUE\n}\n\nvar initialize_multicursor = function(element_multicursors){\n      element_multicursors.forEach(function (element, index, array) {\n          initCursorEl(element);\n      }); // element_multicursors.forEach\n}//end initialize_multicursor \n\n\nwindow.addEventListener('resize', function(e){ \n  //console.log(\"resize windows\")\n  document.querySelectorAll('[data-mirror_id]').forEach(function (element, index, array) {\n          refresh_mirror(element)\n  }); // element_multicursors.forEach\n}, true);\ndocument.addEventListener('scroll', function(e){ \n  //console.log(\"Scroll \")\n  //console.log(\"scroll windows\",document.body.scrollLeft,document.body.scrollTop)\n  //element_multicursors.forEach(function (element, index, array) {\n  document.querySelectorAll('[data-mirror_id]').forEach(function (element, index, array) {\n          refresh_mirror(element)\n  }); // element_multicursors.forEach\n  \n  \n}, true);\n\nfunction initCursorElements(container) {\n  let mainContainer = container || window;\n  \n  if (!mainContainer.querySelectorAll) {\n    return;\n  }\n  \n  let elements = mainContainer.querySelectorAll('[data-realtime=true]');\n  \n  elements.forEach(el => {\n    initCursorEl(el);\n  })\n}\n\nif(debug)\n  console.log(\"elements to INIT -> \",element_multicursors)\ninitialize_multicursor(element_multicursors);\n\n// CoCreateInit.register_old('[data-realtime=true]',initCursorEl);\n// CoCreateInit.register('CoCreateCursor', window, initCursorElements);\n\n_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.init({ \n\tname: 'CoCreateCursor', \n\tobserve: ['subtree', 'childList'],\n\tinclude: '[data-collection][data-document_id][name][data-realtime=true]', \n\tcallback: function(mutation) {\n\t\tinitCursorElements(mutation.target)\n\t}\n});\n\nconst CoCreateCursors = { draw_cursor, refresh_mirror, recalculate_local_cursors };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateCursors);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3Vyc29ycy9zcmMvaW5kZXguanM/ZTdiMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDeUM7QUFDTDtBQUNLO0FBQ047O0FBRUg7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsNkNBQTZDOzs7QUFHN0M7O0FBRUEsK0tBQStLO0FBQy9LO0FBQ0E7QUFDQSxrTEFBa0w7QUFDbEw7QUFDQTtBQUNBLGdDQUFnQyw2R0FBNkc7QUFDN0ksa0NBQWtDLDZHQUE2RztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOzs7QUFHckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNULENBQUM7OztBQUdELDhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFO0FBQ0wsQ0FBQztBQUNELGdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7O0FBR0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUFhLEU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHlCQUF5QjtBQUN6QixpRUFBZSxlQUFlLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2N1cnNvcnMvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgRWxlbWVudCovXG5pbXBvcnQgb2JzZXJ2ZXIgZnJvbSAnQGNvY3JlYXRlL29ic2VydmVyJ1xuaW1wb3J0IHV0aWxzIGZyb20gJ0Bjb2NyZWF0ZS91dGlscyc7XG5pbXBvcnQgY3J1ZCBmcm9tICdAY29jcmVhdGUvY3J1ZC1jbGllbnQnO1xuaW1wb3J0IGlucHV0IGZyb20gJ0Bjb2NyZWF0ZS9pbnB1dCdcblxuaW1wb3J0ICcuL0NvQ3JlYXRlLWN1cnNvcnMuY3NzJztcblxuLyoqVXNvIGVzdGEgdmFyaWFibGUgcGFyYSBtb3N0cmFyIGVycm9yZXMgZW4gY2FzbyBxdWUgbm8gZXN0ZSBlbiBwcm9kKi9cblxudmFyIGVsZW1lbnRfbXVsdGljdXJzb3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsdGV4dGFyZWEsW2NvbnRlbnRlZGl0YWJsZV0nKVxuXG4vL2NvbnNvbGUubG9nKGVsZW1lbnRfbXVsdGljdXJzb3JzKVxudmFyIGRlYnVnID0gZmFsc2VcbnZhciBlbnZpcm9tZW50X3Byb2QgPSB0cnVlXG52YXIgcHJvcGVydGllcyA9IFsnYm94U2l6aW5nJywnYm9yZGVyVG9wV2lkdGgnLCdib3JkZXJSaWdodFdpZHRoJywnYm9yZGVyQm90dG9tV2lkdGgnLCdib3JkZXJMZWZ0V2lkdGgnLCdwYWRkaW5nVG9wJywncGFkZGluZ1JpZ2h0JywncGFkZGluZ0JvdHRvbScsJ3BhZGRpbmdMZWZ0JywnbWFyZ2luVG9wJywnbWFyZ2luUmlnaHQnLCdtYXJnaW5Cb3R0b20nLCdtYXJnaW5MZWZ0JywnZm9udFN0eWxlJywnZm9udFZhcmlhbnQnLCdmb250V2VpZ2h0JywnZm9udFN0cmV0Y2gnLCdmb250U2l6ZScsJ2xpbmVIZWlnaHQnLCdmb250RmFtaWx5JywndGV4dEFsaWduJywndGV4dFRyYW5zZm9ybScsJ3RleHRJbmRlbnQnLCd0ZXh0RGVjb3JhdGlvbicsJ2xldHRlclNwYWNpbmcnLCd3b3JkU3BhY2luZycsJ3RleHRSZW5kZXJpbmcnLCd3ZWJraXRXcml0aW5nTW9kZScsJ3RleHRUcmFuc2Zvcm0nLCd0ZXh0SW5kZW50Jywnb3ZlcmZsb3dXcmFwJ107XG52YXIgbGVuZ3RoX3V1aWQgPSAzMDtcblxuXG5jbGFzcyBDb2NyZWF0ZVV0aWxzQ3Vyc29ye1xuICBcbiAgc3RhdGljIHByaW50KG1lc3NhZ2UsZGVidWcpIHtcbiAgICBkZWJ1ZyA9IGRlYnVnIHx8IGZhbHNlO1xuICAgIGlmKGRlYnVnKVxuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSlcbiAgfVxuICBcbiAgc3RhdGljIGdlbmVyYXRlVVVJRChsZW5ndGg9bnVsbCkge1xuICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGQyID0gKHBlcmZvcm1hbmNlICYmIHBlcmZvcm1hbmNlLm5vdyAmJiAocGVyZm9ybWFuY2Uubm93KCkqMTAwMCkpIHx8IDA7Ly9UaW1lIGluIG1pY3Jvc2Vjb25kcyBzaW5jZSBwYWdlLWxvYWQgb3IgMCBpZiB1bnN1cHBvcnRlZFxuICAgIHZhciB1dWlkID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2O1xuICAgICAgICBpZihkID4gMCl7XG4gICAgICAgICAgICB2YXIgciA9IChkICsgciklMTYgfCAwO1xuICAgICAgICAgICAgZCA9IE1hdGguZmxvb3IoZC8xNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgciA9IChkMiArIHIpJTE2IHwgMDtcbiAgICAgICAgICAgIGQyID0gTWF0aC5mbG9vcihkMi8xNik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjPT0neCcgPyByIDogKHImMHg3fDB4OCkpLnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbiAgICBpZihsZW5ndGghPW51bGwpe1xuICAgICAgdXVpZCA9IHV1aWQuc3Vic3RyKDAsbGVuZ3RoKVxuICAgIH1cbiAgICByZXR1cm4gdXVpZDtcbiAgfVxuICBcbn1cblxudmFyIGdldFBhcmVudHMgPSBmdW5jdGlvbiAoZWxlbSwgc2VsZWN0b3IpIHtcblxuLy8gXHRpZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbi8vIFx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID1cbi8vIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fFxuLy8gXHRcdFx0RWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4vLyBcdFx0XHRFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuLy8gXHRcdFx0RWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciB8fFxuLy8gXHRcdFx0RWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4vLyBcdFx0XHRmdW5jdGlvbihzKSB7XG4vLyBcdFx0XHRcdHZhciBtYXRjaGVzID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHMpLFxuLy8gXHRcdFx0XHRcdGkgPSBtYXRjaGVzLmxlbmd0aDtcbi8vIFx0XHRcdFx0d2hpbGUgKC0taSA+PSAwICYmIG1hdGNoZXMuaXRlbShpKSAhPT0gdGhpcykge31cbi8vIFx0XHRcdFx0cmV0dXJuIGkgPiAtMTtcbi8vIFx0XHRcdH07XG4vLyBcdH1cbn1cblxudmFyIG1pcnJvckRpdiwgY29tcHV0ZWQsIHN0eWxlLCBjb21wdXRlZFBhcmVudEVsZW1lbnQ7XG5cbnZhciBnZXRDYXJldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBvc2l0aW9uX3N0YXJ0LCBwb3NpdGlvbl9lbmQpIHtcbiAgLy8gbWlycm9yZWQgZGl2XG4gIGxldCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICBsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8ICcnO1xuICBpZihkb2N1bWVudF9pZCA9PSAnJyl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBJRF9NSVJST1IgPSBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddOyAvL2RvY3VtZW50X2lkICsgbmFtZSArICAnLS1taXJyb3ItZGl2JztcbiAgbWlycm9yRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoSURfTUlSUk9SKTtcbiAgdmFyIGFkZF9jbGFzc19zY3JvbGwgPSAoZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZignZmxvYXRpbmctbGFiZWwnKSA9PSAtMSkgPyBmYWxzZSA6IHRydWU7XG5cbiAgaWYgKCFtaXJyb3JEaXYpIHtcbiAgICBtaXJyb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtaXJyb3JEaXYuaWQgPSBJRF9NSVJST1I7Ly9kb2N1bWVudF9pZCArbmFtZSsgJy0tbWlycm9yLWRpdic7XG4gICAgICBtaXJyb3JEaXYuY2xhc3NOYW1lID0gKGVudmlyb21lbnRfcHJvZCkgPyAnbWlycm9yX2NvbG9yIG1pcnJvcl9zY3JvbGwgbWlycm9yLXdpZHRoLXNjcm9sbCcgOiAnbWlycm9yLXdpZHRoLXNjcm9sbCc7XG4gICAgLy9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1pcnJvckRpdik7XG4gICAgZWxlbWVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJyxtaXJyb3JEaXYpO1xuICB9XG5cbiAgdmFyIHNjcm9sbHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQuc2Nyb2xsV2lkdGg7XG5cbiAgc3R5bGUgPSBtaXJyb3JEaXYuc3R5bGU7XG4gIGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29tcHV0ZWRQYXJlbnRFbGVtZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICBsZXQgbWFyZ2luX3RvcCA9IHBhcnNlSW50KGNvbXB1dGVkWydtYXJnaW5Ub3AnXSlcbiAgbGV0IG1hcmdpbl9sZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRbJ21hcmdpbkxlZnQnXSlcblxuICBpZiAoZWxlbWVudC5ub2RlTmFtZSAhPT0gJ0lOUFVUJyl7XG4gICAgc3R5bGUud29yZFdyYXAgPSAnYnJlYWstd29yZCc7ICAvLyBvbmx5IGZvciB0ZXh0YXJlYS1zXG4gICAgc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gIH1lbHNle1xuICAgIHN0eWxlLndoaXRlU3BhY2UgPSAncHJlJztcbiAgfVxuICAvLyBwb3NpdGlvbiBvZmYtc2NyZWVuXG4gIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJzsgIC8vIHJlcXVpcmVkIHRvIHJldHVybiBjb29yZGluYXRlcyBwcm9wZXJseVxuICBcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBnZXQgUG9zaXRpb24gZnJvbSBlbGVtZW50XG4gIFxuICBcbiAgbGV0IHNjcnJvbGxUb3BfYnJvd3NlciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgXG4gIC8vc3R5bGUudG9wID0gKChyZWN0LnRvcCtzY3Jyb2xsVG9wX2Jyb3dzZXIpLTEpIC0gKHBhcnNlSW50KGNvbXB1dGVkWydtYXJnaW5Ub3AnXSkgLSBwYXJzZUludChjb21wdXRlZFsnYm9yZGVyVG9wV2lkdGgnXSkgKSArICdweCcvL3BhcnNlSW50KGNvbXB1dGVkLmJvcmRlclRvcFdpZHRoKSArICdweCc7IC8vICBlbGVtZW50Lm9mZnNldFRvcCArIHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlclRvcFdpZHRoKSArICdweCc7XG4gIC8vc3R5bGUudG9wID0gY29tcHV0ZWRQYXJlbnRFbGVtZW50Wyd0b3AnXTtcbiAgc3R5bGUudG9wID0gZWxlbWVudC5vZmZzZXRUb3ArJ3B4JztcbiAgLy9zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0IC0gKHBhcnNlSW50KGNvbXB1dGVkWydtYXJnaW5MZWZ0J10pIC0gIHBhcnNlSW50KGNvbXB1dGVkWydib3JkZXJMZWZ0V2lkdGgnXSkgKSArICdweCcvL3BhcnNlSW50KGNvbXB1dGVkLmJvcmRlckxlZnRXaWR0aCkgKyAncHgnICAgLy8gbWFyZ2luX2xlZnQrXCJweFwiOy8vXCI0MDBweFwiO1xuICAvL3N0eWxlLmxlZnQgPSAgY29tcHV0ZWRQYXJlbnRFbGVtZW50WydsZWZ0J107XG4gIHN0eWxlLmxlZnQgPSBlbGVtZW50Lm9mZnNldExlZnQrJ3B4JztcbiAgc3R5bGUud2lkdGggPSByZWN0LndpZHRoKydweCc7Ly8gLSAocGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyTGVmdFdpZHRoKSArIHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlclJpZ2h0V2lkdGgpKSArICdweCcgICAvLyBtYXJnaW5fbGVmdCtcInB4XCI7Ly9cIjQwMHB4XCI7XG4gIHN0eWxlLmhlaWdodCA9IHJlY3QuaGVpZ2h0KydweCc7Ly8gLSAocGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyVG9wV2lkdGgpICsgcGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyQm90dG9tV2lkdGgpKSArICdweCcgICAvLyBtYXJnaW5fbGVmdCtcInB4XCI7Ly9cIjQwMHB4XCI7XG4gIHN0eWxlLnZpc2liaWxpdHkgPSd2aXNpYmxlJ1xuICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZihbJ2xlZnQnLCd0b3AnXS5pbmRleE9mKHByb3AudG9Mb3dlckNhc2UoKSkgPT09IC0xKVxuICAgIHN0eWxlW3Byb3BdID0gY29tcHV0ZWRbcHJvcF07XG4gIH0pO1xuICBcbiAgc3R5bGUub3ZlcmZsb3dYID0nYXV0byc7XG4gIHN0eWxlLm92ZXJmbG93WSA9J2hpZGRlbic7XG4gIHN0eWxlLm1hcmdpbiA9ICcwcHgnXG4gIC8vc3R5bGUucGFkZGluZyA9ICcwcHgnXG4gIHN0eWxlLmJvcmRlciA9IGNvbXB1dGVkWydib3JkZXInXTtcbiAgc3R5bGUuYm9yZGVyQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAvKiBcbiAgaWYoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT0naW5wdXQnKXtcbiAgICBzdHlsZS5vdmVyZmxvd1ggPSdhdXRvJztcbiAgICBzdHlsZS5vdmVyZmxvd1kgPSdoaWRkZW4nO1xuICB9ZWxzZXtcbiAgICBzdHlsZS5vdmVyZmxvdz1cInZpc2libGVcIlxuICB9Ki9cbiAgXG4gIC8vIHN0eWxlLnBhZGRpbmdSaWdodCA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpICsgc2Nyb2xsd2lkdGggLSBwYXJzZUludChjb21wdXRlZC5ib3JkZXJSaWdodFdpZHRoKSkgKydweCc7XG4gIGxldCBjdXJzb3JfY29udGFpbmVyID0gbWlycm9yRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXJzb3ItY29udGFpbmVyJyk7XG4gIGxldCBzZWxlY3RvcnNfYnlfdXNlcnMgPSBtaXJyb3JEaXYucXVlcnlTZWxlY3RvckFsbCgnLnNlbGVjdG9yc19ieV91c2VycycpO1xuICBsZXQgdmFsdWVfZWxlbWVudCA9IChbJ1RFWFRBUkVBJywnSU5QVVQnXS5pbmRleE9mKGVsZW1lbnQubm9kZU5hbWUpPT0tMSkgP2VsZW1lbnQuaW5uZXJIVE1MIDplbGVtZW50LnZhbHVlO1xuXG4gIG1pcnJvckRpdi50ZXh0Q29udGVudCA9IHZhbHVlX2VsZW1lbnQuc3Vic3RyaW5nKDAsIHBvc2l0aW9uX3N0YXJ0KTtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdJTlBVVCcpXG4gICAgbWlycm9yRGl2LnRleHRDb250ZW50ID0gbWlycm9yRGl2LnRleHRDb250ZW50LnJlcGxhY2UoL1xccy9nLCBcIlxcdTAwYTBcIik7XG4gIHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBzcGFuLmlkID0gZWxlbWVudC5ub2RlTmFtZSArICdzcGFuX3NlbGVjdGlvbnMnO1xuICBsZXQgdmFsdWVfc3BhbiA9IHZhbHVlX2VsZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uX3N0YXJ0LHBvc2l0aW9uX2VuZCkgfHwgJydcbiAgc3Bhbi50ZXh0Q29udGVudCA9IHZhbHVlX3NwYW47ICAvLyB8fCBiZWNhdXNlIGEgY29tcGxldGVseSBlbXB0eSBmYXV4IHNwYW4gZG9lc24ndCByZW5kZXIgYXQgYWxsXG4gIC8vc3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImxpZ2h0Z3JleVwiO1xuICBtaXJyb3JEaXYuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gIFxuICBpZihjdXJzb3JfY29udGFpbmVyKXtcbiAgICAgIGN1cnNvcl9jb250YWluZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRfY3Vyc29yLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgbWlycm9yRGl2LmFwcGVuZENoaWxkKGNoaWxkX2N1cnNvcik7XG4gICAgfSlcbiAgfVxuICBcbiAgaWYoc2VsZWN0b3JzX2J5X3VzZXJzKXtcbiAgICBzZWxlY3RvcnNfYnlfdXNlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRfc2VsZWN0aW9uLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgbWlycm9yRGl2LmFwcGVuZENoaWxkKGNoaWxkX3NlbGVjdGlvbik7XG4gICAgfSlcbiAgfVxuICBcbiAgbGV0IHZhbHVlX2VuZCA9IHZhbHVlX2VsZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uX2VuZCkgIHx8ICcnO1xuICB2YXIgc3Bhbl9lbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIG1pcnJvckRpdi5hcHBlbmRDaGlsZChzcGFuX2VuZCk7XG4gIHNwYW5fZW5kLnRleHRDb250ZW50ID0gdmFsdWVfZW5kO1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIGdldCBQb3NpdGlvbiBmcm9tIGVsZW1lbnRcbiAgdmFyIGNvb3JkaW5hdGVzID0ge1xuICAgIHN0YXJ0IDoge1xuICAgICAgICB0b3A6IHNwYW4ub2Zmc2V0VG9wLFxuICAgICAgICBsZWZ0OiAgc3Bhbi5vZmZzZXRMZWZ0XG4gICAgfSxcbiAgICBlbmQgOiB7XG4gICAgICAgIHRvcDogc3Bhbl9lbmQub2Zmc2V0VG9wLCAvLysgcGFyc2VJbnQoY29tcHV0ZWRbJ2JvcmRlclRvcFdpZHRoJ10pLFxuICAgICAgICBsZWZ0OiAgc3Bhbl9lbmQub2Zmc2V0TGVmdCAvLyArIHBhcnNlSW50KGNvbXB1dGVkWydib3JkZXJMZWZ0V2lkdGgnXSlcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufVxuXG5mdW5jdGlvbiBnZXRTdHlsZShlbCxzdHlsZVByb3ApXG57XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKVxuICAgICAgICB2YXIgeSA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3ApO1xuICAgIHJldHVybiB5O1xufVxuXG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KGNvbGxlY3Rpb24sbW9kdWxlX2lkKXtcbiAgY3J1ZC5yZWFkRG9jdW1lbnQoe1xuICAgICdjb2xsZWN0aW9uJzogY29sbGVjdGlvbixcbiAgICAnZG9jdW1lbnRfaWQnOiBtb2R1bGVfaWRcbiAgfSlcbn1cblxuY3J1ZC5saXN0ZW4oJ3JlYWREb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBsZXQgY3Vyc29yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmN1cnNvci1mbGFnW2RhdGEtZG9jdW1lbnRfaWQ9XCInK2RhdGFbJ2RvY3VtZW50X2lkJ10rJ1wiXScpXG4gICAgaWYgKGN1cnNvcilcbiAgICAgIGN1cnNvci5pbm5lckhUTUwgPSBkYXRhLnJlc3VsdFtjdXJzb3IuZ2V0QXR0cmlidXRlKCduYW1lJyldXG59KVxuXG5cbmZ1bmN0aW9uIGRyYXdfY3Vyc29yKGpzb24pe1xuICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcImRyYXcgQ3Vyc29yIFwiLGpzb25dLGRlYnVnKVxuICAgICAgICBsZXQgZWxlbWVudCA9IGpzb25bJ2VsZW1lbnQnXTtcbiAgICAgICAgbGV0IGFjdGl2YXRlX2N1cnNvciA9IChlbGVtZW50LmRhdGFzZXRbJ2N1cnNvcnMnXSk/ZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTp0cnVlO1xuICAgICAgICBpZihhY3RpdmF0ZV9jdXJzb3Ipe1xuICAgICAgICAgIGxldCBzdGFydCA9IGpzb25bJ3N0YXJ0UG9zaXRpb24nXVxuICAgICAgICAgIGxldCBlbmQgPSBqc29uWydlbmRQb3NpdG9uJ11cbiAgICAgICAgICBsZXQgc29ja2V0X2lkID0ganNvblsnY2xpZW50SWQnXVxuICAgICAgICAgIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gICAgICAgICAgaWYoZG9jdW1lbnRfaWQhPScnKXtcbiAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoXCJhY3Rpb24gZG9jdW1lbnRfaWQgXCIgKyBkb2N1bWVudF9pZCxkZWJ1ZylcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXSA9PSAndW5kZWZpbmVkJyB8fCBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddID09ICcnKVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ10gPSBDb2NyZWF0ZVV0aWxzQ3Vyc29yLmdlbmVyYXRlVVVJRChsZW5ndGhfdXVpZClcbiAgICAgICAgICAgIGxldCBjb29yZGluYXRlcyA9IGdldENhcmV0Q29vcmRpbmF0ZXMoZWxlbWVudCxzdGFydCxlbmQpO1xuICAgICAgICAgICAgaWYoIWNvb3JkaW5hdGVzKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgIGxldCBpZF9taXJyb3IgPSBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddOyAvL2RvY3VtZW50X2lkK25hbWUrJy0tbWlycm9yLWRpdidcbiAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uX3VzZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpZGVudGlmeSA9ICdfJytpZF9taXJyb3I7XG4gICAgICAgICAgICBsZXQgdXNlciA9ICh0eXBlb2YoanNvbikgIT0gJ3VuZGVmaW5lZCcgJiYganNvbi5oYXNPd25Qcm9wZXJ0eSgndXNlcicpKSA/IGpzb24udXNlciA6IGZhbHNlXG4gICAgICAgICAgICBsZXQgdXNlcl9pZCA9ICh0eXBlb2YoanNvbikgIT0gJ3VuZGVmaW5lZCcgJiYganNvbi5oYXNPd25Qcm9wZXJ0eSgndXNlcl9pZCcpICkgPyAgdXNlci51c2VyX2lkIDogZmFsc2VcbiAgICAgICAgICAgIGlmIChzb2NrZXRfaWQpe1xuICAgICAgICAgICAgICAgLy9pZihkYXRhICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ2lkX21pcnJvcicpKXtcbiAgICAgICAgICAgICAgICAgdmFyIGN1cnNvcmVzX290aGVyX2VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3NvY2tldF8nK3NvY2tldF9pZCtpZGVudGlmeSlcbiAgICAgICAgICAgICAgICAgY3Vyc29yZXNfb3RoZXJfZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihjaGlsZF9jdXJzb3IsIGluZGV4LCBhcnJheSl7XG4gICAgICAgICAgICAgICAgICAgaWYoY2hpbGRfY3Vyc29yLnBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpICE9IGlkX21pcnJvcil7XG4gICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwicmVtb3ZlIG9sZCBjdXJzb3Igb3RoZXJzIGVsZW1lbnRzXCIsZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRfY3Vyc29yLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgIGN1cnNvciA9IG1pX21pcnJvci5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yLWNvbnRhaW5lciNzb2NrZXRfJytzb2NrZXRfaWQraWRlbnRpZnkpO1xuICAgICAgICAgICAgICAgICBpZighY3Vyc29yICAmJiBqc29uLmhhc093blByb3BlcnR5KCd1c2VyJykpe1xuICAgICAgICAgICAgICAgICAgICBpZih1c2VyKXtcbiAgICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwiQ3JlYXRlIEN1cnNvclwiLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJzb3JfdGVtcGxhdGUgPSAnPGRpdiBzdHlsZT1cImNvbG9yOmJsdWU7XCIgY2xhc3M9XCJjdXJzb3ItY29udGFpbmVyXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJzb2NrZXRfJytzb2NrZXRfaWQraWRlbnRpZnkrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48ZGl2IGNsYXNzPVwiY3Vyc29yXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicrdXNlci5jb2xvcisnXCI+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImN1cnNvci1mbGFnXCIgZGF0YS1jb2xsZWN0aW9uPVwidXNlcnNcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwibmFtZVwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdXNlcl9uYW1lPVwiJyt1c2VyLm5hbWUrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdXNlcl9jb2xvcj1cIicrdXNlci5jb2xvcisnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zb2NrZXRfaWQ9XCInK3NvY2tldF9pZCsnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1pZF9taXJyb3I9XCInK2lkX21pcnJvcisnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1kb2N1bWVudF9pZD1cIicrdXNlcl9pZCsnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicrdXNlci5jb2xvcisnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZz4nK3VzZXIubmFtZSsnPC9kaXY+PC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3IuaW5uZXJIVE1MID0gY3Vyc29yX3RlbXBsYXRlICsgbWlfbWlycm9yLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZih1c2VyX2lkKXtcbiAgICAgICAgICAgICAgICAgICAgIC8vIHNpIHRpZW5lIHVzZXJfaWQgYWN0dWFsaXphIGVsIG5vbWJyZSBkZWwgY3Vyc29yIHVzYW5kbyBjcnVkXG4gICAgICAgICAgICAgICAgICAgICAgY3J1ZC5yZWFkRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbGxlY3Rpb24nIDogJ3VzZXJzJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAnZG9jdW1lbnRfaWQnOiB1c2VyX2lkXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3Vyc29yID0gbWlfbWlycm9yLnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3ItY29udGFpbmVyI3NvY2tldF8nK3NvY2tldF9pZCtpZGVudGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjdXJzb3Ipe1xuICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcIlVwZGF0ZSBDdXJzb3JcIixjdXJzb3IsY29vcmRpbmF0ZXNdLGRlYnVnKVxuICAgICAgICAgICAgICBsZXQgZm9udF9zaXplID0gZ2V0U3R5bGUoZWxlbWVudCwnZm9udC1zaXplJylcbiAgICAgICAgICAgICAgZm9udF9zaXplID0gcGFyc2VGbG9hdChmb250X3NpemUuc3Vic3RyaW5nKDAsZm9udF9zaXplLmxlbmd0aC0yKSk7XG4gICAgICAgICAgICAgIGxldCBjdXJzb3JfaGVpZ2h0ID0gKCAoZm9udF9zaXplICogMTEyLjUpIC8gMTAwKVxuICAgICAgICAgICAgICBsZXQgbXlfY3Vyc29yID0gY3Vyc29yLnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3InKVxuICAgICAgICAgICAgICBjdXJzb3IuZGF0YXNldC5zdGFydCA9IHN0YXJ0XG4gICAgICAgICAgICAgIGN1cnNvci5kYXRhc2V0LmVuZCA9IGVuZFxuICAgICAgICAgICAgICBjdXJzb3IuZGF0YXNldC5zb2NrZXRfaWQgPSBzb2NrZXRfaWRcbiAgICAgICAgICAgICAgLypjdXJzb3IuZGF0YXNldC51c2VyX25hbWUgPSB1c2VyLm5hbWVcbiAgICAgICAgICAgICAgY3Vyc29yLmRhdGFzZXQudXNlcl9jb2xvciA9IHVzZXIuY29sb3IqL1xuICBcbiAgICAgICAgICAgICAgY3Vyc29yLnN0eWxlW1widG9wXCJdID0gY29vcmRpbmF0ZXMuZW5kLnRvcCtcInB4XCI7IFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY3Vyc29yLnN0eWxlW1wid2lkdGhcIl0gPSBcIjJweFwiOyAgLy8ycHhcbiAgICAgICAgICAgICAgbXlfY3Vyc29yLnN0eWxlW1wiaGVpZ2h0XCJdID0gY3Vyc29yX2hlaWdodCtcInB4XCI7IFxuICAgICAgICAgICAgICBjdXJzb3Iuc3R5bGVbXCJsZWZ0XCJdID0gY29vcmRpbmF0ZXMuZW5kLmxlZnQrXCJweFwiOyBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vYWRkIHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWwtJytzb2NrZXRfaWQraWRlbnRpZnkpO1xuICAgICAgICAgICAgICAgIGlmKChzdGFydCAhPSBlbmQpICYmIHVzZXIgKXtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWwtJytzb2NrZXRfaWQraWRlbnRpZnkpXG4gICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0aW9uX3VzZXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nX3JpZ2h0ID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtcInBhZGRpbmdSaWdodFwiXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuaWQgPSAnc2VsLScrc29ja2V0X2lkK2lkZW50aWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuY2xhc3NOYW1lPSdzZWxlY3RvcnNfYnlfdXNlcnMnXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbWlycm9yID0gZ2V0Q29tcHV0ZWRTdHlsZShtaV9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci5zdHlsZVtcInBvc2l0aW9uXCJdID0gXCJhYnNvbHV0ZVwiOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLnN0eWxlW1widG9wXCJdID0gc3R5bGVfbWlycm9yLnBhZGRpbmdUb3A7IFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuc3R5bGVbXCJsZWZ0XCJdID0gc3R5bGVfbWlycm9yLnBhZGRpbmdMZWZ0OyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLnN0eWxlW1wicGFkZGluZy1yaWdodFwiXSA9IHNjcm9sbHdpZHRoK3BhZGRpbmdfcmlnaHQrXCJweFwiOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pX21pcnJvci5pbnNlcnRCZWZvcmUoc2VsZWN0aW9uX3VzZXIsIG1pX21pcnJvci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uX3NwYW5fYnlfdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fc3Bhbl9ieV91c2VyLmlkID0gJ3NlbGVjdGlvbi0nK3NvY2tldF9pZCtpZGVudGlmeTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fc3Bhbl9ieV91c2VyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHVzZXIuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlX2VsZW1lbnQgPSAoWydURVhUQVJFQScsJ0lOUFVUJ10uaW5kZXhPZihlbGVtZW50Lm5vZGVOYW1lKT09LTEpID9lbGVtZW50LmlubmVySFRNTCA6ZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci50ZXh0Q29udGVudCA9IHZhbHVlX2VsZW1lbnQuc3Vic3RyaW5nKDAsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVfc3Bhbl9zZWxlY3Rpb24gPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZyhzdGFydCxlbmQpIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZWxlY3Rpb24gXCIsdmFsdWVfc3Bhbl9zZWxlY3Rpb24sc3RhcnQsZW5kKVxuICAgICAgICAgICAgICAgICAgICAgIC8vc2VsZWN0aW9uX3NwYW5fYnlfdXNlci5zdHlsZS5vcGFjaXR5ID0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9zcGFuX2J5X3VzZXIudGV4dENvbnRlbnQgPSB2YWx1ZV9zcGFuX3NlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci5hcHBlbmRDaGlsZChzZWxlY3Rpb25fc3Bhbl9ieV91c2VyKVxuICAgICAgICAgICAgICAgIH0vL2VuZCBTZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgIGlmKHNlbGVjdGlvbl91c2VyKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfS8vZW5kIGlmIGRvY3VtZW50X2lkXG4gICAgICAgIH0vL2VuZCBhY3RpdmF0ZV9jdXJzb3JzXG59Ly9kcmF3X2N1cnNvclxuXG5mdW5jdGlvbiByZWZyZXNoX21pcnJvcihlbGVtZW50KXtcbiAgdmFyIGlkX21pcnJvciA9ICcnXG4gIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gIGlmKGRvY3VtZW50X2lkIT0nJyl7XG4gICAgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICBpZihlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddKVxuICAgICAgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXVxuICAgICAgZWxzZSBcbiAgICAgIHJldHVybjtcbiAgICAvL2NvbnNvbGUubG9nKFwiUmVmcmVzaCBcIixpZF9taXJyb3IpXG4gICAgdmFyIG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcInJlZnJlc2hfbWlycm9yIFwiLG1pX21pcnJvcl0sZGVidWcpXG4gICAgdmFyIHNlbGVjdG9yX2VsZW1lbnQgPSBlbGVtZW50Lm5vZGVOYW1lK1wiW25hbWU9J1wiK25hbWUrXCInXVtkYXRhLWRvY3VtZW50X2lkPSdcIitkb2N1bWVudF9pZCtcIiddXCJcbiAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcInNlbGVjdG9yIC0+IFwiK3NlbGVjdG9yX2VsZW1lbnRdLGRlYnVnKVxuICAgIFxuICAgICAgaWYobWlfbWlycm9yKXtcbiAgICAgICAgY29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICBzdHlsZSA9IG1pX21pcnJvci5zdHlsZVxuICAgICAgICBzdHlsZS53aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSAocGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyTGVmdFdpZHRoKSArIHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlclJpZ2h0V2lkdGgpKSArICdweCdcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSAocGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyVG9wV2lkdGgpICsgcGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyQm90dG9tV2lkdGgpKSArICdweCdcbiAgICAgICAgdmFyIGN1cnNvcl9jb250YWluZXIgPSBtaV9taXJyb3IucXVlcnlTZWxlY3RvckFsbCgnLmN1cnNvci1jb250YWluZXInKTtcbiAgICAgICAgY3Vyc29yX2NvbnRhaW5lci5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZF9jdXJzb3IsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSRWRyYXcgY3Vyc29yXCIpXG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkX2N1cnNvci5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yLWZsYWcnKTtcbiAgICAgICAgbGV0IGRhdGFzZXRfY2hpbGQgPSBjaGlsZC5kYXRhc2V0O1xuICAgICAgICBsZXQgZGF0YXNldCA9IGNoaWxkX2N1cnNvci5kYXRhc2V0O1xuICAgICAgICAgIGRyYXdfY3Vyc29yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjpkYXRhc2V0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvc2l0b246ZGF0YXNldC5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQgOiBkYXRhc2V0LnNvY2tldF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyOntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG9yJzpkYXRhc2V0X2NoaWxkLnVzZXJfY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzpkYXRhc2V0LnVzZXJfbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICB9XG4gIH0vL2VuZCBkb2N1bWVudFxufS8vZW5kIHZlcmlmeSBcblxuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjYWxjdWxhdGVfbG9jYWxfY3Vyc29ycyhlbGVtZW50LGNvdW50KXtcbiAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwiY291bnQgXCIrY291bnQsZGVidWcpXG4gICAgICAgICAgbGV0IG15X3N0YXJ0ID0gKCAhIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkgID8gZWxlbWVudC5zZWxlY3Rpb25TdGFydCA6IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic2VsZWN0aW9uX3N0YXJ0XCIpKTtcbiAgICAgICAgICAvL2xldCBteV9zdGFydCAgID0gZWxlbWVudC5zZWxlY3Rpb25TdGFydFxuICAgICAgICAgIGxldCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCAnJztcbiAgICAgICAgICBsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8ICcnO1xuICAgICAgICAgIGxldCBjb2xsZWN0aW9uID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpIHx8ICcnO1xuICAgICAgICAgIGxldCBzZWxlY3RvciA9ICdbZGF0YS1jb2xsZWN0aW9uPVwiJytjb2xsZWN0aW9uKydcIl1bZGF0YS1kb2N1bWVudF9pZD1cIicrZG9jdW1lbnRfaWQrJ1wiXVtuYW1lPVwiJytuYW1lKydcIl0nXG4gICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107IC8vbGV0IGlkX21pcnJvciA9IGRvY3VtZW50X2lkK25hbWUrJy0tbWlycm9yLWRpdic7XG4gICAgICAgICAgbGV0IG1pcnJvckRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcik7XG4gICAgICAgICAgbGV0IGN1cnNvcl9jb250YWluZXIgPSAobWlycm9yRGl2KSA/IG1pcnJvckRpdi5xdWVyeVNlbGVjdG9yQWxsKCcuY3Vyc29yLWNvbnRhaW5lcicpIDogbnVsbDtcbiAgICAgICAgICBpZihjdXJzb3JfY29udGFpbmVyKXtcbiAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lcnNfY3Vyc29ycyA9IFtdO1xuICAgICAgICAgICAgICBjdXJzb3JfY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkX2N1cnNvciwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwYXJzZUludChjaGlsZF9jdXJzb3IuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YXJ0JykpO1xuICAgICAgICAgICAgICAgICAgbGV0IHVzZXJfbmFtZSA9IGNoaWxkX2N1cnNvci5nZXRBdHRyaWJ1dGUoJ2RhdGEtdXNlcl9uYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoW1wibXlfc3RhcnQgbG9jYWxcIixteV9zdGFydCwnc3RhcnQgY3Vyc29yICcrdXNlcl9uYW1lK1wiID0gXCIsc3RhcnRdLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgaWYoc3RhcnQgPiBteV9zdGFydCAmJiBjb250YWluZXJzX2N1cnNvcnMuaW5kZXhPZih1c2VyX25hbWUpID09IC0xICl7XG4gICAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoXCJFcyBtYXlvclwiLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gcGFyc2VJbnQoY2hpbGRfY3Vyc29yLmdldEF0dHJpYnV0ZSgnZGF0YS1lbmQnKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3Nfc3RhcnQgPSBzdGFydCtjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc19lbmQgPSBlbmQrY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoWydwb3Nfc3RhcnQnLHBvc19zdGFydCwncG9zX2VuZCcscG9zX2VuZF0sZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhc2V0ID0gY2hpbGRfY3Vyc29yLnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3ItZmxhZycpLmRhdGFzZXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsaWVudElkID0gZGF0YXNldC5zb2NrZXRfaWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqc29uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246cG9zX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3NpdG9uOnBvc19lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndXNlcic6e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG9yJzpkYXRhc2V0LnVzZXJfY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ZGF0YXNldC51c2VyX25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcInNlbnQgRHJhdyBDdXJzb3IgXCIsanNvbl0sZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGRyYXdfY3Vyc29yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJzX2N1cnNvcnMucHVzaCh1c2VyX25hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9taXJyb3JEaXYuYXBwZW5kQ2hpbGQoY2hpbGRfY3Vyc29yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q3Vyc29yRWwoZWxlbWVudCl7XG4gIGxldCBmb3JtdWxhcmlvID0gZ2V0UGFyZW50cyhlbGVtZW50LCdmb3JtJylcbiAgICAgICAgICBsZXQgcmVhbHRpbWUgPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVhbHRpbWUnKSA6ICd0cnVlJztcbiAgICAgICAgICBpZiggcmVhbHRpbWUgPT0ndHJ1ZScgfHwgIChmb3JtdWxhcmlvICYmIGZvcm11bGFyaW8uZ2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJykgPT0ndHJ1ZScgKSApe1xuICAgICAgICAgICAgaWYocmVhbHRpbWUgPT0nZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoW1wiSW5pdCBFdmVudHMgXCIsZWxlbWVudF0sZGVidWcpXG4gICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IGVsZW1lbnQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBjb29yZGluYXRlcyA9IGdldENhcmV0Q29vcmRpbmF0ZXMoZWxlbWVudCxzdGFydCxlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGV2ZW50LmlucHV0VHlwZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCdUZXh0JykubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Nhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYoY291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZV9sb2NhbF9jdXJzb3JzKHRoaXMsY291bnQpXG4gICAgICAgICAgICAgICAgICB9LGZhbHNlKVxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJNb3ZlIFNjcm9sbCBcIixlbGVtZW50XSx0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICBpZihtaV9taXJyb3Ipe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnNjcm9sbFRvKGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9yZXNpemVcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3V0cHV0c2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50X2ZvciwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnRfZm9yLmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcIlJlc2l6ZSBpZF9taXJyb3IgLT4gXCIraWRfbWlycm9yXSxkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtaV9taXJyb3Ipe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc3R5bGVbXCJ3aWR0aFwiXSA9IGVsZW1lbnRfZm9yLm9mZnNldFdpZHRoK1wicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnN0eWxlW1wiaGVpZ2h0XCJdID0gZWxlbWVudF9mb3Iub2Zmc2V0SGVpZ2h0K1wicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgaXNGb2N1c2VkID0gKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnRfZm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92ZXJpZnlfY3Vyc29yKGVsZW1lbnRfZm9yLGlzRm9jdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRm9jdXNlZCA9IChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNGb2N1c2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENhcmV0Q29vcmRpbmF0ZXMoZWxlbWVudCxlbGVtZW50LnNlbGVjdGlvblN0YXJ0LGVsZW1lbnQuc2VsZWN0aW9uRW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoX21pcnJvcihlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzaXplT2JzZXJ2ZXIob3V0cHV0c2l6ZSkub2JzZXJ2ZShlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgLy9pZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnSU5QVVQnKXtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRvY3VtZW50X2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWlfbWlycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc2Nyb2xsVG8oZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JyxmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtaV9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pX21pcnJvci5zY3JvbGxUbyhlbGVtZW50LnNjcm9sbExlZnQsZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJyxmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImtleWRvd24gTCxUID0+IFwiLGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc2Nyb2xsVG8oZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKTsgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfbWlycm9yKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJrZXl1cCBMLFQgPT4gXCIsZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKVxuICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWlfbWlycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc2Nyb2xsVG8oZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICB9Ly9lbmQgaWYgcmVhbHRpbWUgVFJVRVxufVxuXG52YXIgaW5pdGlhbGl6ZV9tdWx0aWN1cnNvciA9IGZ1bmN0aW9uKGVsZW1lbnRfbXVsdGljdXJzb3JzKXtcbiAgICAgIGVsZW1lbnRfbXVsdGljdXJzb3JzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIGluaXRDdXJzb3JFbChlbGVtZW50KTtcbiAgICAgIH0pOyAvLyBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoXG59Ly9lbmQgaW5pdGlhbGl6ZV9tdWx0aWN1cnNvciBcblxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oZSl7IFxuICAvL2NvbnNvbGUubG9nKFwicmVzaXplIHdpbmRvd3NcIilcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbWlycm9yX2lkXScpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIHJlZnJlc2hfbWlycm9yKGVsZW1lbnQpXG4gIH0pOyAvLyBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoXG59LCB0cnVlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpeyBcbiAgLy9jb25zb2xlLmxvZyhcIlNjcm9sbCBcIilcbiAgLy9jb25zb2xlLmxvZyhcInNjcm9sbCB3aW5kb3dzXCIsZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKVxuICAvL2VsZW1lbnRfbXVsdGljdXJzb3JzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1taXJyb3JfaWRdJykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgcmVmcmVzaF9taXJyb3IoZWxlbWVudClcbiAgfSk7IC8vIGVsZW1lbnRfbXVsdGljdXJzb3JzLmZvckVhY2hcbiAgXG4gIFxufSwgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGluaXRDdXJzb3JFbGVtZW50cyhjb250YWluZXIpIHtcbiAgbGV0IG1haW5Db250YWluZXIgPSBjb250YWluZXIgfHwgd2luZG93O1xuICBcbiAgaWYgKCFtYWluQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIGxldCBlbGVtZW50cyA9IG1haW5Db250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcmVhbHRpbWU9dHJ1ZV0nKTtcbiAgXG4gIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgIGluaXRDdXJzb3JFbChlbCk7XG4gIH0pXG59XG5cbmlmKGRlYnVnKVxuICBjb25zb2xlLmxvZyhcImVsZW1lbnRzIHRvIElOSVQgLT4gXCIsZWxlbWVudF9tdWx0aWN1cnNvcnMpXG5pbml0aWFsaXplX211bHRpY3Vyc29yKGVsZW1lbnRfbXVsdGljdXJzb3JzKTtcblxuLy8gQ29DcmVhdGVJbml0LnJlZ2lzdGVyX29sZCgnW2RhdGEtcmVhbHRpbWU9dHJ1ZV0nLGluaXRDdXJzb3JFbCk7XG4vLyBDb0NyZWF0ZUluaXQucmVnaXN0ZXIoJ0NvQ3JlYXRlQ3Vyc29yJywgd2luZG93LCBpbml0Q3Vyc29yRWxlbWVudHMpO1xuXG5vYnNlcnZlci5pbml0KHsgXG5cdG5hbWU6ICdDb0NyZWF0ZUN1cnNvcicsIFxuXHRvYnNlcnZlOiBbJ3N1YnRyZWUnLCAnY2hpbGRMaXN0J10sXG5cdGluY2x1ZGU6ICdbZGF0YS1jb2xsZWN0aW9uXVtkYXRhLWRvY3VtZW50X2lkXVtuYW1lXVtkYXRhLXJlYWx0aW1lPXRydWVdJywgXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuXHRcdGluaXRDdXJzb3JFbGVtZW50cyhtdXRhdGlvbi50YXJnZXQpXG5cdH1cbn0pO1xuXG5jb25zdCBDb0NyZWF0ZUN1cnNvcnMgPSB7IGRyYXdfY3Vyc29yLCByZWZyZXNoX21pcnJvciwgcmVjYWxjdWxhdGVfbG9jYWxfY3Vyc29ycyB9O1xuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVDdXJzb3JzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/cursors/src/index.js\n")},"./node_modules/@cocreate/floating-label/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\");\n/* harmony import */ var _CoCreate_floating_label_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CoCreate-floating-label.css */ \"./node_modules/@cocreate/floating-label/src/CoCreate-floating-label.css\");\n// 'use restrict'\n\n\n\n\nconst CoCreateFloatingLabel = {\n  className: 'floating-label_field',\n\n  init: function() {\n    this.initElement()\n  },\n\n  initElement: function(container) {\n    const self = this;\n\n    let mainContainer = container || document;\n    if (!mainContainer.querySelectorAll) {\n      return;\n    }\n\n    let elements = mainContainer.querySelectorAll('.floating-label');\n\n    if (elements.length == 0 && mainContainer.classList && mainContainer.classList.contains('floating-label')) {\n      elements = [mainContainer];\n    }\n\n    elements.forEach(el => {\n      self.render(el);\n      self.__initEvents(el)\n    })\n  },\n\n  render: function(node) {\n    if (node.parentNode && !node.parentNode.classList.contains(this.className)) {\n      const placeholder = node.getAttribute('placeholder');\n      const wrapper = document.createElement('div');\n      node.setAttribute(\"placeholder\", \"\")\n      wrapper.className = this.className;\n      this.__wrap(node, wrapper, placeholder);\n      this.update(node);\n    }\n  },\n\n  update: function(node, value) {\n    if (node.classList.contains('floating-label') && node.parentNode.classList.contains('floating-label_field')) {\n      const parent = node.parentNode;\n      const active = node.hasAttribute('active')\n      if (node.value || value || active) {\n        node.classList.add(\"text_color\");\n        parent.classList.add('active');\n      }\n      else {\n        node.classList.remove(\"text_color\");\n        parent.classList.remove('active');\n      }\n    }\n  },\n\n  __wrap: function(el, wrapper, placeholder) {\n    el.parentNode.insertBefore(wrapper, el);\n    var div1 = document.createElement('div');\n    div1.className = \"floating-label_outline\";\n    var div2 = document.createElement('div');\n    div2.className = \"floating-label_leading\";\n    var div3 = document.createElement('div');\n    div3.className = \"floating-label_notch\";\n    var label = document.createElement('label');\n    label.className = \"floating-label_label\";\n    label.innerHTML = placeholder;\n    var div4 = document.createElement('div');\n    div4.className = \"floating-label_trailing\";\n    div1.appendChild(div2);\n    div3.appendChild(label);\n    div1.appendChild(div3);\n    div1.appendChild(div4);\n\n    wrapper.appendChild(div1);\n    wrapper.appendChild(el);\n  },\n\n  __initEvents: function(node) {\n\n    node.addEventListener('focus', (event) => {\n      const inputContent = node.value;\n      const tag_name = node.tagName.toLowerCase()\n      if (inputContent == '' || tag_name == 'select') {\n        node.classList.add(\"text_color\");\n        parent = node.closest(\"div\");\n        parent.classList.add(\"active\");\n      }\n    });\n\n    node.addEventListener('blur', (event) => {\n      const inputContent = node.value;\n      const active = node.hasAttribute('active')\n      if (inputContent == '' && !active) {\n        node.classList.remove(\"text_color\");\n        parent = node.closest(\"div\");\n        parent.classList.remove(\"active\");\n      }\n    });\n\n  },\n\n}\n\nCoCreateFloatingLabel.init();\n\n_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.init({ \n  name: 'CoCreateFloatingLabelInit',\n  observe: ['subtree', 'childList'],\n  include: '.floating-label',\n  callback: function(mutation) {\n    // console.log(mutation)\n    CoCreateFloatingLabel.initElement(mutation.target)\n  }\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateFloatingLabel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvZmxvYXRpbmctbGFiZWwvc3JjL2luZGV4LmpzPzRkOTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRXlDO0FBQ0Y7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHOztBQUVIOztBQUVBOztBQUVBLDREQUFhLEU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUscUJBQXFCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9mbG9hdGluZy1sYWJlbC9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAndXNlIHJlc3RyaWN0J1xuXG5pbXBvcnQgb2JzZXJ2ZXIgZnJvbSAnQGNvY3JlYXRlL29ic2VydmVyJ1xuaW1wb3J0ICcuL0NvQ3JlYXRlLWZsb2F0aW5nLWxhYmVsLmNzcyc7XG5cbmNvbnN0IENvQ3JlYXRlRmxvYXRpbmdMYWJlbCA9IHtcbiAgY2xhc3NOYW1lOiAnZmxvYXRpbmctbGFiZWxfZmllbGQnLFxuXG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoKVxuICB9LFxuXG4gIGluaXRFbGVtZW50OiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGxldCBtYWluQ29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50O1xuICAgIGlmICghbWFpbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGVsZW1lbnRzID0gbWFpbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuZmxvYXRpbmctbGFiZWwnKTtcblxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMCAmJiBtYWluQ29udGFpbmVyLmNsYXNzTGlzdCAmJiBtYWluQ29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucygnZmxvYXRpbmctbGFiZWwnKSkge1xuICAgICAgZWxlbWVudHMgPSBbbWFpbkNvbnRhaW5lcl07XG4gICAgfVxuXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBzZWxmLnJlbmRlcihlbCk7XG4gICAgICBzZWxmLl9faW5pdEV2ZW50cyhlbClcbiAgICB9KVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIW5vZGUucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jbGFzc05hbWUpKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IG5vZGUuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCBcIlwiKVxuICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgIHRoaXMuX193cmFwKG5vZGUsIHdyYXBwZXIsIHBsYWNlaG9sZGVyKTtcbiAgICAgIHRoaXMudXBkYXRlKG5vZGUpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdmbG9hdGluZy1sYWJlbCcpICYmIG5vZGUucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2Zsb2F0aW5nLWxhYmVsX2ZpZWxkJykpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGNvbnN0IGFjdGl2ZSA9IG5vZGUuaGFzQXR0cmlidXRlKCdhY3RpdmUnKVxuICAgICAgaWYgKG5vZGUudmFsdWUgfHwgdmFsdWUgfHwgYWN0aXZlKSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChcInRleHRfY29sb3JcIik7XG4gICAgICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoXCJ0ZXh0X2NvbG9yXCIpO1xuICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9fd3JhcDogZnVuY3Rpb24oZWwsIHdyYXBwZXIsIHBsYWNlaG9sZGVyKSB7XG4gICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlciwgZWwpO1xuICAgIHZhciBkaXYxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2MS5jbGFzc05hbWUgPSBcImZsb2F0aW5nLWxhYmVsX291dGxpbmVcIjtcbiAgICB2YXIgZGl2MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdjIuY2xhc3NOYW1lID0gXCJmbG9hdGluZy1sYWJlbF9sZWFkaW5nXCI7XG4gICAgdmFyIGRpdjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYzLmNsYXNzTmFtZSA9IFwiZmxvYXRpbmctbGFiZWxfbm90Y2hcIjtcbiAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9IFwiZmxvYXRpbmctbGFiZWxfbGFiZWxcIjtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSBwbGFjZWhvbGRlcjtcbiAgICB2YXIgZGl2NCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdjQuY2xhc3NOYW1lID0gXCJmbG9hdGluZy1sYWJlbF90cmFpbGluZ1wiO1xuICAgIGRpdjEuYXBwZW5kQ2hpbGQoZGl2Mik7XG4gICAgZGl2My5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgZGl2MS5hcHBlbmRDaGlsZChkaXYzKTtcbiAgICBkaXYxLmFwcGVuZENoaWxkKGRpdjQpO1xuXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChkaXYxKTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsKTtcbiAgfSxcblxuICBfX2luaXRFdmVudHM6IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IG5vZGUudmFsdWU7XG4gICAgICBjb25zdCB0YWdfbmFtZSA9IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICBpZiAoaW5wdXRDb250ZW50ID09ICcnIHx8IHRhZ19uYW1lID09ICdzZWxlY3QnKSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChcInRleHRfY29sb3JcIik7XG4gICAgICAgIHBhcmVudCA9IG5vZGUuY2xvc2VzdChcImRpdlwiKTtcbiAgICAgICAgcGFyZW50LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IG5vZGUudmFsdWU7XG4gICAgICBjb25zdCBhY3RpdmUgPSBub2RlLmhhc0F0dHJpYnV0ZSgnYWN0aXZlJylcbiAgICAgIGlmIChpbnB1dENvbnRlbnQgPT0gJycgJiYgIWFjdGl2ZSkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoXCJ0ZXh0X2NvbG9yXCIpO1xuICAgICAgICBwYXJlbnQgPSBub2RlLmNsb3Nlc3QoXCJkaXZcIik7XG4gICAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0sXG5cbn1cblxuQ29DcmVhdGVGbG9hdGluZ0xhYmVsLmluaXQoKTtcblxub2JzZXJ2ZXIuaW5pdCh7IFxuICBuYW1lOiAnQ29DcmVhdGVGbG9hdGluZ0xhYmVsSW5pdCcsXG4gIG9ic2VydmU6IFsnc3VidHJlZScsICdjaGlsZExpc3QnXSxcbiAgaW5jbHVkZTogJy5mbG9hdGluZy1sYWJlbCcsXG4gIGNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuICAgIC8vIGNvbnNvbGUubG9nKG11dGF0aW9uKVxuICAgIENvQ3JlYXRlRmxvYXRpbmdMYWJlbC5pbml0RWxlbWVudChtdXRhdGlvbi50YXJnZXQpXG4gIH1cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlRmxvYXRpbmdMYWJlbDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/floating-label/src/index.js\n")},"./node_modules/@cocreate/form/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\");\n/* harmony import */ var _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/utils */ \"./node_modules/@cocreate/utils/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _cocreate_action__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @cocreate/action */ \"./node_modules/@cocreate/action/src/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./node_modules/@cocreate/form/src/utils.js\");\n\n\n\n\n \n\nconst CoCreateForm = {\n\t\n\trequestAttr: \"data-document_request\",\n\tselectors: [],\n\tmodules: [],\n\n\tinit: function({name, selector, callback}) {\n\t\t\n\t\tthis.modules.push({\n\t\t\tname,\n\t\t\tselector,\n\t\t\tcallback\n\t\t});\n\t\t\n\t\tif (selector) {\n\t\t\tthis.selectors.push(selector);\n\t\t}\n\t},\n\t\n\tget: function() {\n\t\treturn {\n\t\t\tselectors: this.selectors\n\t\t}\n\t},\n\t\n\tcheckID: function(element, attr = \"data-document_id\") {\n\t\tlet document_id = element.getAttribute(attr) || \"\";\n\t\tif (document_id === \"\" || document_id === \"pending\" || !_cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(document_id)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\t\n\trequest: function({form, element, nameAttr, value}) {\n\t\t\n\t\tif (!form && element) {\n\t\t\tform = element.closest('form');\n\t\t}\n\t\t\n\t\tif (form) {\n\t\t\tthis.__requestDocumentIdOfForm(form)\n\t\t} else if (element) {\n\t\t\tnameAttr = nameAttr || \"name\"\n\t\t\tthis.__requestDocumentId(element, nameAttr, value);\n\t\t}\n\t\t\n\t},\n\t\n\tinitElement: function(container) {\n\t\tconst __container = container || document\n\t\t\n\t\tif (!__container.querySelectorAll) {\n\t\t\treturn;\n\t\t}\n\t\tlet  forms = __container.querySelectorAll('form');\n\n\t\tif (forms.length === 0 && __container != document && __container.tagName === \"FORM\") {\n\t\t\tforms = [__container];\n\t\t}\n\t\t\n\t\tforms.forEach((form) => {\n\t\t\t_utils__WEBPACK_IMPORTED_MODULE_4__.default.setAttribute(form)\n\t\t\t_utils__WEBPACK_IMPORTED_MODULE_4__.default.disableAutoFill(form);\n\t\t})\n\t},\n\t\n\t__init: function() {\n\t\tconst forms = document.querySelectorAll('form');\n\t\tthis.__initEvent();\n\n\t\tforms.forEach((form) => {\n\t\t\t_utils__WEBPACK_IMPORTED_MODULE_4__.default.setAttribute(form)\n\t\t})\n\t\t\n\t},\n\t\n\t__initEvent: function() {\n\t\tconst self = this;\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().listen('createDocument', function(data) {\n\t\t\tconst {metadata} = data;\n\t\t\tself.__receivedDocumentId(data);\n\t\t\tif (metadata == \"createDocument-action\") {\n\t\t\t\t//. dispatch EndAction\n\t\t\t}\n\t\t})\n\t\t\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().listen('deleteDocument', function(data) {\n\t\t\tconst {metadata} = data\n\t\t\tif (metadata === \"deleteDocument-action\") {\n\t\t\t\t//.dispatch End Action\n\t\t\t}\n\t\t})\t\n\t\tdocument.addEventListener('clicked-submitBtn', function(event) {\n\t\t\tconst {element} = event.detail;\n\n\t\t\tself.modules.forEach(({selector, callback}) => {\n\t\t\t\tif (callback && element.matches(selector)) {\n\t\t\t\t\tcallback.call(null, element);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t},\n\n\t__deleteDocumentAction: function(btn) {\n\t\tconst { collection, document_id } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(btn)\n\t\tif (_cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(collection) && _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(document_id)) {\n\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().deleteDocument({ \n\t\t\t\tcollection, \n\t\t\t\tdocument_id, \n\t\t\t\t'metadata': 'deleteDocument-action' \n\t\t\t});\n\t\t\t\n\t\t\tdocument.dispatchEvent(new CustomEvent('deletedDocument', {\n\t\t\t\tdetail: {}\n\t\t\t}))\n\t\t}\n\t},\n\t\n\t__deleteDocumentsAction: function(btn) {\n\t\tconst { collection, document_id } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(btn)\n\t\tconst selector = btn.getAttribute('data-document_target');\n\t\tif (!selector) return;\n\t\t\n\t\tconst selectedEls = document.querySelectorAll(selector)\n\t\t\n\t\tif (_utils__WEBPACK_IMPORTED_MODULE_4__.default.checkValue(collection)) {\n\t\t\tselectedEls.forEach((el) => {\n\t\t\t\tconst document_id =  el.getAttribute('data-document_id');\n\t\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().checkValue(document_id)) {\n\t\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().deleteDocument({\n\t\t\t\t\t\t'collection': collection,\n\t\t\t\t\t\t'document_id': document_id,\n\t\t\t\t\t\t'metadata': ''\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\tdocument.dispatchEvent(new CustomEvent('deletedDocuments', {\n\t\t\t\tdetail: {}\n\t\t\t}))\n\t\t}\n\t},\n\t\n\t__createDocumentAction: function(btn) {\n\t\tconst form = btn.closest(\"form\")\n\t\tconst self = this;\n\t\tlet collections = _utils__WEBPACK_IMPORTED_MODULE_4__.default.getCOllections(form)\n\t\t\n\t\tcollections.forEach((collection) => {\n\t\t\tlet data = _utils__WEBPACK_IMPORTED_MODULE_4__.default.getFormData(form, \"\", collection);\n\t\t\t\n\t\t\tif (Object.keys(data).length == 0 && data.constructor === Object) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(collection)) {\n\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().createDocument({\n\t\t\t\t\t'collection': collection,\n\t\t\t\t\t'data': data,\n\t\t\t\t\t'metadata': 'createDocument-action' ,\n\t\t\t\t\t'element':'empty'\n\t\t\t\t});\n\t\t\t\tdocument.dispatchEvent(new CustomEvent('createdDocument', {\n\t\t\t\t\tdetail: {}\n\t\t\t\t}))\n\t\t\t}\n\t\t})\n\t},\n\t\n\t__saveDocumentAction: function(btn) {\n\t\tconst form = btn.closest(\"form\")\n\n\t\tif (!_utils__WEBPACK_IMPORTED_MODULE_4__.default.checkFormValidate(form)) {\n\t\t\talert('Values are not unique');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst selectors = this.selectors || [];\n\t\tconst elements = form.querySelectorAll(selectors.join(','));\n\t\t\n\t\tlet request_document_id = false;\n\t\tfor (var i = 0; i < elements.length; i++) {\n\t\t\tlet el = elements[i];\n\t\t\tconst { document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(el)\n\t\t\tconst is_save = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().isSaveAttr(el)\n\t\t\tif (!is_save) continue;\n\n\t\t\tif (!_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().checkValue(document_id)) {\n\t\t\t\tif (name) request_document_id = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().isCRDT(el)) continue;\n\n\t\t\tif (_utils__WEBPACK_IMPORTED_MODULE_4__.default.isTemplateInput(el)) return;\n\n\t\t\tvar new_event = new CustomEvent(\"clicked-submitBtn\", {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail: { \n\t\t\t\t\ttype: \"submitBtn\", \n\t\t\t\t\telement: el \n\t\t\t\t}});\n\t\t\tel.dispatchEvent(new_event);  \n\t\t}\n\t\tif (request_document_id) {\n\t\t\tthis.requestDocumentIdOfForm(form)\n\t\t}\n\t\t\n\t\tdocument.dispatchEvent(new CustomEvent('savedDocument', {\n\t\t\tdetail: {}\n\t\t}))\n\t},\n\t\n\t__requestDocumentId: function(element, nameAttr = \"name\", value = null) {\n\t\tconst { collection, name }  = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(element)\n\t\tif (!collection || !name) return \n\n\t\tconst request_id = _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.generateUUID();\n\t\telement.setAttribute(this.requestAttr, request_id);\n\t\t\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().createDocument({\n\t\t\t\"collection\": collection,\n\t\t\t\"element\": request_id,\n\t\t\t\"metadata\": \"\",\n\t\t})\n\t},\n\t\t\n\t__requestDocumentIdOfForm: function (form) {\n\t\t\n\t\tlet self = this;\n\t\tlet elemens = form.querySelectorAll('[name], [data-pass_to]')\n\t\t\n\t\tlet collections = [];\n\n\t\tfor (var  i = 0; i < elemens.length; i++) {\n\t\t\tlet el = elemens[i];\n\t\t\tif (el.parentNode.classList.contains('template')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst collection = el.getAttribute(\"data-collection\") || el.getAttribute(\"data-pass_collection\") || \"\";\t\n\t\t\t\n\t\t\tif (\n\t\t\t\tcollection !== \"\" && \n\t\t\t\t!collections.includes(collection) && \n\t\t\t\t(!self.checkID(el, 'data-document_id') && !self.checkID(el, 'data-pass_document_id'))\n\t\t\t) {\n\t\t\t\tconst request_id = _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.generateUUID();\n\t\t\t\tcollections.push(collection);\n\n\t\t\t\tel.setAttribute(this.requestAttr, request_id);\n\t\t\t\t//. get Data\n\t\t\t\t\n\t\t\t\tlet data = _utils__WEBPACK_IMPORTED_MODULE_4__.default.getFormData(form, \"\", collection);\n\t\t\t\t\n\t\t\t\t/* FixME Create Document request */\t\n\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().createDocument({\n\t\t\t\t\t\"collection\": collection,\n\t\t\t\t\t\"element\": request_id,\n\t\t\t\t\t'data': data,\n\t\t\t\t\t\"metadata\": \"\",\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t},\n\n\t__setNewIdProcess: function(element, document_id, pass) {\n\t\tif (!element) return;\n\t\t\n  \t\telement.removeAttribute(this.requestAttr);\n\t\tconst event_data = {\n\t\t\tdocument_id: document_id,\n\t\t}\n\n\t\tif (!pass && !this.checkID(element) && element.hasAttribute('name')) {\n\t\t\telement.setAttribute('data-document_id', document_id);\n\t  \t}\n\n\t  \tif (pass && !this.checkID(element, 'data-pass_document_id') && element.hasAttribute('data-pass_to')) {\n\t\t\telement.setAttribute('data-pass_document_id', document_id);\n\t\t\t// CoCreateLogic.storePassData(element)\n\t\t\t\n\t\t\tif (element.parentNode.classList.contains('submitBtn')) {\n\t\t\t\telement.click();\n\t\t\t}\n\t  \t}\n  \t\n\t\tvar event = new CustomEvent('set-document_id', {detail: event_data})\n\t\telement.dispatchEvent(event);\n\n\t},\n\t\n\t__receivedDocumentId: function(data) {\n\t\tif (!data['document_id']) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet element = document.querySelector(`[${this.requestAttr}=\"${data['element']}\"]`);\n\t\tif (!element) return;\n\t\tlet self = this;\n\t\tconst form = (element.tagName === \"FORM\") ? element : _utils__WEBPACK_IMPORTED_MODULE_4__.default.getParents(element, 'form');\n\t\tconst collection = data['collection'];\n\t\tconst id = data['document_id']\n\t\tif (form && id) {\n\t\t\tform.setAttribute('data-form_id', data['element']);\n\t\t\tconst elements = form.querySelectorAll(`[data-collection=${collection}], [data-pass_collection=${collection}]`)\n\t\t\telements.forEach(function(el) {\n\t\t\t\tel.removeAttribute(self.requestAttr);\n\t\t\t\tif (el.hasAttribute('name')) self.__setNewIdProcess(el, id);\n\t\t\t\tif (el.hasAttribute('data-pass_to')) self.__setNewIdProcess(el, id, true);\n\t\t\t})\n\t  \t\n\t\t} else if (element) {\n\t\t\tthis.__setNewIdProcess(element, id);\n\t\t}\n\t},\n}\n\nCoCreateForm.__init();\n// core.registerInit(CoCreateForm.initElement, CoCreateForm);\n\n_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.init({ \n\tname: 'CoCreateForm', \n\tobserve: ['subtree', 'childList'],\n\tinclude: 'form', \n\tcallback: function(mutation) {\n\t\tCoCreateForm.initElement(mutation.target)\n\t}\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"createDocument\",\n\tendEvent: \"createdDocument\",\n\tcallback: (btn, data) => {\n\t\tCoCreateForm.__createDocumentAction(btn)\n\t},\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"deleteDocument\",\n\tendEvent: \"deletedDocument\",\n\tcallback: (btn, data) => {\n\t\tCoCreateForm.__deleteDocumentAction(btn)\n\t},\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"deleteDocuments\",\n\tendEvent: \"deletedDocuments\",\n\tcallback: (btn, data) => {\n\t\tCoCreateDocument.__deleteDocumentsAction(btn)\n\t},\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"saveDocument\",\n\tendEvent: \"savedDocument\",\n\tcallback: (btn, data) => {\n\t\tCoCreateForm.__saveDocumentAction(btn)\n\t},\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateForm);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvZm9ybS9zcmMvaW5kZXguanM/ZWJlYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlDO0FBQ0o7QUFDRztBQUNIO0FBQ1Y7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIseUJBQXlCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLDBEQUEwRCwrREFBa0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0IsK0JBQStCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsd0RBQWtCO0FBQ3JCLEdBQUcsMkRBQXFCO0FBQ3hCLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsd0RBQWtCO0FBQ3JCLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRSxtRUFBVztBQUNiLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRSxtRUFBVztBQUNiLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxVQUFVLFFBQVE7O0FBRWxCLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0EsU0FBUywwQkFBMEIsR0FBRyxvRUFBWTtBQUNsRCxNQUFNLCtEQUFrQixnQkFBZ0IsK0RBQWtCO0FBQzFELEdBQUcsMkVBQW1CLEU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLFNBQVMsMEJBQTBCLEdBQUcsb0VBQVk7QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLHNEQUFnQjtBQUN0QjtBQUNBO0FBQ0EsUUFBUSx1RUFBZTtBQUN2QixLQUFLLDJFQUFtQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBb0I7O0FBRXhDO0FBQ0EsY0FBYyx1REFBaUI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLE9BQU8sK0RBQWtCO0FBQ3pCLElBQUksMkVBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBLE9BQU8sNkRBQXVCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBLFVBQVUsb0JBQW9CLEdBQUcsb0VBQVk7QUFDN0MsbUJBQW1CLHVFQUFlO0FBQ2xDOztBQUVBLFFBQVEsdUVBQWU7QUFDdkI7QUFDQTtBQUNBOztBQUVBLE9BQU8sbUVBQVc7O0FBRWxCLE9BQU8sMkRBQXFCOztBQUU1QjtBQUNBO0FBQ0EsYTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQSxTQUFTLG1CQUFtQixJQUFJLG9FQUFZO0FBQzVDOztBQUVBLHFCQUFxQixpRUFBb0I7QUFDekM7O0FBRUEsRUFBRSwyRUFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpRUFBb0I7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHVEQUFpQjs7QUFFaEM7QUFDQSxJQUFJLDJFQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELG1CQUFtQjtBQUNyRTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxpQkFBaUIsSUFBSSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBLHdEQUF3RCxzREFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsV0FBVywyQkFBMkIsV0FBVztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSw0REFBYSxFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwREFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQsMERBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVELDBEQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRCwwREFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQsaUVBQWUsWUFBWSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvZm9ybS9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgb2JzZXJ2ZXIgZnJvbSAnQGNvY3JlYXRlL29ic2VydmVyJ1xuaW1wb3J0IGNjdXRpbHMgZnJvbSAnQGNvY3JlYXRlL3V0aWxzJ1xuaW1wb3J0IGNydWQgZnJvbSAnQGNvY3JlYXRlL2NydWQtY2xpZW50J1xuaW1wb3J0IGFjdGlvbiBmcm9tICdAY29jcmVhdGUvYWN0aW9uJ1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuL3V0aWxzXCIgXG5cbmNvbnN0IENvQ3JlYXRlRm9ybSA9IHtcblx0XG5cdHJlcXVlc3RBdHRyOiBcImRhdGEtZG9jdW1lbnRfcmVxdWVzdFwiLFxuXHRzZWxlY3RvcnM6IFtdLFxuXHRtb2R1bGVzOiBbXSxcblxuXHRpbml0OiBmdW5jdGlvbih7bmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrfSkge1xuXHRcdFxuXHRcdHRoaXMubW9kdWxlcy5wdXNoKHtcblx0XHRcdG5hbWUsXG5cdFx0XHRzZWxlY3Rvcixcblx0XHRcdGNhbGxiYWNrXG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKHNlbGVjdG9yKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcblx0XHR9XG5cdH0sXG5cdFxuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZWxlY3RvcnM6IHRoaXMuc2VsZWN0b3JzXG5cdFx0fVxuXHR9LFxuXHRcblx0Y2hlY2tJRDogZnVuY3Rpb24oZWxlbWVudCwgYXR0ciA9IFwiZGF0YS1kb2N1bWVudF9pZFwiKSB7XG5cdFx0bGV0IGRvY3VtZW50X2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cikgfHwgXCJcIjtcblx0XHRpZiAoZG9jdW1lbnRfaWQgPT09IFwiXCIgfHwgZG9jdW1lbnRfaWQgPT09IFwicGVuZGluZ1wiIHx8ICFjY3V0aWxzLmNoZWNrVmFsdWUoZG9jdW1lbnRfaWQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRcblx0cmVxdWVzdDogZnVuY3Rpb24oe2Zvcm0sIGVsZW1lbnQsIG5hbWVBdHRyLCB2YWx1ZX0pIHtcblx0XHRcblx0XHRpZiAoIWZvcm0gJiYgZWxlbWVudCkge1xuXHRcdFx0Zm9ybSA9IGVsZW1lbnQuY2xvc2VzdCgnZm9ybScpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoZm9ybSkge1xuXHRcdFx0dGhpcy5fX3JlcXVlc3REb2N1bWVudElkT2ZGb3JtKGZvcm0pXG5cdFx0fSBlbHNlIGlmIChlbGVtZW50KSB7XG5cdFx0XHRuYW1lQXR0ciA9IG5hbWVBdHRyIHx8IFwibmFtZVwiXG5cdFx0XHR0aGlzLl9fcmVxdWVzdERvY3VtZW50SWQoZWxlbWVudCwgbmFtZUF0dHIsIHZhbHVlKTtcblx0XHR9XG5cdFx0XG5cdH0sXG5cdFxuXHRpbml0RWxlbWVudDogZnVuY3Rpb24oY29udGFpbmVyKSB7XG5cdFx0Y29uc3QgX19jb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnRcblx0XHRcblx0XHRpZiAoIV9fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0ICBmb3JtcyA9IF9fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvcm0nKTtcblxuXHRcdGlmIChmb3Jtcy5sZW5ndGggPT09IDAgJiYgX19jb250YWluZXIgIT0gZG9jdW1lbnQgJiYgX19jb250YWluZXIudGFnTmFtZSA9PT0gXCJGT1JNXCIpIHtcblx0XHRcdGZvcm1zID0gW19fY29udGFpbmVyXTtcblx0XHR9XG5cdFx0XG5cdFx0Zm9ybXMuZm9yRWFjaCgoZm9ybSkgPT4ge1xuXHRcdFx0dXRpbHMuc2V0QXR0cmlidXRlKGZvcm0pXG5cdFx0XHR1dGlscy5kaXNhYmxlQXV0b0ZpbGwoZm9ybSk7XG5cdFx0fSlcblx0fSxcblx0XG5cdF9faW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3QgZm9ybXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdmb3JtJyk7XG5cdFx0dGhpcy5fX2luaXRFdmVudCgpO1xuXG5cdFx0Zm9ybXMuZm9yRWFjaCgoZm9ybSkgPT4ge1xuXHRcdFx0dXRpbHMuc2V0QXR0cmlidXRlKGZvcm0pXG5cdFx0fSlcblx0XHRcblx0fSxcblx0XG5cdF9faW5pdEV2ZW50OiBmdW5jdGlvbigpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjcnVkLmxpc3RlbignY3JlYXRlRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRjb25zdCB7bWV0YWRhdGF9ID0gZGF0YTtcblx0XHRcdHNlbGYuX19yZWNlaXZlZERvY3VtZW50SWQoZGF0YSk7XG5cdFx0XHRpZiAobWV0YWRhdGEgPT0gXCJjcmVhdGVEb2N1bWVudC1hY3Rpb25cIikge1xuXHRcdFx0XHQvLy4gZGlzcGF0Y2ggRW5kQWN0aW9uXG5cdFx0XHR9XG5cdFx0fSlcblx0XHRcblx0XHRjcnVkLmxpc3RlbignZGVsZXRlRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRjb25zdCB7bWV0YWRhdGF9ID0gZGF0YVxuXHRcdFx0aWYgKG1ldGFkYXRhID09PSBcImRlbGV0ZURvY3VtZW50LWFjdGlvblwiKSB7XG5cdFx0XHRcdC8vLmRpc3BhdGNoIEVuZCBBY3Rpb25cblx0XHRcdH1cblx0XHR9KVx0XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2tlZC1zdWJtaXRCdG4nLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Y29uc3Qge2VsZW1lbnR9ID0gZXZlbnQuZGV0YWlsO1xuXG5cdFx0XHRzZWxmLm1vZHVsZXMuZm9yRWFjaCgoe3NlbGVjdG9yLCBjYWxsYmFja30pID0+IHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrICYmIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG51bGwsIGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH0pXG5cdH0sXG5cblx0X19kZWxldGVEb2N1bWVudEFjdGlvbjogZnVuY3Rpb24oYnRuKSB7XG5cdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCB9ID0gY3J1ZC5nZXRBdHRyKGJ0bilcblx0XHRpZiAoY2N1dGlscy5jaGVja1ZhbHVlKGNvbGxlY3Rpb24pICYmIGNjdXRpbHMuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkpIHtcblx0XHRcdGNydWQuZGVsZXRlRG9jdW1lbnQoeyBcblx0XHRcdFx0Y29sbGVjdGlvbiwgXG5cdFx0XHRcdGRvY3VtZW50X2lkLCBcblx0XHRcdFx0J21ldGFkYXRhJzogJ2RlbGV0ZURvY3VtZW50LWFjdGlvbicgXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RlbGV0ZWREb2N1bWVudCcsIHtcblx0XHRcdFx0ZGV0YWlsOiB7fVxuXHRcdFx0fSkpXG5cdFx0fVxuXHR9LFxuXHRcblx0X19kZWxldGVEb2N1bWVudHNBY3Rpb246IGZ1bmN0aW9uKGJ0bikge1xuXHRcdGNvbnN0IHsgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQgfSA9IGNydWQuZ2V0QXR0cihidG4pXG5cdFx0Y29uc3Qgc2VsZWN0b3IgPSBidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X3RhcmdldCcpO1xuXHRcdGlmICghc2VsZWN0b3IpIHJldHVybjtcblx0XHRcblx0XHRjb25zdCBzZWxlY3RlZEVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG5cdFx0XG5cdFx0aWYgKHV0aWxzLmNoZWNrVmFsdWUoY29sbGVjdGlvbikpIHtcblx0XHRcdHNlbGVjdGVkRWxzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGRvY3VtZW50X2lkID0gIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpO1xuXHRcdFx0XHRpZiAoY3J1ZC5jaGVja1ZhbHVlKGRvY3VtZW50X2lkKSkge1xuXHRcdFx0XHRcdGNydWQuZGVsZXRlRG9jdW1lbnQoe1xuXHRcdFx0XHRcdFx0J2NvbGxlY3Rpb24nOiBjb2xsZWN0aW9uLFxuXHRcdFx0XHRcdFx0J2RvY3VtZW50X2lkJzogZG9jdW1lbnRfaWQsXG5cdFx0XHRcdFx0XHQnbWV0YWRhdGEnOiAnJ1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHRcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkZWxldGVkRG9jdW1lbnRzJywge1xuXHRcdFx0XHRkZXRhaWw6IHt9XG5cdFx0XHR9KSlcblx0XHR9XG5cdH0sXG5cdFxuXHRfX2NyZWF0ZURvY3VtZW50QWN0aW9uOiBmdW5jdGlvbihidG4pIHtcblx0XHRjb25zdCBmb3JtID0gYnRuLmNsb3Nlc3QoXCJmb3JtXCIpXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0bGV0IGNvbGxlY3Rpb25zID0gdXRpbHMuZ2V0Q09sbGVjdGlvbnMoZm9ybSlcblx0XHRcblx0XHRjb2xsZWN0aW9ucy5mb3JFYWNoKChjb2xsZWN0aW9uKSA9PiB7XG5cdFx0XHRsZXQgZGF0YSA9IHV0aWxzLmdldEZvcm1EYXRhKGZvcm0sIFwiXCIsIGNvbGxlY3Rpb24pO1xuXHRcdFx0XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID09IDAgJiYgZGF0YS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChjY3V0aWxzLmNoZWNrVmFsdWUoY29sbGVjdGlvbikpIHtcblx0XHRcdFx0Y3J1ZC5jcmVhdGVEb2N1bWVudCh7XG5cdFx0XHRcdFx0J2NvbGxlY3Rpb24nOiBjb2xsZWN0aW9uLFxuXHRcdFx0XHRcdCdkYXRhJzogZGF0YSxcblx0XHRcdFx0XHQnbWV0YWRhdGEnOiAnY3JlYXRlRG9jdW1lbnQtYWN0aW9uJyAsXG5cdFx0XHRcdFx0J2VsZW1lbnQnOidlbXB0eSdcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjcmVhdGVkRG9jdW1lbnQnLCB7XG5cdFx0XHRcdFx0ZGV0YWlsOiB7fVxuXHRcdFx0XHR9KSlcblx0XHRcdH1cblx0XHR9KVxuXHR9LFxuXHRcblx0X19zYXZlRG9jdW1lbnRBY3Rpb246IGZ1bmN0aW9uKGJ0bikge1xuXHRcdGNvbnN0IGZvcm0gPSBidG4uY2xvc2VzdChcImZvcm1cIilcblxuXHRcdGlmICghdXRpbHMuY2hlY2tGb3JtVmFsaWRhdGUoZm9ybSkpIHtcblx0XHRcdGFsZXJ0KCdWYWx1ZXMgYXJlIG5vdCB1bmlxdWUnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0Y29uc3Qgc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvcnMgfHwgW107XG5cdFx0Y29uc3QgZWxlbWVudHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzLmpvaW4oJywnKSk7XG5cdFx0XG5cdFx0bGV0IHJlcXVlc3RfZG9jdW1lbnRfaWQgPSBmYWxzZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGNvbnN0IHsgZG9jdW1lbnRfaWQsIG5hbWUgfSA9IGNydWQuZ2V0QXR0cihlbClcblx0XHRcdGNvbnN0IGlzX3NhdmUgPSBjcnVkLmlzU2F2ZUF0dHIoZWwpXG5cdFx0XHRpZiAoIWlzX3NhdmUpIGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoIWNydWQuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkpIHtcblx0XHRcdFx0aWYgKG5hbWUpIHJlcXVlc3RfZG9jdW1lbnRfaWQgPSB0cnVlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGNydWQuaXNDUkRUKGVsKSkgY29udGludWU7XG5cblx0XHRcdGlmICh1dGlscy5pc1RlbXBsYXRlSW5wdXQoZWwpKSByZXR1cm47XG5cblx0XHRcdHZhciBuZXdfZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJjbGlja2VkLXN1Ym1pdEJ0blwiLCB7XG5cdFx0XHRcdGJ1YmJsZXM6IHRydWUsXG5cdFx0XHRcdGRldGFpbDogeyBcblx0XHRcdFx0XHR0eXBlOiBcInN1Ym1pdEJ0blwiLCBcblx0XHRcdFx0XHRlbGVtZW50OiBlbCBcblx0XHRcdFx0fX0pO1xuXHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChuZXdfZXZlbnQpOyAgXG5cdFx0fVxuXHRcdGlmIChyZXF1ZXN0X2RvY3VtZW50X2lkKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3REb2N1bWVudElkT2ZGb3JtKGZvcm0pXG5cdFx0fVxuXHRcdFxuXHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzYXZlZERvY3VtZW50Jywge1xuXHRcdFx0ZGV0YWlsOiB7fVxuXHRcdH0pKVxuXHR9LFxuXHRcblx0X19yZXF1ZXN0RG9jdW1lbnRJZDogZnVuY3Rpb24oZWxlbWVudCwgbmFtZUF0dHIgPSBcIm5hbWVcIiwgdmFsdWUgPSBudWxsKSB7XG5cdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBuYW1lIH0gID0gY3J1ZC5nZXRBdHRyKGVsZW1lbnQpXG5cdFx0aWYgKCFjb2xsZWN0aW9uIHx8ICFuYW1lKSByZXR1cm4gXG5cblx0XHRjb25zdCByZXF1ZXN0X2lkID0gY2N1dGlscy5nZW5lcmF0ZVVVSUQoKTtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLnJlcXVlc3RBdHRyLCByZXF1ZXN0X2lkKTtcblx0XHRcblx0XHRjcnVkLmNyZWF0ZURvY3VtZW50KHtcblx0XHRcdFwiY29sbGVjdGlvblwiOiBjb2xsZWN0aW9uLFxuXHRcdFx0XCJlbGVtZW50XCI6IHJlcXVlc3RfaWQsXG5cdFx0XHRcIm1ldGFkYXRhXCI6IFwiXCIsXG5cdFx0fSlcblx0fSxcblx0XHRcblx0X19yZXF1ZXN0RG9jdW1lbnRJZE9mRm9ybTogZnVuY3Rpb24gKGZvcm0pIHtcblx0XHRcblx0XHRsZXQgc2VsZiA9IHRoaXM7XG5cdFx0bGV0IGVsZW1lbnMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tuYW1lXSwgW2RhdGEtcGFzc190b10nKVxuXHRcdFxuXHRcdGxldCBjb2xsZWN0aW9ucyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgIGkgPSAwOyBpIDwgZWxlbWVucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGVsID0gZWxlbWVuc1tpXTtcblx0XHRcdGlmIChlbC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygndGVtcGxhdGUnKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IGNvbGxlY3Rpb24gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbGxlY3Rpb25cIikgfHwgZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYXNzX2NvbGxlY3Rpb25cIikgfHwgXCJcIjtcdFxuXHRcdFx0XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNvbGxlY3Rpb24gIT09IFwiXCIgJiYgXG5cdFx0XHRcdCFjb2xsZWN0aW9ucy5pbmNsdWRlcyhjb2xsZWN0aW9uKSAmJiBcblx0XHRcdFx0KCFzZWxmLmNoZWNrSUQoZWwsICdkYXRhLWRvY3VtZW50X2lkJykgJiYgIXNlbGYuY2hlY2tJRChlbCwgJ2RhdGEtcGFzc19kb2N1bWVudF9pZCcpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IHJlcXVlc3RfaWQgPSBjY3V0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXHRcdFx0XHRjb2xsZWN0aW9ucy5wdXNoKGNvbGxlY3Rpb24pO1xuXG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSh0aGlzLnJlcXVlc3RBdHRyLCByZXF1ZXN0X2lkKTtcblx0XHRcdFx0Ly8uIGdldCBEYXRhXG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgZGF0YSA9IHV0aWxzLmdldEZvcm1EYXRhKGZvcm0sIFwiXCIsIGNvbGxlY3Rpb24pO1xuXHRcdFx0XHRcblx0XHRcdFx0LyogRml4TUUgQ3JlYXRlIERvY3VtZW50IHJlcXVlc3QgKi9cdFxuXHRcdFx0XHRjcnVkLmNyZWF0ZURvY3VtZW50KHtcblx0XHRcdFx0XHRcImNvbGxlY3Rpb25cIjogY29sbGVjdGlvbixcblx0XHRcdFx0XHRcImVsZW1lbnRcIjogcmVxdWVzdF9pZCxcblx0XHRcdFx0XHQnZGF0YSc6IGRhdGEsXG5cdFx0XHRcdFx0XCJtZXRhZGF0YVwiOiBcIlwiLFxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfX3NldE5ld0lkUHJvY2VzczogZnVuY3Rpb24oZWxlbWVudCwgZG9jdW1lbnRfaWQsIHBhc3MpIHtcblx0XHRpZiAoIWVsZW1lbnQpIHJldHVybjtcblx0XHRcbiAgXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRoaXMucmVxdWVzdEF0dHIpO1xuXHRcdGNvbnN0IGV2ZW50X2RhdGEgPSB7XG5cdFx0XHRkb2N1bWVudF9pZDogZG9jdW1lbnRfaWQsXG5cdFx0fVxuXG5cdFx0aWYgKCFwYXNzICYmICF0aGlzLmNoZWNrSUQoZWxlbWVudCkgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ25hbWUnKSkge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnLCBkb2N1bWVudF9pZCk7XG5cdCAgXHR9XG5cblx0ICBcdGlmIChwYXNzICYmICF0aGlzLmNoZWNrSUQoZWxlbWVudCwgJ2RhdGEtcGFzc19kb2N1bWVudF9pZCcpICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXBhc3NfdG8nKSkge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFzc19kb2N1bWVudF9pZCcsIGRvY3VtZW50X2lkKTtcblx0XHRcdC8vIENvQ3JlYXRlTG9naWMuc3RvcmVQYXNzRGF0YShlbGVtZW50KVxuXHRcdFx0XG5cdFx0XHRpZiAoZWxlbWVudC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnc3VibWl0QnRuJykpIHtcblx0XHRcdFx0ZWxlbWVudC5jbGljaygpO1xuXHRcdFx0fVxuXHQgIFx0fVxuICBcdFxuXHRcdHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2V0LWRvY3VtZW50X2lkJywge2RldGFpbDogZXZlbnRfZGF0YX0pXG5cdFx0ZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuXHR9LFxuXHRcblx0X19yZWNlaXZlZERvY3VtZW50SWQ6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRpZiAoIWRhdGFbJ2RvY3VtZW50X2lkJ10pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFske3RoaXMucmVxdWVzdEF0dHJ9PVwiJHtkYXRhWydlbGVtZW50J119XCJdYCk7XG5cdFx0aWYgKCFlbGVtZW50KSByZXR1cm47XG5cdFx0bGV0IHNlbGYgPSB0aGlzO1xuXHRcdGNvbnN0IGZvcm0gPSAoZWxlbWVudC50YWdOYW1lID09PSBcIkZPUk1cIikgPyBlbGVtZW50IDogdXRpbHMuZ2V0UGFyZW50cyhlbGVtZW50LCAnZm9ybScpO1xuXHRcdGNvbnN0IGNvbGxlY3Rpb24gPSBkYXRhWydjb2xsZWN0aW9uJ107XG5cdFx0Y29uc3QgaWQgPSBkYXRhWydkb2N1bWVudF9pZCddXG5cdFx0aWYgKGZvcm0gJiYgaWQpIHtcblx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdkYXRhLWZvcm1faWQnLCBkYXRhWydlbGVtZW50J10pO1xuXHRcdFx0Y29uc3QgZWxlbWVudHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWNvbGxlY3Rpb249JHtjb2xsZWN0aW9ufV0sIFtkYXRhLXBhc3NfY29sbGVjdGlvbj0ke2NvbGxlY3Rpb259XWApXG5cdFx0XHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShzZWxmLnJlcXVlc3RBdHRyKTtcblx0XHRcdFx0aWYgKGVsLmhhc0F0dHJpYnV0ZSgnbmFtZScpKSBzZWxmLl9fc2V0TmV3SWRQcm9jZXNzKGVsLCBpZCk7XG5cdFx0XHRcdGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcGFzc190bycpKSBzZWxmLl9fc2V0TmV3SWRQcm9jZXNzKGVsLCBpZCwgdHJ1ZSk7XG5cdFx0XHR9KVxuXHQgIFx0XG5cdFx0fSBlbHNlIGlmIChlbGVtZW50KSB7XG5cdFx0XHR0aGlzLl9fc2V0TmV3SWRQcm9jZXNzKGVsZW1lbnQsIGlkKTtcblx0XHR9XG5cdH0sXG59XG5cbkNvQ3JlYXRlRm9ybS5fX2luaXQoKTtcbi8vIGNvcmUucmVnaXN0ZXJJbml0KENvQ3JlYXRlRm9ybS5pbml0RWxlbWVudCwgQ29DcmVhdGVGb3JtKTtcblxub2JzZXJ2ZXIuaW5pdCh7IFxuXHRuYW1lOiAnQ29DcmVhdGVGb3JtJywgXG5cdG9ic2VydmU6IFsnc3VidHJlZScsICdjaGlsZExpc3QnXSxcblx0aW5jbHVkZTogJ2Zvcm0nLCBcblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uKSB7XG5cdFx0Q29DcmVhdGVGb3JtLmluaXRFbGVtZW50KG11dGF0aW9uLnRhcmdldClcblx0fVxufSlcblxuYWN0aW9uLmluaXQoe1xuXHRhY3Rpb246IFwiY3JlYXRlRG9jdW1lbnRcIixcblx0ZW5kRXZlbnQ6IFwiY3JlYXRlZERvY3VtZW50XCIsXG5cdGNhbGxiYWNrOiAoYnRuLCBkYXRhKSA9PiB7XG5cdFx0Q29DcmVhdGVGb3JtLl9fY3JlYXRlRG9jdW1lbnRBY3Rpb24oYnRuKVxuXHR9LFxufSlcblxuYWN0aW9uLmluaXQoe1xuXHRhY3Rpb246IFwiZGVsZXRlRG9jdW1lbnRcIixcblx0ZW5kRXZlbnQ6IFwiZGVsZXRlZERvY3VtZW50XCIsXG5cdGNhbGxiYWNrOiAoYnRuLCBkYXRhKSA9PiB7XG5cdFx0Q29DcmVhdGVGb3JtLl9fZGVsZXRlRG9jdW1lbnRBY3Rpb24oYnRuKVxuXHR9LFxufSlcblxuYWN0aW9uLmluaXQoe1xuXHRhY3Rpb246IFwiZGVsZXRlRG9jdW1lbnRzXCIsXG5cdGVuZEV2ZW50OiBcImRlbGV0ZWREb2N1bWVudHNcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZURvY3VtZW50Ll9fZGVsZXRlRG9jdW1lbnRzQWN0aW9uKGJ0bilcblx0fSxcbn0pXG5cbmFjdGlvbi5pbml0KHtcblx0YWN0aW9uOiBcInNhdmVEb2N1bWVudFwiLFxuXHRlbmRFdmVudDogXCJzYXZlZERvY3VtZW50XCIsXG5cdGNhbGxiYWNrOiAoYnRuLCBkYXRhKSA9PiB7XG5cdFx0Q29DcmVhdGVGb3JtLl9fc2F2ZURvY3VtZW50QWN0aW9uKGJ0bilcblx0fSxcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlRm9ybTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/form/src/index.js\n")},"./node_modules/@cocreate/form/src/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst Utils = {\n\n\tdisableAutoFill: function(element) {\n\t\tif (element.tagName == \"TEXTAREA\") {\n\t\t\telement.value = \"\";\n\t\t\telement.setAttribute(\"autocomplete\",\"off\")\n\t\t}\n\t\tif (!element.hasAttribute(\"autocomplete\")) {\n\t\t\telement.setAttribute('autocomplete', \"off\");\n\t\t}\n\t},\n\n\tsetAttribute: function(form) {\n\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default().getAttr(form)\n\t\t\n\t\tconst dataRealTime = form.getAttribute('data-realtime');\n\t\tlet elements = form.querySelectorAll('[name], [data-pass_to]')\n\t\t\n\t\t\t\t\t\n\t\telements.forEach(function(el) {\n\t\t\tif (el.parentNode.classList.contains('template')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (el.getAttribute('data-realtime') == null && dataRealTime) {\n\t\t\t\t\n\t\t\t\t// if (!['INPUT', 'TEXTAREA'].indexOf(el.tagName)) {\n\t\t\t\tel.setAttribute('data-realtime', dataRealTime);\n\t\t\t\t// }\n\t\t\t}\n\t\t\tif (el.getAttribute('name') && !el.hasAttribute('data-collection') && collection) {\n\t\t\t\tel.setAttribute('data-collection', collection);\n\t\t\t}\n\t\t\t\n\t\t\tif (el.getAttribute('data-pass_to') && !el.hasAttribute('data-pass_collection') &&  collection) {\n\t\t\t\tel.setAttribute('data-pass_collection', collection);\n\t\t\t}\n\t\t\t\n\t\t\tif (el.getAttribute('name') && !el.getAttribute('data-document_id') && document_id) {\n\t\t\t\tel.setAttribute('data-document_id', document_id)\n\t\t\t}\n\t\t\tif (!el.hasAttribute(\"data-document_id\") && document_id != null) {\n\t\t\t\tel.setAttribute('data-document_id', document_id)\n\t\t\t}\n\n\t\t})\n\t},\n\n\tcheckFormValidate: function(form) {\n\t\t\n\t\tif (typeof CoCreate.unique !== 'undefined') {\n\t\t\treturn CoCreate.unique.checkValidate(form)\n\t\t}\n\t\treturn true;\n\t},\n\t\n\tisTemplateInput: function (input) {\n\t\tif (input.classList.contains('template')) return true;\n\t\t\n\t\tlet node = input.parentNode;\n\t\twhile (node) {\n\t\t\tif (node.classList && node.classList.contains('template')) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\tgetFormData: function(form, document_id, collection) {\n\t\tlet data = {};\n\t\tif (!collection) return {}\n\t\t\n\t\tconst elements = form.querySelectorAll(`[name][data-collection='${collection}']`)\n\t\telements.forEach((el) => {\n\t\t\tlet el_document_id = el.getAttribute('data-document_id') || \"\"\n\t\t\tlet name = el.getAttribute('name')\n\t\t\tlet value = el.value || el.getAttribute('value')\n\t\t\tif (name === \"_id\") return;\n\t\t\tif (!name || !value) return;\n\t\t\tif (document_id == el_document_id) {\n\t\t\t\tdata[name] = el.value\n\t\t\t}\n\t\t})\n\t\treturn data;\n\t},\n\t// getFormData: function(form, selectors) {\n\t// \tconst self = this; \n\t// \tconst elements = form.querySelectorAll(selectors.join(','));\n\t\t\n\t// \tlet request_document_id = false;\n\t// \tlet dataList = [];\n\t\t\n\t\t\n\t// \telements.forEach(el => {\n\t// \t\tlet collection = el.getAttribute('data-collection')\n\t// \t\tlet document_id = el.getAttribute('data-document_id')\n\t// \t\tlet name = el.getAttribute('name')\n\t\t\t\n\t// \t\tif (el.getAttribute('data-save_value') == 'false') {\n\t// \t\t\treturn;\n\t// \t\t}\n\t\t\t\n\t// \t\tif (!document_id && name) {\n\t// \t\t\trequest_document_id = true;\n\t// \t\t\treturn;\n\t// \t\t}\n\t\t\t\n\t// \t\tlet data = dataList.find(d => d.collection == collection && d.document_id == document_id);\n\t\t\t\t\n\t// \t})\n\t// },\n\t\n\tgetParents: function(element, selector = \"form\") {\n\t\tif (!Element.prototype.matches) {\n\t\t\tElement.prototype.matches =\tElement.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector ||\tElement.prototype.oMatchesSelector ||\tElement.prototype.webkitMatchesSelector ||\n\t\t\t\n\t\t\tfunction(s) {\n\t\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length;\n\t\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\t\treturn i > -1;\n\t\t\t};\n\t\t}\n\t\t\n\t\tfor ( ; element && element !== document; element = element.parentNode ) {\n\t\t\tif ( element.matches( selector ) ) return element;\n\t\t}\n\t\treturn null;\n\t},\n\t\n\tsetDocumentIDOfElement: function(element, document_id) {\n\t\tlet old_document_id = element.getAttribute('data-document_id');\n\t\tif (!old_document_id || old_document_id == \"\" || old_document_id == \"pending\") {\n\t\t\telement.setAttribute('data-document_id', document_id);\n\t\t}\n\t},\n\t\n\tgetCOllections: function(form) {\n\t\tlet collections = [];\n\t\tif (!form) return collections;\n\n\t\tlet els = form.querySelectorAll('[name][data-collection]');\n\t\tels.forEach((el) => {\n\t\t\tlet tmpCollection = el.getAttribute('data-collection')\n\t\t\tif (tmpCollection && !collections.includes(tmpCollection)) {\n\t\t\t\tcollections.push(tmpCollection)\n\t\t\t} \n\t\t})\n\t\treturn collections;\n\t},\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Utils);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvZm9ybS9zcmMvdXRpbHMuanM/MTY3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsU0FBUyxnQ0FBZ0MsR0FBRyxvRUFBWTs7QUFFeEQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSCxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsdUI7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGlDQUFpQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRjs7QUFFQSxpRUFBZSxLQUFLIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9mb3JtL3NyYy91dGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnVkIGZyb20gJ0Bjb2NyZWF0ZS9jcnVkLWNsaWVudCdcblxuY29uc3QgVXRpbHMgPSB7XG5cblx0ZGlzYWJsZUF1dG9GaWxsOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0aWYgKGVsZW1lbnQudGFnTmFtZSA9PSBcIlRFWFRBUkVBXCIpIHtcblx0XHRcdGVsZW1lbnQudmFsdWUgPSBcIlwiO1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIixcIm9mZlwiKVxuXHRcdH1cblx0XHRpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJywgXCJvZmZcIik7XG5cdFx0fVxuXHR9LFxuXG5cdHNldEF0dHJpYnV0ZTogZnVuY3Rpb24oZm9ybSkge1xuXHRcdGNvbnN0IHsgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUgfSA9IGNydWQuZ2V0QXR0cihmb3JtKVxuXHRcdFxuXHRcdGNvbnN0IGRhdGFSZWFsVGltZSA9IGZvcm0uZ2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJyk7XG5cdFx0bGV0IGVsZW1lbnRzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbbmFtZV0sIFtkYXRhLXBhc3NfdG9dJylcblx0XHRcblx0XHRcdFx0XHRcblx0XHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRpZiAoZWwucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3RlbXBsYXRlJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScpID09IG51bGwgJiYgZGF0YVJlYWxUaW1lKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiAoIVsnSU5QVVQnLCAnVEVYVEFSRUEnXS5pbmRleE9mKGVsLnRhZ05hbWUpKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScsIGRhdGFSZWFsVGltZSk7XG5cdFx0XHRcdC8vIH1cblx0XHRcdH1cblx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSAmJiAhZWwuaGFzQXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKSAmJiBjb2xsZWN0aW9uKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJywgY29sbGVjdGlvbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFzc190bycpICYmICFlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcGFzc19jb2xsZWN0aW9uJykgJiYgIGNvbGxlY3Rpb24pIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLXBhc3NfY29sbGVjdGlvbicsIGNvbGxlY3Rpb24pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoZWwuZ2V0QXR0cmlidXRlKCduYW1lJykgJiYgIWVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpICYmIGRvY3VtZW50X2lkKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcsIGRvY3VtZW50X2lkKVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWRvY3VtZW50X2lkXCIpICYmIGRvY3VtZW50X2lkICE9IG51bGwpIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJywgZG9jdW1lbnRfaWQpXG5cdFx0XHR9XG5cblx0XHR9KVxuXHR9LFxuXG5cdGNoZWNrRm9ybVZhbGlkYXRlOiBmdW5jdGlvbihmb3JtKSB7XG5cdFx0XG5cdFx0aWYgKHR5cGVvZiBDb0NyZWF0ZS51bmlxdWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gQ29DcmVhdGUudW5pcXVlLmNoZWNrVmFsaWRhdGUoZm9ybSlcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdFxuXHRpc1RlbXBsYXRlSW5wdXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHRcdGlmIChpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoJ3RlbXBsYXRlJykpIHJldHVybiB0cnVlO1xuXHRcdFxuXHRcdGxldCBub2RlID0gaW5wdXQucGFyZW50Tm9kZTtcblx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0aWYgKG5vZGUuY2xhc3NMaXN0ICYmIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZW1wbGF0ZScpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRcblx0Z2V0Rm9ybURhdGE6IGZ1bmN0aW9uKGZvcm0sIGRvY3VtZW50X2lkLCBjb2xsZWN0aW9uKSB7XG5cdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRpZiAoIWNvbGxlY3Rpb24pIHJldHVybiB7fVxuXHRcdFxuXHRcdGNvbnN0IGVsZW1lbnRzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKGBbbmFtZV1bZGF0YS1jb2xsZWN0aW9uPScke2NvbGxlY3Rpb259J11gKVxuXHRcdGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRsZXQgZWxfZG9jdW1lbnRfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKSB8fCBcIlwiXG5cdFx0XHRsZXQgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpXG5cdFx0XHRsZXQgdmFsdWUgPSBlbC52YWx1ZSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcblx0XHRcdGlmIChuYW1lID09PSBcIl9pZFwiKSByZXR1cm47XG5cdFx0XHRpZiAoIW5hbWUgfHwgIXZhbHVlKSByZXR1cm47XG5cdFx0XHRpZiAoZG9jdW1lbnRfaWQgPT0gZWxfZG9jdW1lbnRfaWQpIHtcblx0XHRcdFx0ZGF0YVtuYW1lXSA9IGVsLnZhbHVlXG5cdFx0XHR9XG5cdFx0fSlcblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblx0Ly8gZ2V0Rm9ybURhdGE6IGZ1bmN0aW9uKGZvcm0sIHNlbGVjdG9ycykge1xuXHQvLyBcdGNvbnN0IHNlbGYgPSB0aGlzOyBcblx0Ly8gXHRjb25zdCBlbGVtZW50cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMuam9pbignLCcpKTtcblx0XHRcblx0Ly8gXHRsZXQgcmVxdWVzdF9kb2N1bWVudF9pZCA9IGZhbHNlO1xuXHQvLyBcdGxldCBkYXRhTGlzdCA9IFtdO1xuXHRcdFxuXHRcdFxuXHQvLyBcdGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHQvLyBcdFx0bGV0IGNvbGxlY3Rpb24gPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpXG5cdC8vIFx0XHRsZXQgZG9jdW1lbnRfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKVxuXHQvLyBcdFx0bGV0IG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuXHRcdFx0XG5cdC8vIFx0XHRpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNhdmVfdmFsdWUnKSA9PSAnZmFsc2UnKSB7XG5cdC8vIFx0XHRcdHJldHVybjtcblx0Ly8gXHRcdH1cblx0XHRcdFxuXHQvLyBcdFx0aWYgKCFkb2N1bWVudF9pZCAmJiBuYW1lKSB7XG5cdC8vIFx0XHRcdHJlcXVlc3RfZG9jdW1lbnRfaWQgPSB0cnVlO1xuXHQvLyBcdFx0XHRyZXR1cm47XG5cdC8vIFx0XHR9XG5cdFx0XHRcblx0Ly8gXHRcdGxldCBkYXRhID0gZGF0YUxpc3QuZmluZChkID0+IGQuY29sbGVjdGlvbiA9PSBjb2xsZWN0aW9uICYmIGQuZG9jdW1lbnRfaWQgPT0gZG9jdW1lbnRfaWQpO1xuXHRcdFx0XHRcblx0Ly8gXHR9KVxuXHQvLyB9LFxuXHRcblx0Z2V0UGFyZW50czogZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IgPSBcImZvcm1cIikge1xuXHRcdGlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuXHRcdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XHRFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yIHx8XHRFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24ocykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSwgaSA9IG1hdGNoZXMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID49IDAgJiYgbWF0Y2hlcy5pdGVtKGkpICE9PSB0aGlzKSB7fVxuXHRcdFx0XHRyZXR1cm4gaSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0XG5cdFx0Zm9yICggOyBlbGVtZW50ICYmIGVsZW1lbnQgIT09IGRvY3VtZW50OyBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBlbGVtZW50Lm1hdGNoZXMoIHNlbGVjdG9yICkgKSByZXR1cm4gZWxlbWVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cdFxuXHRzZXREb2N1bWVudElET2ZFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBkb2N1bWVudF9pZCkge1xuXHRcdGxldCBvbGRfZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpO1xuXHRcdGlmICghb2xkX2RvY3VtZW50X2lkIHx8IG9sZF9kb2N1bWVudF9pZCA9PSBcIlwiIHx8IG9sZF9kb2N1bWVudF9pZCA9PSBcInBlbmRpbmdcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnLCBkb2N1bWVudF9pZCk7XG5cdFx0fVxuXHR9LFxuXHRcblx0Z2V0Q09sbGVjdGlvbnM6IGZ1bmN0aW9uKGZvcm0pIHtcblx0XHRsZXQgY29sbGVjdGlvbnMgPSBbXTtcblx0XHRpZiAoIWZvcm0pIHJldHVybiBjb2xsZWN0aW9ucztcblxuXHRcdGxldCBlbHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tuYW1lXVtkYXRhLWNvbGxlY3Rpb25dJyk7XG5cdFx0ZWxzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRsZXQgdG1wQ29sbGVjdGlvbiA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJylcblx0XHRcdGlmICh0bXBDb2xsZWN0aW9uICYmICFjb2xsZWN0aW9ucy5pbmNsdWRlcyh0bXBDb2xsZWN0aW9uKSkge1xuXHRcdFx0XHRjb2xsZWN0aW9ucy5wdXNoKHRtcENvbGxlY3Rpb24pXG5cdFx0XHR9IFxuXHRcdH0pXG5cdFx0cmV0dXJuIGNvbGxlY3Rpb25zO1xuXHR9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBVdGlsczsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/form/src/utils.js\n")},"./node_modules/@cocreate/htmltags/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\");\n/* harmony import */ var _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/utils */ \"./node_modules/@cocreate/utils/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\nconst CoCreateHtmlTags = {\n\n\tselector: \"h1, h2, h3, h4, h5, h6, p, i, q, a, b, li, span, code, head, div, div.domEditor, iframe, body, img, html\",\n\n\tinit: function() {\n\t\tthis.__initAttribute()\n\t\tthis.__initSocket()\n\t\tthis.__initEvents()\n\t\tthis.initElement(document);\n\t},\n\n\tinitElement: function(element) {\n\t\t// if (!element || !element.getAttribute) {\n\t\t// \treturn;\n\t\t// }\n\n\t\tconst requests = this.__getReqeust(element)\n\t\tif (requests && requests.length > 0) {\n\n\t\t\trequests.forEach((req) => {\n\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().readDocument({\n\t\t\t\t\tcollection: req['collection'],\n\t\t\t\t\tdocument_id: req['document_id'],\n\t\t\t\t\tmetadata: req['metadata']\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t},\n\n\tsaveContent: function(el) {\n\t\tconst collection = el.getAttribute('data-collection')\n\t\tconst document_id = el.getAttribute('data-document_id');\n\t\tconst name = el.getAttribute('name')\n\n\t\tlet save_value = '';\n\n\t\tif (el.tagName === 'IFRAME') {\n\t\t\tsave_value = el.srcdoc;\n\t\t}\n\t\telse {\n\t\t\tsave_value = el.innerHTML;\n\t\t}\n\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().updateDocument({\n\t\t\tcollection,\n\t\t\tdocument_id,\n\t\t\tupsert: true,\n\t\t\tbroadcast_sender: false,\n\t\t\tdata: {\n\t\t\t\t[name]: save_value\n\t\t\t},\n\t\t\tbroadcast: false\n\t\t})\n\t},\n\n\tsave: function(el, broadcast, broadcast_sender) {\n\n\t\tif (typeof el == \"object\") {\n\t\t\tconst event = new CustomEvent('changed-element', {});\n\t\t\tel.dispatchEvent(event);\n\t\t}\n\n\t\tif (!el.classList.contains('domEditor')) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if (utils.isRealTime(el) || isSubmit) {\n\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(el);\n\t\tlet el_broadcast = el.getAttribute('data-broadcast') || \"true\";\n\t\tlet namespace = el.getAttribute('data-namespace') || '';\n\t\tlet room = el.getAttribute('data-room') || ''\n\n\t\tel_broadcast = (el_broadcast === \"true\") ? true : false;\n\t\tif (!broadcast) {\n\t\t\tbroadcast = el_broadcast;\n\t\t}\n\n\t\tlet save_value = '';\n\n\t\tif (el.tagName === 'IFRAME') {\n\t\t\tsave_value = el.srcdoc;\n\t\t}\n\t\telse {\n\t\t\tsave_value = el.innerHTML;\n\t\t}\n\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().updateDocument({\n\t\t\tnamespace,\n\t\t\troom,\n\t\t\tcollection,\n\t\t\tdocument_id,\n\t\t\tupsert: true,\n\t\t\tbroadcast_sender,\n\t\t\tdata: {\n\t\t\t\t[name]: save_value\n\t\t\t},\n\t\t\tbroadcast: broadcast\n\t\t})\n\t\t// }\n\t},\n\n\trender: function(data, isUpdate) {\n\n\t\tconst tags_selector = this.__addAttributeSelectorTags(this.selector)\n\t\tlet elements = document.querySelectorAll(tags_selector)\n\n\t\tlet isRendered = false;\n\t\tlet isRenderedIframe = false;\n\t\tconst self = this;\n\n\t\tlet encodeData = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().encodeObject(data.data);\n\n\t\telements.forEach((el) => {\n\t\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(el);\n\t\t\tconst { is_read, is_update } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getFlagAttr(el);\n\t\t\tconst metadata = data['metadata'] || {};\n\t\t\tconst request_id = el.getAttribute('data-request_id')\n\n\t\t\tif (!is_read) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isUpdate && !is_update) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (request_id && data['metadata'] && data['metadata']['request_id'] !== request_id) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (data['collection'] == collection && data['document_id'] == document_id && !el.isContentEditable) {\n\t\t\t\t// const value = self.__getValueFromJonDeep(data.data, name)\n\t\t\t\tconst value = encodeData[name]\n\t\t\t\tif (value === null || value === undefined) return;\n\n\t\t\t\tif (el.tagName === 'IMG') {\n\t\t\t\t\tel.src = value;\n\t\t\t\t}\n\t\t\t\telse if (el.tagName === 'IFRAME') {\n\t\t\t\t\tel.srcdoc = value;\n\t\t\t\t\tlet iframe = el;\n\t\t\t\t\tisRenderedIframe = true;\n\n\t\t\t\n\t\t\t\t\tconsole.log('dnd loaded trigger event')\n\t\t\t\t\tel.onload = function(e) {\n\t\t\t\t\t\tiframe.removeAttribute('srcdoc');\n\t\t\t\t\t\t\t\tlet event = new CustomEvent('CoCreateHtmlTags-rendered', {\n\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\twindow: iframe.contentWindow\n\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\n\t\t\t\t\twindow.parent.dispatchEvent(event);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if (el.tagName === 'DIV') {\n\t\t\t\t\tif (el.hasAttribute(\"value\")) {\n\t\t\t\t\t\tel.setAttribute(\"value\", value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (el.classList.contains('domEditor')) {\n\t\t\t\t\t\tif (el.getAttribute('data-domEditor') == \"replace\") {\n\t\t\t\t\t\t\tlet newElement = document.createElement(\"div\");\n\t\t\t\t\t\t\tnewElement.innerHTML = value;\n\t\t\t\t\t\t\tlet parentNode = el.parentNode;\n\t\t\t\t\t\t\tif (parentNode) {\n\t\t\t\t\t\t\t\tif (newElement.children[0]) {\n\t\t\t\t\t\t\t\t\tparentNode.replaceChild(newElement.children[0], el);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tparentNode.replaceChild(newElement, el);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tel.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tel.innerHTML = value;\n\t\t\t\t\tif (el.hasAttribute(\"value\")) {\n\t\t\t\t\t\tel.setAttribute(\"value\", value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (el.tagName == 'HEAD' || el.tagName == 'BODY') {\n\t\t\t\t\tel.removeAttribute('data-collection');\n\t\t\t\t\tel.removeAttribute('data-document_id');\n\t\t\t\t\tel.removeAttribute('data-pass_id');\n\n\t\t\t\t\tvar scripts = el.querySelectorAll('script');\n\t\t\t\t\tfor (var k = 0; k < scripts.length; k++) {\n\t\t\t\t\t\tvar tmp = document.createElement('script');\n\t\t\t\t\t\ttmp.type = \"text/javascript\";\n\t\t\t\t\t\tvar src = scripts[k].getAttribute('src');\n\t\t\t\t\t\tvar innerHtml = scripts[k].innerHTML;\n\t\t\t\t\t\tif (innerHtml != \"\") tmp.innerHTML = innerHtml;\n\t\t\t\t\t\tif (src) tmp.src = src;\n\t\t\t\t\t\tel.appendChild(tmp);\n\n\t\t\t\t\t\tscripts[k].remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tisRendered = true\n\t\t\t}\n\t\t})\n\n\t\tif (isRendered) {\n\t\t\t//. rendered event\n\t\t\tconst event = new CustomEvent('CoCreateHtmlTags-rendered', {\n\t\t\t\teventType: 'rendered',\n\t\t\t\tdetail: {\n\t\t\t\t\tdata: data\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tdocument.dispatchEvent(event)\n\t\t}\n\n\t\tif (isRenderedIframe) {\n\t\t\tconst iframeEvent = new CustomEvent('CoCreateHtmlTags-iframe-rendered', {\n\t\t\t\teventType: 'rendered',\n\t\t\t\tdetail: {\n\t\t\t\t\tdata: data\n\t\t\t\t}\n\t\t\t})\n\t\t\tdocument.dispatchEvent(iframeEvent)\n\t\t}\n\t},\n\n\t__getReqeust: function(container) {\n\n\t\tlet fetch_container = container || document;\n\n\t\tif (!fetch_container.querySelectorAll) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tags_selector = this.__addAttributeSelectorTags(this.selector)\n\t\tlet elements = fetch_container.querySelectorAll(tags_selector)\n\t\tlet requestData = [];\n\n\t\tif (elements.length == 0 && fetch_container != document && fetch_container.hasAttribute('data-document_id')) {\n\t\t\telements = [fetch_container];\n\t\t}\n\n\t\telements.forEach((el) => {\n\t\t\tif (_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.getInitialized(el, \"htmltags\")) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst { collection, document_id } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(el)\n\t\t\tconst readValue = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().isReadAttr(el);\n\t\t\tconst request_id = el.getAttribute('data-request_id')\n\n\t\t\tif (readValue && _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().checkValue(document_id) && request_id) {\n\t\t\t\t_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.setInitialized(el, \"htmltags\");\n\n\t\t\t\trequestData.push({\n\t\t\t\t\tcollection: collection,\n\t\t\t\t\tdocument_id: document_id,\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\trequest_id: request_id\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tif (readValue && _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().checkValue(document_id) && !requestData.some((d) => d['collection'] === collection && d['document_id'] === document_id)) {\n\t\t\t\trequestData.push({ collection, document_id })\n\t\t\t}\n\t\t})\n\t\treturn requestData;\n\t},\n\n\n\t__initAttribute: function(container) {\n\n\t\tconst mainContainer = container || document;\n\n\t\tif (!mainContainer.querySelectorAll) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tags_selector = this.__addAttributeSelectorTags(this.selector)\n\n\t\tlet elements = mainContainer.querySelectorAll(tags_selector)\n\n\t\tif (elements.length == 0 && mainContainer != document && mainContainer.hasAttribute('data-document_id')) {\n\t\t\telements = [mainContainer]\n\t\t}\n\n\t\telements.forEach((el) => {\n\t\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(el)\n\n\t\t\tif (collection && document_id && name && el.getAttribute('data-realtime') == null) {\n\t\t\t\tel.setAttribute('data-realtime', true)\n\t\t\t}\n\t\t})\n\t},\n\n\t__initSocket: function() {\n\t\tconst self = this;\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().listen('updateDocument', function(data) {\n\t\t\tself.render(data, true)\n\t\t})\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().listen('readDocument', function(data) {\n\t\t\tself.render(data)\n\t\t})\n\n\t\t//  socket.listen('connect', function(data) {\n\t\t// const requests = self.__getReqeust()\n\t\t// if (requests && requests.length > 0) {\n\t\t// \trequests.forEach((req) => {\n\t\t// \t\tcrud.readDocument({\n\t\t// \t\t\tcollection: req['collection'],\n\t\t// \t\t\tdocument_id: req['document_id']\n\t\t// \t\t})\n\t\t// \t})\n\t\t// }\n\t\t//  })\n\t},\n\n\t__initEvents: function() {\n\t\tconst self = this;\n\t\tdocument.addEventListener('change-content', function(event) {\n\t\t\tconst { element, broadcast, broadcast_sender } = event.detail;\n\t\t\tif (!element) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst domEl = self.findElementByChild(element)\n\t\t\tif (domEl) {\n\t\t\t\tself.save(domEl, broadcast, broadcast_sender)\n\t\t\t}\n\n\t\t})\n\t},\n\n\t__addAttributeSelectorTags: function(str_tags) {\n\t\tlet tags = str_tags.trim().split(/\\s*,\\s*/).map(function(tag) {\n\t\t\treturn tag + \"[data-collection][data-document_id][name]\";\n\t\t});\n\t\treturn tags.join(\", \");\n\t},\n\n\tfindElementByChild: function(element) {\n\t\treturn _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.getParentFromElement(element, 'domEditor');\n\t},\n\n\t__getValueFromJonDeep: function(json, path) {\n\t\ttry {\n\t\t\tif (typeof json == 'undefined')\n\t\t\t\treturn false;\n\t\t\tlet subpath = path.split('.');\n\t\t\tlet find = subpath.shift();\n\t\t\tif (subpath.length > 0) {\n\t\t\t\treturn this.__getValueFromJonDeep(json[find], subpath.join('.'))\n\t\t\t}\n\t\t\treturn json[find];\n\t\t}\n\t\tcatch (error) {\n\t\t\tconsole.log(error)\n\t\t\treturn false;\n\t\t}\n\t},\n\n}\n\nCoCreateHtmlTags.init();\n// CoCreateInit.register('CoCreateHtmlTags', CoCreateHtmlTags, CoCreateHtmlTags.initElement);\n\n_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.init({\n\tname: 'CoCreateHtmlTags',\n\tobserve: ['subtree', 'childList'],\n\tinclude: '[data-collection][data-document_id][name]',\n\tcallback: function(mutation) {\n\t\tCoCreateHtmlTags.initElement(mutation.target)\n\t}\n})\n\n// if (window.parent !== window) {\n//   console.log(\"dispatch htmlTags rendered\");\n//   window.addEventListener(\"load\", () => {\n//     window.parent.dispatchEvent(new Event(\"CoCreateHtmlTags-rendered\"));\n//   });\n// }\n// if (window.parent !== window) {\n//   console.log(\"dispatch htmlTags rendered\");\n//   window.addEventListener(\"load\", () => {\n//     window.parent.dispatchEvent(new Event(\"CoCreateJS-onload\"));\n//   });\n// }\n\n\n\n\n\n// if (window.document.readyState != 'complete')\n// \twindow.addEventListener(\"load\", () => {\n// \t\twindow.parent.dispatchEvent(new Event(\"CoCreateHtmlTags-rendered\"));\n// \t});\n// else\n// \twindow.parent.dispatchEvent(new Event(\"CoCreateHtmlTags-rendered\"));\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateHtmlTags);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvaHRtbHRhZ3Mvc3JjL2luZGV4LmpzPzY4NWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUM7QUFDTDtBQUNJOzs7QUFHeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUkseUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDJFQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0NBQWdDLEdBQUcsb0VBQVk7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDJFQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIseUVBQWlCOztBQUVwQztBQUNBLFVBQVUsZ0NBQWdDLEdBQUcsb0VBQVk7QUFDekQsVUFBVSxxQkFBcUIsR0FBRyx3RUFBZ0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLHNFQUF1QjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSwwQkFBMEIsR0FBRyxvRUFBWTtBQUNuRCxxQkFBcUIsdUVBQWU7QUFDcEM7O0FBRUEsb0JBQW9CLHVFQUFlO0FBQ25DLElBQUksc0VBQXVCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0Esb0JBQW9CLHVFQUFlO0FBQ25DLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxnQ0FBZ0MsR0FBRyxvRUFBWTs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUUsbUVBQVc7QUFDYjtBQUNBLEdBQUc7QUFDSCxFQUFFLG1FQUFXO0FBQ2I7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0EsU0FBUyx5RUFBMEI7QUFDbkMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsNERBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7O0FBSUEsaUVBQWUsZ0JBQWdCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2h0bWx0YWdzL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBvYnNlcnZlciBmcm9tICdAY29jcmVhdGUvb2JzZXJ2ZXInXG5pbXBvcnQgdXRpbHMgZnJvbSAnQGNvY3JlYXRlL3V0aWxzJztcbmltcG9ydCBjcnVkIGZyb20gJ0Bjb2NyZWF0ZS9jcnVkLWNsaWVudCdcblxuXG5jb25zdCBDb0NyZWF0ZUh0bWxUYWdzID0ge1xuXG5cdHNlbGVjdG9yOiBcImgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHAsIGksIHEsIGEsIGIsIGxpLCBzcGFuLCBjb2RlLCBoZWFkLCBkaXYsIGRpdi5kb21FZGl0b3IsIGlmcmFtZSwgYm9keSwgaW1nLCBodG1sXCIsXG5cblx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fX2luaXRBdHRyaWJ1dGUoKVxuXHRcdHRoaXMuX19pbml0U29ja2V0KClcblx0XHR0aGlzLl9faW5pdEV2ZW50cygpXG5cdFx0dGhpcy5pbml0RWxlbWVudChkb2N1bWVudCk7XG5cdH0sXG5cblx0aW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHQvLyBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG5cdFx0Ly8gXHRyZXR1cm47XG5cdFx0Ly8gfVxuXG5cdFx0Y29uc3QgcmVxdWVzdHMgPSB0aGlzLl9fZ2V0UmVxZXVzdChlbGVtZW50KVxuXHRcdGlmIChyZXF1ZXN0cyAmJiByZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG5cblx0XHRcdHJlcXVlc3RzLmZvckVhY2goKHJlcSkgPT4ge1xuXHRcdFx0XHRjcnVkLnJlYWREb2N1bWVudCh7XG5cdFx0XHRcdFx0Y29sbGVjdGlvbjogcmVxWydjb2xsZWN0aW9uJ10sXG5cdFx0XHRcdFx0ZG9jdW1lbnRfaWQ6IHJlcVsnZG9jdW1lbnRfaWQnXSxcblx0XHRcdFx0XHRtZXRhZGF0YTogcmVxWydtZXRhZGF0YSddXG5cdFx0XHRcdH0pXG5cdFx0XHR9KVxuXHRcdH1cblx0fSxcblxuXHRzYXZlQ29udGVudDogZnVuY3Rpb24oZWwpIHtcblx0XHRjb25zdCBjb2xsZWN0aW9uID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKVxuXHRcdGNvbnN0IGRvY3VtZW50X2lkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJyk7XG5cdFx0Y29uc3QgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpXG5cblx0XHRsZXQgc2F2ZV92YWx1ZSA9ICcnO1xuXG5cdFx0aWYgKGVsLnRhZ05hbWUgPT09ICdJRlJBTUUnKSB7XG5cdFx0XHRzYXZlX3ZhbHVlID0gZWwuc3JjZG9jO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNhdmVfdmFsdWUgPSBlbC5pbm5lckhUTUw7XG5cdFx0fVxuXG5cdFx0Y3J1ZC51cGRhdGVEb2N1bWVudCh7XG5cdFx0XHRjb2xsZWN0aW9uLFxuXHRcdFx0ZG9jdW1lbnRfaWQsXG5cdFx0XHR1cHNlcnQ6IHRydWUsXG5cdFx0XHRicm9hZGNhc3Rfc2VuZGVyOiBmYWxzZSxcblx0XHRcdGRhdGE6IHtcblx0XHRcdFx0W25hbWVdOiBzYXZlX3ZhbHVlXG5cdFx0XHR9LFxuXHRcdFx0YnJvYWRjYXN0OiBmYWxzZVxuXHRcdH0pXG5cdH0sXG5cblx0c2F2ZTogZnVuY3Rpb24oZWwsIGJyb2FkY2FzdCwgYnJvYWRjYXN0X3NlbmRlcikge1xuXG5cdFx0aWYgKHR5cGVvZiBlbCA9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlZC1lbGVtZW50Jywge30pO1xuXHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2RvbUVkaXRvcicpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gaWYgKHV0aWxzLmlzUmVhbFRpbWUoZWwpIHx8IGlzU3VibWl0KSB7XG5cdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSB9ID0gY3J1ZC5nZXRBdHRyKGVsKTtcblx0XHRsZXQgZWxfYnJvYWRjYXN0ID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJyb2FkY2FzdCcpIHx8IFwidHJ1ZVwiO1xuXHRcdGxldCBuYW1lc3BhY2UgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZXNwYWNlJykgfHwgJyc7XG5cdFx0bGV0IHJvb20gPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcm9vbScpIHx8ICcnXG5cblx0XHRlbF9icm9hZGNhc3QgPSAoZWxfYnJvYWRjYXN0ID09PSBcInRydWVcIikgPyB0cnVlIDogZmFsc2U7XG5cdFx0aWYgKCFicm9hZGNhc3QpIHtcblx0XHRcdGJyb2FkY2FzdCA9IGVsX2Jyb2FkY2FzdDtcblx0XHR9XG5cblx0XHRsZXQgc2F2ZV92YWx1ZSA9ICcnO1xuXG5cdFx0aWYgKGVsLnRhZ05hbWUgPT09ICdJRlJBTUUnKSB7XG5cdFx0XHRzYXZlX3ZhbHVlID0gZWwuc3JjZG9jO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNhdmVfdmFsdWUgPSBlbC5pbm5lckhUTUw7XG5cdFx0fVxuXG5cdFx0Y3J1ZC51cGRhdGVEb2N1bWVudCh7XG5cdFx0XHRuYW1lc3BhY2UsXG5cdFx0XHRyb29tLFxuXHRcdFx0Y29sbGVjdGlvbixcblx0XHRcdGRvY3VtZW50X2lkLFxuXHRcdFx0dXBzZXJ0OiB0cnVlLFxuXHRcdFx0YnJvYWRjYXN0X3NlbmRlcixcblx0XHRcdGRhdGE6IHtcblx0XHRcdFx0W25hbWVdOiBzYXZlX3ZhbHVlXG5cdFx0XHR9LFxuXHRcdFx0YnJvYWRjYXN0OiBicm9hZGNhc3Rcblx0XHR9KVxuXHRcdC8vIH1cblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uKGRhdGEsIGlzVXBkYXRlKSB7XG5cblx0XHRjb25zdCB0YWdzX3NlbGVjdG9yID0gdGhpcy5fX2FkZEF0dHJpYnV0ZVNlbGVjdG9yVGFncyh0aGlzLnNlbGVjdG9yKVxuXHRcdGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFnc19zZWxlY3RvcilcblxuXHRcdGxldCBpc1JlbmRlcmVkID0gZmFsc2U7XG5cdFx0bGV0IGlzUmVuZGVyZWRJZnJhbWUgPSBmYWxzZTtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdGxldCBlbmNvZGVEYXRhID0gY3J1ZC5lbmNvZGVPYmplY3QoZGF0YS5kYXRhKTtcblxuXHRcdGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRjb25zdCB7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lIH0gPSBjcnVkLmdldEF0dHIoZWwpO1xuXHRcdFx0Y29uc3QgeyBpc19yZWFkLCBpc191cGRhdGUgfSA9IGNydWQuZ2V0RmxhZ0F0dHIoZWwpO1xuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBkYXRhWydtZXRhZGF0YSddIHx8IHt9O1xuXHRcdFx0Y29uc3QgcmVxdWVzdF9pZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZXF1ZXN0X2lkJylcblxuXHRcdFx0aWYgKCFpc19yZWFkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzVXBkYXRlICYmICFpc191cGRhdGUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVxdWVzdF9pZCAmJiBkYXRhWydtZXRhZGF0YSddICYmIGRhdGFbJ21ldGFkYXRhJ11bJ3JlcXVlc3RfaWQnXSAhPT0gcmVxdWVzdF9pZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhWydjb2xsZWN0aW9uJ10gPT0gY29sbGVjdGlvbiAmJiBkYXRhWydkb2N1bWVudF9pZCddID09IGRvY3VtZW50X2lkICYmICFlbC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuXHRcdFx0XHQvLyBjb25zdCB2YWx1ZSA9IHNlbGYuX19nZXRWYWx1ZUZyb21Kb25EZWVwKGRhdGEuZGF0YSwgbmFtZSlcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBlbmNvZGVEYXRhW25hbWVdXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKGVsLnRhZ05hbWUgPT09ICdJTUcnKSB7XG5cdFx0XHRcdFx0ZWwuc3JjID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoZWwudGFnTmFtZSA9PT0gJ0lGUkFNRScpIHtcblx0XHRcdFx0XHRlbC5zcmNkb2MgPSB2YWx1ZTtcblx0XHRcdFx0XHRsZXQgaWZyYW1lID0gZWw7XG5cdFx0XHRcdFx0aXNSZW5kZXJlZElmcmFtZSA9IHRydWU7XG5cblx0XHRcdFxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdkbmQgbG9hZGVkIHRyaWdnZXIgZXZlbnQnKVxuXHRcdFx0XHRcdGVsLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdGlmcmFtZS5yZW1vdmVBdHRyaWJ1dGUoJ3NyY2RvYycpO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnQ29DcmVhdGVIdG1sVGFncy1yZW5kZXJlZCcsIHtcblxuXHRcdFx0XHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdFx0XHRcdHdpbmRvdzogaWZyYW1lLmNvbnRlbnRXaW5kb3dcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcblx0XHRcdFx0XHR3aW5kb3cucGFyZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGVsLnRhZ05hbWUgPT09ICdESVYnKSB7XG5cdFx0XHRcdFx0aWYgKGVsLmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpKSB7XG5cdFx0XHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnZG9tRWRpdG9yJykpIHtcblx0XHRcdFx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9tRWRpdG9yJykgPT0gXCJyZXBsYWNlXCIpIHtcblx0XHRcdFx0XHRcdFx0bGV0IG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHRcdFx0XHRuZXdFbGVtZW50LmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRsZXQgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0XHRcdGlmIChwYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5ld0VsZW1lbnQuY2hpbGRyZW5bMF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0VsZW1lbnQuY2hpbGRyZW5bMF0sIGVsKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdFbGVtZW50LCBlbCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKGVsLmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpKSB7XG5cdFx0XHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsLnRhZ05hbWUgPT0gJ0hFQUQnIHx8IGVsLnRhZ05hbWUgPT0gJ0JPRFknKSB7XG5cdFx0XHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKTtcblx0XHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKTtcblx0XHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcGFzc19pZCcpO1xuXG5cdFx0XHRcdFx0dmFyIHNjcmlwdHMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHNjcmlwdHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdFx0XHRcdHRtcC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0XHRcdFx0XHRcdHZhciBzcmMgPSBzY3JpcHRzW2tdLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cdFx0XHRcdFx0XHR2YXIgaW5uZXJIdG1sID0gc2NyaXB0c1trXS5pbm5lckhUTUw7XG5cdFx0XHRcdFx0XHRpZiAoaW5uZXJIdG1sICE9IFwiXCIpIHRtcC5pbm5lckhUTUwgPSBpbm5lckh0bWw7XG5cdFx0XHRcdFx0XHRpZiAoc3JjKSB0bXAuc3JjID0gc3JjO1xuXHRcdFx0XHRcdFx0ZWwuYXBwZW5kQ2hpbGQodG1wKTtcblxuXHRcdFx0XHRcdFx0c2NyaXB0c1trXS5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlzUmVuZGVyZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdGlmIChpc1JlbmRlcmVkKSB7XG5cdFx0XHQvLy4gcmVuZGVyZWQgZXZlbnRcblx0XHRcdGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdDb0NyZWF0ZUh0bWxUYWdzLXJlbmRlcmVkJywge1xuXHRcdFx0XHRldmVudFR5cGU6ICdyZW5kZXJlZCcsXG5cdFx0XHRcdGRldGFpbDoge1xuXHRcdFx0XHRcdGRhdGE6IGRhdGFcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudClcblx0XHR9XG5cblx0XHRpZiAoaXNSZW5kZXJlZElmcmFtZSkge1xuXHRcdFx0Y29uc3QgaWZyYW1lRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ0NvQ3JlYXRlSHRtbFRhZ3MtaWZyYW1lLXJlbmRlcmVkJywge1xuXHRcdFx0XHRldmVudFR5cGU6ICdyZW5kZXJlZCcsXG5cdFx0XHRcdGRldGFpbDoge1xuXHRcdFx0XHRcdGRhdGE6IGRhdGFcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoaWZyYW1lRXZlbnQpXG5cdFx0fVxuXHR9LFxuXG5cdF9fZ2V0UmVxZXVzdDogZnVuY3Rpb24oY29udGFpbmVyKSB7XG5cblx0XHRsZXQgZmV0Y2hfY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCFmZXRjaF9jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRhZ3Nfc2VsZWN0b3IgPSB0aGlzLl9fYWRkQXR0cmlidXRlU2VsZWN0b3JUYWdzKHRoaXMuc2VsZWN0b3IpXG5cdFx0bGV0IGVsZW1lbnRzID0gZmV0Y2hfY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodGFnc19zZWxlY3Rvcilcblx0XHRsZXQgcmVxdWVzdERhdGEgPSBbXTtcblxuXHRcdGlmIChlbGVtZW50cy5sZW5ndGggPT0gMCAmJiBmZXRjaF9jb250YWluZXIgIT0gZG9jdW1lbnQgJiYgZmV0Y2hfY29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpKSB7XG5cdFx0XHRlbGVtZW50cyA9IFtmZXRjaF9jb250YWluZXJdO1xuXHRcdH1cblxuXHRcdGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRpZiAob2JzZXJ2ZXIuZ2V0SW5pdGlhbGl6ZWQoZWwsIFwiaHRtbHRhZ3NcIikpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRjb25zdCB7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkIH0gPSBjcnVkLmdldEF0dHIoZWwpXG5cdFx0XHRjb25zdCByZWFkVmFsdWUgPSBjcnVkLmlzUmVhZEF0dHIoZWwpO1xuXHRcdFx0Y29uc3QgcmVxdWVzdF9pZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZXF1ZXN0X2lkJylcblxuXHRcdFx0aWYgKHJlYWRWYWx1ZSAmJiBjcnVkLmNoZWNrVmFsdWUoZG9jdW1lbnRfaWQpICYmIHJlcXVlc3RfaWQpIHtcblx0XHRcdFx0b2JzZXJ2ZXIuc2V0SW5pdGlhbGl6ZWQoZWwsIFwiaHRtbHRhZ3NcIik7XG5cblx0XHRcdFx0cmVxdWVzdERhdGEucHVzaCh7XG5cdFx0XHRcdFx0Y29sbGVjdGlvbjogY29sbGVjdGlvbixcblx0XHRcdFx0XHRkb2N1bWVudF9pZDogZG9jdW1lbnRfaWQsXG5cdFx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHRcdHJlcXVlc3RfaWQ6IHJlcXVlc3RfaWRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXG5cdFx0XHRpZiAocmVhZFZhbHVlICYmIGNydWQuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkgJiYgIXJlcXVlc3REYXRhLnNvbWUoKGQpID0+IGRbJ2NvbGxlY3Rpb24nXSA9PT0gY29sbGVjdGlvbiAmJiBkWydkb2N1bWVudF9pZCddID09PSBkb2N1bWVudF9pZCkpIHtcblx0XHRcdFx0cmVxdWVzdERhdGEucHVzaCh7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkIH0pXG5cdFx0XHR9XG5cdFx0fSlcblx0XHRyZXR1cm4gcmVxdWVzdERhdGE7XG5cdH0sXG5cblxuXHRfX2luaXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuXG5cdFx0Y29uc3QgbWFpbkNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudDtcblxuXHRcdGlmICghbWFpbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgdGFnc19zZWxlY3RvciA9IHRoaXMuX19hZGRBdHRyaWJ1dGVTZWxlY3RvclRhZ3ModGhpcy5zZWxlY3RvcilcblxuXHRcdGxldCBlbGVtZW50cyA9IG1haW5Db250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0YWdzX3NlbGVjdG9yKVxuXG5cdFx0aWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAwICYmIG1haW5Db250YWluZXIgIT0gZG9jdW1lbnQgJiYgbWFpbkNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKSkge1xuXHRcdFx0ZWxlbWVudHMgPSBbbWFpbkNvbnRhaW5lcl1cblx0XHR9XG5cblx0XHRlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuXHRcdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSB9ID0gY3J1ZC5nZXRBdHRyKGVsKVxuXG5cdFx0XHRpZiAoY29sbGVjdGlvbiAmJiBkb2N1bWVudF9pZCAmJiBuYW1lICYmIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScpID09IG51bGwpIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJywgdHJ1ZSlcblx0XHRcdH1cblx0XHR9KVxuXHR9LFxuXG5cdF9faW5pdFNvY2tldDogZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0Y3J1ZC5saXN0ZW4oJ3VwZGF0ZURvY3VtZW50JywgZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0c2VsZi5yZW5kZXIoZGF0YSwgdHJ1ZSlcblx0XHR9KVxuXHRcdGNydWQubGlzdGVuKCdyZWFkRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRzZWxmLnJlbmRlcihkYXRhKVxuXHRcdH0pXG5cblx0XHQvLyAgc29ja2V0Lmxpc3RlbignY29ubmVjdCcsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHQvLyBjb25zdCByZXF1ZXN0cyA9IHNlbGYuX19nZXRSZXFldXN0KClcblx0XHQvLyBpZiAocmVxdWVzdHMgJiYgcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuXHRcdC8vIFx0cmVxdWVzdHMuZm9yRWFjaCgocmVxKSA9PiB7XG5cdFx0Ly8gXHRcdGNydWQucmVhZERvY3VtZW50KHtcblx0XHQvLyBcdFx0XHRjb2xsZWN0aW9uOiByZXFbJ2NvbGxlY3Rpb24nXSxcblx0XHQvLyBcdFx0XHRkb2N1bWVudF9pZDogcmVxWydkb2N1bWVudF9pZCddXG5cdFx0Ly8gXHRcdH0pXG5cdFx0Ly8gXHR9KVxuXHRcdC8vIH1cblx0XHQvLyAgfSlcblx0fSxcblxuXHRfX2luaXRFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZS1jb250ZW50JywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGNvbnN0IHsgZWxlbWVudCwgYnJvYWRjYXN0LCBicm9hZGNhc3Rfc2VuZGVyIH0gPSBldmVudC5kZXRhaWw7XG5cdFx0XHRpZiAoIWVsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkb21FbCA9IHNlbGYuZmluZEVsZW1lbnRCeUNoaWxkKGVsZW1lbnQpXG5cdFx0XHRpZiAoZG9tRWwpIHtcblx0XHRcdFx0c2VsZi5zYXZlKGRvbUVsLCBicm9hZGNhc3QsIGJyb2FkY2FzdF9zZW5kZXIpXG5cdFx0XHR9XG5cblx0XHR9KVxuXHR9LFxuXG5cdF9fYWRkQXR0cmlidXRlU2VsZWN0b3JUYWdzOiBmdW5jdGlvbihzdHJfdGFncykge1xuXHRcdGxldCB0YWdzID0gc3RyX3RhZ3MudHJpbSgpLnNwbGl0KC9cXHMqLFxccyovKS5tYXAoZnVuY3Rpb24odGFnKSB7XG5cdFx0XHRyZXR1cm4gdGFnICsgXCJbZGF0YS1jb2xsZWN0aW9uXVtkYXRhLWRvY3VtZW50X2lkXVtuYW1lXVwiO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0YWdzLmpvaW4oXCIsIFwiKTtcblx0fSxcblxuXHRmaW5kRWxlbWVudEJ5Q2hpbGQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gdXRpbHMuZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCwgJ2RvbUVkaXRvcicpO1xuXHR9LFxuXG5cdF9fZ2V0VmFsdWVGcm9tSm9uRGVlcDogZnVuY3Rpb24oanNvbiwgcGF0aCkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAodHlwZW9mIGpzb24gPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdGxldCBzdWJwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuXHRcdFx0bGV0IGZpbmQgPSBzdWJwYXRoLnNoaWZ0KCk7XG5cdFx0XHRpZiAoc3VicGF0aC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fZ2V0VmFsdWVGcm9tSm9uRGVlcChqc29uW2ZpbmRdLCBzdWJwYXRoLmpvaW4oJy4nKSlcblx0XHRcdH1cblx0XHRcdHJldHVybiBqc29uW2ZpbmRdO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUubG9nKGVycm9yKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblxufVxuXG5Db0NyZWF0ZUh0bWxUYWdzLmluaXQoKTtcbi8vIENvQ3JlYXRlSW5pdC5yZWdpc3RlcignQ29DcmVhdGVIdG1sVGFncycsIENvQ3JlYXRlSHRtbFRhZ3MsIENvQ3JlYXRlSHRtbFRhZ3MuaW5pdEVsZW1lbnQpO1xuXG5vYnNlcnZlci5pbml0KHtcblx0bmFtZTogJ0NvQ3JlYXRlSHRtbFRhZ3MnLFxuXHRvYnNlcnZlOiBbJ3N1YnRyZWUnLCAnY2hpbGRMaXN0J10sXG5cdGluY2x1ZGU6ICdbZGF0YS1jb2xsZWN0aW9uXVtkYXRhLWRvY3VtZW50X2lkXVtuYW1lXScsXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuXHRcdENvQ3JlYXRlSHRtbFRhZ3MuaW5pdEVsZW1lbnQobXV0YXRpb24udGFyZ2V0KVxuXHR9XG59KVxuXG4vLyBpZiAod2luZG93LnBhcmVudCAhPT0gd2luZG93KSB7XG4vLyAgIGNvbnNvbGUubG9nKFwiZGlzcGF0Y2ggaHRtbFRhZ3MgcmVuZGVyZWRcIik7XG4vLyAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4vLyAgICAgd2luZG93LnBhcmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcIkNvQ3JlYXRlSHRtbFRhZ3MtcmVuZGVyZWRcIikpO1xuLy8gICB9KTtcbi8vIH1cbi8vIGlmICh3aW5kb3cucGFyZW50ICE9PSB3aW5kb3cpIHtcbi8vICAgY29uc29sZS5sb2coXCJkaXNwYXRjaCBodG1sVGFncyByZW5kZXJlZFwiKTtcbi8vICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbi8vICAgICB3aW5kb3cucGFyZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiQ29DcmVhdGVKUy1vbmxvYWRcIikpO1xuLy8gICB9KTtcbi8vIH1cblxuXG5cblxuXG4vLyBpZiAod2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgIT0gJ2NvbXBsZXRlJylcbi8vIFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbi8vIFx0XHR3aW5kb3cucGFyZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiQ29DcmVhdGVIdG1sVGFncy1yZW5kZXJlZFwiKSk7XG4vLyBcdH0pO1xuLy8gZWxzZVxuLy8gXHR3aW5kb3cucGFyZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiQ29DcmVhdGVIdG1sVGFncy1yZW5kZXJlZFwiKSk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZUh0bWxUYWdzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/htmltags/src/index.js\n")},"./node_modules/@cocreate/input/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\");\n/* harmony import */ var _cocreate_form__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/form */ \"./node_modules/@cocreate/form/src/index.js\");\n/* harmony import */ var _cocreate_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cocreate/utils */ \"./node_modules/@cocreate/utils/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _cocreate_crdt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @cocreate/crdt */ \"./node_modules/@cocreate/crdt/src/index.js\");\n\n\n\n\n\n\nconst CoCreateInput = {\n\t\n\tselector: \"input, textarea, select\",\n\t\n\tinit: function() {\n\t\tthis.initElement(document)\n\t},\n\t\n\tinitElement: function(container) {\n\t\t\n\t\tlet mainContainer = container || document;\n\t\tif (!mainContainer.querySelectorAll) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst self = this;\n\t\tlet inputs = mainContainer.querySelectorAll(this.selector);\n\t\t\n\t\tinputs.forEach((input)=> {\n\t\t\tif (_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.getInitialized(input, \"input\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.setInitialized(input, \"input\")\n\t\t\tconst { collection, document_id } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().getAttr(input);\n\t\t\tif (_cocreate_utils__WEBPACK_IMPORTED_MODULE_2__.default.isJsonString(collection)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().isCRDT(input)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (document_id && collection) {\n\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().readDocument({ collection, document_id })\n\t\t\t}\n\t\t\tself.__initEvents(input);\n\t\t})\n\t},\n\t\n\tsave: function (input) {\n\t\t\n\t\tconst value = this.getValue(input);\n\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().getAttr(input);\n\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().updateDocument({\n\t\t\tcollection,\n\t\t\tdocument_id,\n\t\t\tdata: {\n\t\t\t\t[name]: value\n\t\t\t},\n\t\t\t// broadcast_sender: false\n\t\t})\n\t},\n\t\n\n\t\n\trender: function (data, allTags) {\n\t\tlet inputs = document.querySelectorAll(this.selector)\n\t\tlet _this = this;\n\t\t\n\t\tinputs.forEach((input) => {\n\t\t\tif (!allTags) {\n\t\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().isCRDT(input)) return;\n\t\t\t}\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().isCRDT(input)) return;\n\t\t\t\n\t\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().getAttr(input);\n\t\t\t\n\t\t\tconst data_fetch_value = input.getAttribute('data-fetch_value');\n\t\t\t\n\t\t\tif (data_fetch_value === \"false\" || !_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().isReadAttr(input)) return;\n\t\t\t\n\t\t\tif (data['collection'] == collection && data['document_id'] == document_id && (name in data.data)) {\n\t\t\t\t_this.setValue(input, data['data'][name]);\n\t\t\t\t\n\t\t\t\t// fetch value event\n\t\t\t\tinput.dispatchEvent(new Event(\"updated_by_fetch\")); \n\t\t\t\t\n\t\t\t\tinput.dispatchEvent(new CustomEvent('CoCreateInput-run', {\n\t\t\t\t\teventType: 'rendered',\n\t\t\t\t\titem: input,\n\t\t\t\t}))\n\t\t\t}\n\t\t})\n\t\t\n\t},\n\t\n\tgetValue: function(input) {\n\t\tlet value = input.value;\n\n\t\tlet prefix = input.getAttribute('data-prefix_value') || \"\";\n\t\tlet suffix = input.getAttribute('data-suffix_value') || \"\";\n\t\t\n\t\tif (input.type === \"checkbox\") {\n\t\t\tvalue = input.checked\n\t\t} \n\t\telse if (input.type === \"number\") {\n\t\t\tvalue = Number(value)\n\t\t}\n\t\telse if (input.type === \"password\") {\n\t\t\tvalue = this.__encryptPassword(value)\n\t\t}\n\t\t\n\t\tif (typeof value == \"string\") {\n\t\t\tvalue = prefix + value + suffix;\n\t\t}\n\t\t\n\t\treturn value;\n\t},\n\t\n\tsetValue: function(input, value) {\n\t\tif (input.type == 'checkbox') {\n\t\t\tinput.checked = value;\n\t\t} \n\t\telse if (input.type === 'radio') {\n\t\t\tinput.value == value ? input.checked = true : input.checked = false\n\t\t}\n\t\t\n\t\tif (input.type === 'password') {\n\t\t\tvalue = this.__decryptPassword(value);\n\t\t}\n\t\t\n\t\tinput.value = value;\n\n\t\tinput.dispatchEvent(new CustomEvent('CoCreateInput-setvalue', { eventType: 'rendered'}))\n\t},\n\t\n\t__initEvents: function(input) {\n\t\t\n\t\tconst self = this;\n\t\t\n\t\tinput.addEventListener('set-document_id', function() {\n\t\t\t// const { collection, document_id, name } = crud.getAttr(input)\n\t\t\t// crdt.init({ collection, document_id, name, element: input})\n\t\t\tself.save(this)\n\t\t})\n\t\t\n\t\tinput.addEventListener('input', function(e) {\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().isRealtimeAttr(this)) {\n\t\t\t\tself.save(this)\n\t\t\t}\n\t\t})\n\t\t\n\t\tinput.addEventListener('change', function(e) {\n\t\t\tif (this.tagName == 'SELECT' && _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().isRealtimeAttr(this)) {\n\t\t\t\tself.save(this)\n\t\t\t}\n\t\t})\n\t\t\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().listen('updateDocument', function(data) {\n\t\t    self.render(data);\n\t\t})\n\t\t\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().listen('connect', function(data) {\n\t\t\tself.__getReqeust()\n\t\t})\n\t\t\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().listen('readDocument', function(data) {\n\t    \tself.render(data);\n\t\t})\n\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().getAttr(input)\n\n\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().checkValue(collection) && _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().checkValue(document_id) && CoCreate.crdt) {\n\t\t\t_cocreate_crdt__WEBPACK_IMPORTED_MODULE_4__.default.init({ collection, document_id, name, element: input})\n\t\t}\n\t},\n\t\n\t__getReqeust: function(container) {\n\t\t\n\t\tlet fetch_container = container || document;\n\t\tlet inputs = fetch_container.querySelectorAll(this.selector)\n\t\tlet requestData = [];\n\n\t\tinputs.forEach((input) => {\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().isCRDT(input)) return;\n\t\t\t\n\t\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_3___default().getAttr(input)\n\t\t\t\n\t\t\tif (document_id && !requestData.some((d) => d['collection'] === collection && d['document_id'] === document_id)) {\n\t\t\t\trequestData.push({ collection, document_id })\n\t\t\t}\n\t\t})\n\t\treturn requestData;\n\t},\n\t\n\t__encryptPassword: function(str) {\n\t\tvar encodedString = btoa(str);\n\t\treturn encodedString;\n\t},\n\t\n\t__decryptPassword: function (str) {\n\t\tif (!str) {\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\tvar decode_str = atob(str);\n\t\treturn decode_str;\n\t}\n\t\n}\n\nCoCreateInput.init();\n\n_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.init({ \n\tname: 'CoCreateInput', \n\tobserve: ['subtree', 'childList'],\n\tinclude: '[data-collection][data-document_id][name]', \n\tcallback: function(mutation) {\n\t\tCoCreateInput.initElement(mutation.target)\n\t}\n})\n\n_cocreate_form__WEBPACK_IMPORTED_MODULE_1__.default.init({\n\tname: 'CoCreateInput',\n\tselector: \"input, textarea, select\",\n\tcallback: function(el) {\n\t\tCoCreateInput.save(el);\n\t}\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateInput);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvaW5wdXQvc3JjL2luZGV4LmpzPzFkYmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5QztBQUNSO0FBQ0c7QUFDSztBQUNSOztBQUVqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxzRUFBdUI7QUFDOUI7QUFDQTtBQUNBLEdBQUcsc0VBQXVCO0FBQzFCLFVBQVUsMEJBQTBCLEdBQUcsb0VBQVk7QUFDbkQsT0FBTyxpRUFBa0I7QUFDekI7QUFDQTs7QUFFQSxPQUFPLG1FQUFXO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHlFQUFpQixFQUFFLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7O0FBRUE7QUFDQSxTQUFTLGdDQUFnQyxHQUFHLG9FQUFZOztBQUV4RCxFQUFFLDJFQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG1FQUFXO0FBQ25CO0FBQ0EsT0FBTyxtRUFBVzs7QUFFbEIsVUFBVSxnQ0FBZ0MsR0FBRyxvRUFBWTs7QUFFekQ7O0FBRUEsd0NBQXdDLHVFQUFlOztBQUV2RDtBQUNBOztBQUVBO0FBQ0EsdUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFpRSx1QkFBdUI7QUFDeEYsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQSxHQUFHOztBQUVIO0FBQ0EsT0FBTywyRUFBbUI7QUFDMUI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQ0FBbUMsMkVBQW1CO0FBQ3REO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUUsbUVBQVc7QUFDYjtBQUNBLEdBQUc7O0FBRUgsRUFBRSxtRUFBVztBQUNiO0FBQ0EsR0FBRzs7QUFFSCxFQUFFLG1FQUFXO0FBQ2I7QUFDQSxHQUFHO0FBQ0gsU0FBUyxnQ0FBZ0MsR0FBRyxvRUFBWTs7QUFFeEQsTUFBTSx1RUFBZSxnQkFBZ0IsdUVBQWU7QUFDcEQsR0FBRyx3REFBUyxFQUFFLCtDQUErQztBQUM3RDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxtRUFBVzs7QUFFbEIsVUFBVSxnQ0FBZ0MsR0FBRyxvRUFBWTs7QUFFekQ7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0REFBYSxFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3REFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGlFQUFlLGFBQWEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2lucHV0L3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBvYnNlcnZlciBmcm9tICdAY29jcmVhdGUvb2JzZXJ2ZXInXG5pbXBvcnQgZm9ybSBmcm9tICdAY29jcmVhdGUvZm9ybSdcbmltcG9ydCB1dGlscyBmcm9tICdAY29jcmVhdGUvdXRpbHMnO1xuaW1wb3J0IGNydWQgZnJvbSAnQGNvY3JlYXRlL2NydWQtY2xpZW50JztcbmltcG9ydCBjcmR0IGZyb20gJ0Bjb2NyZWF0ZS9jcmR0J1xuXG5jb25zdCBDb0NyZWF0ZUlucHV0ID0ge1xuXHRcblx0c2VsZWN0b3I6IFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIixcblx0XG5cdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW5pdEVsZW1lbnQoZG9jdW1lbnQpXG5cdH0sXG5cdFxuXHRpbml0RWxlbWVudDogZnVuY3Rpb24oY29udGFpbmVyKSB7XG5cdFx0XG5cdFx0bGV0IG1haW5Db250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQ7XG5cdFx0aWYgKCFtYWluQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0bGV0IGlucHV0cyA9IG1haW5Db250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yKTtcblx0XHRcblx0XHRpbnB1dHMuZm9yRWFjaCgoaW5wdXQpPT4ge1xuXHRcdFx0aWYgKG9ic2VydmVyLmdldEluaXRpYWxpemVkKGlucHV0LCBcImlucHV0XCIpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG9ic2VydmVyLnNldEluaXRpYWxpemVkKGlucHV0LCBcImlucHV0XCIpXG5cdFx0XHRjb25zdCB7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkIH0gPSBjcnVkLmdldEF0dHIoaW5wdXQpO1xuXHRcdFx0aWYgKHV0aWxzLmlzSnNvblN0cmluZyhjb2xsZWN0aW9uKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChjcnVkLmlzQ1JEVChpbnB1dCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoZG9jdW1lbnRfaWQgJiYgY29sbGVjdGlvbikge1xuXHRcdFx0XHRjcnVkLnJlYWREb2N1bWVudCh7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkIH0pXG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9faW5pdEV2ZW50cyhpbnB1dCk7XG5cdFx0fSlcblx0fSxcblx0XG5cdHNhdmU6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHRcdFxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZShpbnB1dCk7XG5cdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSB9ID0gY3J1ZC5nZXRBdHRyKGlucHV0KTtcblxuXHRcdGNydWQudXBkYXRlRG9jdW1lbnQoe1xuXHRcdFx0Y29sbGVjdGlvbixcblx0XHRcdGRvY3VtZW50X2lkLFxuXHRcdFx0ZGF0YToge1xuXHRcdFx0XHRbbmFtZV06IHZhbHVlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gYnJvYWRjYXN0X3NlbmRlcjogZmFsc2Vcblx0XHR9KVxuXHR9LFxuXHRcblxuXHRcblx0cmVuZGVyOiBmdW5jdGlvbiAoZGF0YSwgYWxsVGFncykge1xuXHRcdGxldCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpXG5cdFx0bGV0IF90aGlzID0gdGhpcztcblx0XHRcblx0XHRpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcblx0XHRcdGlmICghYWxsVGFncykge1xuXHRcdFx0XHRpZiAoY3J1ZC5pc0NSRFQoaW5wdXQpKSByZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3J1ZC5pc0NSRFQoaW5wdXQpKSByZXR1cm47XG5cdFx0XHRcblx0XHRcdGNvbnN0IHsgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUgfSA9IGNydWQuZ2V0QXR0cihpbnB1dCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRhdGFfZmV0Y2hfdmFsdWUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmV0Y2hfdmFsdWUnKTtcblx0XHRcdFxuXHRcdFx0aWYgKGRhdGFfZmV0Y2hfdmFsdWUgPT09IFwiZmFsc2VcIiB8fCAhY3J1ZC5pc1JlYWRBdHRyKGlucHV0KSkgcmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGF0YVsnY29sbGVjdGlvbiddID09IGNvbGxlY3Rpb24gJiYgZGF0YVsnZG9jdW1lbnRfaWQnXSA9PSBkb2N1bWVudF9pZCAmJiAobmFtZSBpbiBkYXRhLmRhdGEpKSB7XG5cdFx0XHRcdF90aGlzLnNldFZhbHVlKGlucHV0LCBkYXRhWydkYXRhJ11bbmFtZV0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZmV0Y2ggdmFsdWUgZXZlbnRcblx0XHRcdFx0aW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJ1cGRhdGVkX2J5X2ZldGNoXCIpKTsgXG5cdFx0XHRcdFxuXHRcdFx0XHRpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnQ29DcmVhdGVJbnB1dC1ydW4nLCB7XG5cdFx0XHRcdFx0ZXZlbnRUeXBlOiAncmVuZGVyZWQnLFxuXHRcdFx0XHRcdGl0ZW06IGlucHV0LFxuXHRcdFx0XHR9KSlcblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHR9LFxuXHRcblx0Z2V0VmFsdWU6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0bGV0IHZhbHVlID0gaW5wdXQudmFsdWU7XG5cblx0XHRsZXQgcHJlZml4ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLXByZWZpeF92YWx1ZScpIHx8IFwiXCI7XG5cdFx0bGV0IHN1ZmZpeCA9IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1zdWZmaXhfdmFsdWUnKSB8fCBcIlwiO1xuXHRcdFxuXHRcdGlmIChpbnB1dC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcblx0XHRcdHZhbHVlID0gaW5wdXQuY2hlY2tlZFxuXHRcdH0gXG5cdFx0ZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0dmFsdWUgPSBOdW1iZXIodmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGlucHV0LnR5cGUgPT09IFwicGFzc3dvcmRcIikge1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9fZW5jcnlwdFBhc3N3b3JkKHZhbHVlKVxuXHRcdH1cblx0XHRcblx0XHRpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhbHVlID0gcHJlZml4ICsgdmFsdWUgKyBzdWZmaXg7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0XG5cdHNldFZhbHVlOiBmdW5jdGlvbihpbnB1dCwgdmFsdWUpIHtcblx0XHRpZiAoaW5wdXQudHlwZSA9PSAnY2hlY2tib3gnKSB7XG5cdFx0XHRpbnB1dC5jaGVja2VkID0gdmFsdWU7XG5cdFx0fSBcblx0XHRlbHNlIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG5cdFx0XHRpbnB1dC52YWx1ZSA9PSB2YWx1ZSA/IGlucHV0LmNoZWNrZWQgPSB0cnVlIDogaW5wdXQuY2hlY2tlZCA9IGZhbHNlXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChpbnB1dC50eXBlID09PSAncGFzc3dvcmQnKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX19kZWNyeXB0UGFzc3dvcmQodmFsdWUpO1xuXHRcdH1cblx0XHRcblx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXG5cdFx0aW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ0NvQ3JlYXRlSW5wdXQtc2V0dmFsdWUnLCB7IGV2ZW50VHlwZTogJ3JlbmRlcmVkJ30pKVxuXHR9LFxuXHRcblx0X19pbml0RXZlbnRzOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdFxuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdFxuXHRcdGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ3NldC1kb2N1bWVudF9pZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gY29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSB9ID0gY3J1ZC5nZXRBdHRyKGlucHV0KVxuXHRcdFx0Ly8gY3JkdC5pbml0KHsgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUsIGVsZW1lbnQ6IGlucHV0fSlcblx0XHRcdHNlbGYuc2F2ZSh0aGlzKVxuXHRcdH0pXG5cdFx0XG5cdFx0aW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoY3J1ZC5pc1JlYWx0aW1lQXR0cih0aGlzKSkge1xuXHRcdFx0XHRzZWxmLnNhdmUodGhpcylcblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmICh0aGlzLnRhZ05hbWUgPT0gJ1NFTEVDVCcgJiYgY3J1ZC5pc1JlYWx0aW1lQXR0cih0aGlzKSkge1xuXHRcdFx0XHRzZWxmLnNhdmUodGhpcylcblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdGNydWQubGlzdGVuKCd1cGRhdGVEb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHQgICAgc2VsZi5yZW5kZXIoZGF0YSk7XG5cdFx0fSlcblx0XHRcblx0XHRjcnVkLmxpc3RlbignY29ubmVjdCcsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHNlbGYuX19nZXRSZXFldXN0KClcblx0XHR9KVxuXHRcdFxuXHRcdGNydWQubGlzdGVuKCdyZWFkRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICBcdHNlbGYucmVuZGVyKGRhdGEpO1xuXHRcdH0pXG5cdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSB9ID0gY3J1ZC5nZXRBdHRyKGlucHV0KVxuXG5cdFx0aWYgKGNydWQuY2hlY2tWYWx1ZShjb2xsZWN0aW9uKSAmJiBjcnVkLmNoZWNrVmFsdWUoZG9jdW1lbnRfaWQpICYmIENvQ3JlYXRlLmNyZHQpIHtcblx0XHRcdGNyZHQuaW5pdCh7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lLCBlbGVtZW50OiBpbnB1dH0pXG5cdFx0fVxuXHR9LFxuXHRcblx0X19nZXRSZXFldXN0OiBmdW5jdGlvbihjb250YWluZXIpIHtcblx0XHRcblx0XHRsZXQgZmV0Y2hfY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50O1xuXHRcdGxldCBpbnB1dHMgPSBmZXRjaF9jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yKVxuXHRcdGxldCByZXF1ZXN0RGF0YSA9IFtdO1xuXG5cdFx0aW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG5cdFx0XHRpZiAoY3J1ZC5pc0NSRFQoaW5wdXQpKSByZXR1cm47XG5cdFx0XHRcblx0XHRcdGNvbnN0IHsgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUgfSA9IGNydWQuZ2V0QXR0cihpbnB1dClcblx0XHRcdFxuXHRcdFx0aWYgKGRvY3VtZW50X2lkICYmICFyZXF1ZXN0RGF0YS5zb21lKChkKSA9PiBkWydjb2xsZWN0aW9uJ10gPT09IGNvbGxlY3Rpb24gJiYgZFsnZG9jdW1lbnRfaWQnXSA9PT0gZG9jdW1lbnRfaWQpKSB7XG5cdFx0XHRcdHJlcXVlc3REYXRhLnB1c2goeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCB9KVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmV0dXJuIHJlcXVlc3REYXRhO1xuXHR9LFxuXHRcblx0X19lbmNyeXB0UGFzc3dvcmQ6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBlbmNvZGVkU3RyaW5nID0gYnRvYShzdHIpO1xuXHRcdHJldHVybiBlbmNvZGVkU3RyaW5nO1xuXHR9LFxuXHRcblx0X19kZWNyeXB0UGFzc3dvcmQ6IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRpZiAoIXN0cikge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBkZWNvZGVfc3RyID0gYXRvYihzdHIpO1xuXHRcdHJldHVybiBkZWNvZGVfc3RyO1xuXHR9XG5cdFxufVxuXG5Db0NyZWF0ZUlucHV0LmluaXQoKTtcblxub2JzZXJ2ZXIuaW5pdCh7IFxuXHRuYW1lOiAnQ29DcmVhdGVJbnB1dCcsIFxuXHRvYnNlcnZlOiBbJ3N1YnRyZWUnLCAnY2hpbGRMaXN0J10sXG5cdGluY2x1ZGU6ICdbZGF0YS1jb2xsZWN0aW9uXVtkYXRhLWRvY3VtZW50X2lkXVtuYW1lXScsIFxuXHRjYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcblx0XHRDb0NyZWF0ZUlucHV0LmluaXRFbGVtZW50KG11dGF0aW9uLnRhcmdldClcblx0fVxufSlcblxuZm9ybS5pbml0KHtcblx0bmFtZTogJ0NvQ3JlYXRlSW5wdXQnLFxuXHRzZWxlY3RvcjogXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdFwiLFxuXHRjYWxsYmFjazogZnVuY3Rpb24oZWwpIHtcblx0XHRDb0NyZWF0ZUlucHV0LnNhdmUoZWwpO1xuXHR9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVJbnB1dDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/input/src/index.js\n")},"./node_modules/@cocreate/observer/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// window.addEventListener("load", () => {\n\n/*\nCoCreate.observer.init({ \n\tname: \'CoCreateFetchInit\', // no usage, just to provide for console debugging \n\tobserve: [\'subtree\', \'childList\',\'attributes\'], // the same parameters of options in #https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n\tattributes: [\'data-fetch_collection\'], // it doesn\'t count added nodes or remove nodes\n\tinclude: ".classname", // a selector to select only elements that matches\n\texclude: ".classname", // a selector to exclude elements from processing\n\tcallback: function(mutation) { // a function which gets a mutation object according to #https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord\n\t\tCoCreateFetch.initElement(mutation.target)\n\t}\n})\n*/\n\n\n/**\n * description\n * \n * @param {String} [name] - an optional name to provide for debugging console\n * @param {Array} observe - a list of mutation type to be observerd, a mix of possible `attributes`, `childList` or `subtree`\n * ... and other params can be here \n * \n * @return null\n */\nwindow.profiler = {}\nwindow.counter = 0;\nwindow.counter2 = 0;\nwindow.targets = {};\nwindow.attributeName = {};\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n        i = matches.length;\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n}\n\nconst CoCreateObserver = {\n  initTasks: new Map(),\n  attrTasks: new Map(),\n  rules: new Map(),\n  rulesArray: [],\n\n  __init: function() {\n    const self = this;\n    const observer = new MutationObserver((mutationsList, observer) => self.__callback(mutationsList, observer));\n\n    // setTimeout(()=>{\n    observer.observe(document.body, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: false,\n      attributeOldValue: true,\n      characterData: true,\n    });\n  },\n\n  // init: function(data) {\n  //   this.add(data);\n  // },\n\n  init: function({ observe, include, exclude, attributes, name, callback }) {\n    console.log(\' aaaaaaaaaaaaaa observer init \',name)\n\n    // if (name == \'ccAttribute\' || name == \'ccCss\') {\n      if (observe.some(x => x == "childList")) {\n        this.initTasks.set(callback, { observe, include, exclude, attributes, name });\n      }\n\n      if (observe.some(x => x == "attributes")) {\n        this.attrTasks.set(callback, { observe, include, exclude, attributes, name });\n      }\n    // }\n\n  },\n  remove: function(callback) {\n    this.initTasks.delete(callback)\n    this.attrTasks.delete(callback)\n  },\n\n  addRule: function({ include, exclude, name }) {\n    this.rules.set(name, { include, exclude });\n    this.rulesArray = Array.from(this.rules);\n  },\n\n  removeRule: function({ name }) {\n    this.rules.delete(name);\n    this.rulesArray = Array.from(this.rules);\n  },\n\n  __callback: function(mutationsList, observer) {\n    // console.log(this)\n    window.counter++;\n    for (let mutation of mutationsList) {\n      if (mutation.type == "childList" && mutation.addedNodes.length > 0) {\n        //. run init functions\n        this.__initCallback(mutation)\n      }\n\n      if (mutation.type == "attributes") {\n        //. run attributes functions\n        this.__attrCallback(mutation);\n      }\n    }\n  },\n\n  __initCallback: function(mutation) {\n    let addedNodes = Array.from(mutation.addedNodes);\n\n    this.initTasks.forEach(({ observe, include, exclude, attributes, name }, callback) => {\n\n      mutation.addedNodes.forEach((el) => {\n        if (!el.tagName) return;\n\n        if (include && !(el.matches(include) || el.querySelector(include))) {\n          return\n        }\n        if (exclude && (el.matches(exclude) || el.querySelector(exclude))) {\n          return;\n        }\n\n        // if (el.created) return;\n        // window.counter2++;\n        // window.profiler[name] = window.profiler[name] != undefined ? window.profiler[name] + 1 : 0;\n        // window.targets[mutation.target.id || mutation.target.tagName] =\n        //   window.targets[mutation.target.id || mutation.target.tagName] != undefined ?\n        //   window.targets[mutation.target.id || mutation.target.tagName] + 1 :\n        //   0;\n\n        // window.attributeName[mutation.attributeName] =\n        //   window.attributeName[mutation.attributeName] != undefined ?\n        //   window.attributeName[mutation.attributeName] + 1 :\n        //   0;\n        callback.apply(null, [{ type: mutation.type, target: el }]);\n      })\n    });\n\n    // addedNodes.map(el => el.created = true);\n  },\n\n  __attrCallback: function(mutation) {\n    for (let [name, { include, exclude }] of this.rulesArray) {\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n    }\n    this.attrTasks.forEach(({ observe, include, exclude, attributes, name }, callback) => {\n      if (attributes && mutation.attributeName && !attributes.includes(mutation.attributeName)) {\n        return;\n      }\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n\n      if (mutation.attributeName) {\n        let newValue = mutation.target.getAttribute(mutation.attributeName);\n        if (newValue != mutation.oldValue) {\n          // window.counter2++;\n          // window.profiler[name] = window.profiler[name] != undefined ? window.profiler[name] + 1 : 0;\n          // window.targets[mutation.target.id || mutation.target.tagName] =\n          //   window.targets[mutation.target.id || mutation.target.tagName] != undefined ?\n          //   window.targets[mutation.target.id || mutation.target.tagName] + 1 :\n          //   0;\n\n          // window.attributeName[mutation.attributeName] =\n          //   window.attributeName[mutation.attributeName] != undefined ?\n          //   window.attributeName[mutation.attributeName] + 1 :\n          //   0;\n          callback.apply(null, [mutation]);\n        }\n      }\n\n    })\n  },\n\n  setInitialized: function(element, type) {\n    // element.setAttribute(`initialized_${type}`, "true");\n    type = type || "";\n    let key = "co_initialized_" + type;\n    element[key] = true;\n  },\n\n  getInitialized: function(element, type) {\n    type = type || "";\n    let key = "co_initialized_" + type;\n    if (!element[key]) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n}\n\nCoCreateObserver.__init();\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateObserver);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvb2JzZXJ2ZXIvc3JjL2luZGV4LmpzP2VkMmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVBO0FBQ0Esd0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLE1BQU07O0FBRU4sa0JBQWtCLHdEQUF3RDtBQUMxRTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjs7QUFFQTtBQUNBLHNDQUFzQyw4Q0FBOEM7QUFDcEY7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxxQkFBcUIseUJBQXlCO0FBQzlDLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQSxHQUFHOztBQUVILHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSw2QkFBNkIsOENBQThDOztBQUUzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakUsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOENBQThDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxpRUFBZSxnQkFBZ0IsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvb2JzZXJ2ZXIvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcblxuLypcbkNvQ3JlYXRlLm9ic2VydmVyLmluaXQoeyBcblx0bmFtZTogJ0NvQ3JlYXRlRmV0Y2hJbml0JywgLy8gbm8gdXNhZ2UsIGp1c3QgdG8gcHJvdmlkZSBmb3IgY29uc29sZSBkZWJ1Z2dpbmcgXG5cdG9ic2VydmU6IFsnc3VidHJlZScsICdjaGlsZExpc3QnLCdhdHRyaWJ1dGVzJ10sIC8vIHRoZSBzYW1lIHBhcmFtZXRlcnMgb2Ygb3B0aW9ucyBpbiAjaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXIvb2JzZXJ2ZVxuXHRhdHRyaWJ1dGVzOiBbJ2RhdGEtZmV0Y2hfY29sbGVjdGlvbiddLCAvLyBpdCBkb2Vzbid0IGNvdW50IGFkZGVkIG5vZGVzIG9yIHJlbW92ZSBub2Rlc1xuXHRpbmNsdWRlOiBcIi5jbGFzc25hbWVcIiwgLy8gYSBzZWxlY3RvciB0byBzZWxlY3Qgb25seSBlbGVtZW50cyB0aGF0IG1hdGNoZXNcblx0ZXhjbHVkZTogXCIuY2xhc3NuYW1lXCIsIC8vIGEgc2VsZWN0b3IgdG8gZXhjbHVkZSBlbGVtZW50cyBmcm9tIHByb2Nlc3Npbmdcblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uKSB7IC8vIGEgZnVuY3Rpb24gd2hpY2ggZ2V0cyBhIG11dGF0aW9uIG9iamVjdCBhY2NvcmRpbmcgdG8gI2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NdXRhdGlvblJlY29yZFxuXHRcdENvQ3JlYXRlRmV0Y2guaW5pdEVsZW1lbnQobXV0YXRpb24udGFyZ2V0KVxuXHR9XG59KVxuKi9cblxuXG4vKipcbiAqIGRlc2NyaXB0aW9uXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBhbiBvcHRpb25hbCBuYW1lIHRvIHByb3ZpZGUgZm9yIGRlYnVnZ2luZyBjb25zb2xlXG4gKiBAcGFyYW0ge0FycmF5fSBvYnNlcnZlIC0gYSBsaXN0IG9mIG11dGF0aW9uIHR5cGUgdG8gYmUgb2JzZXJ2ZXJkLCBhIG1peCBvZiBwb3NzaWJsZSBgYXR0cmlidXRlc2AsIGBjaGlsZExpc3RgIG9yIGBzdWJ0cmVlYFxuICogLi4uIGFuZCBvdGhlciBwYXJhbXMgY2FuIGJlIGhlcmUgXG4gKiBcbiAqIEByZXR1cm4gbnVsbFxuICovXG53aW5kb3cucHJvZmlsZXIgPSB7fVxud2luZG93LmNvdW50ZXIgPSAwO1xud2luZG93LmNvdW50ZXIyID0gMDtcbndpbmRvdy50YXJnZXRzID0ge307XG53aW5kb3cuYXR0cmlidXRlTmFtZSA9IHt9O1xuaWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPVxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBtYXRjaGVzID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHMpLFxuICAgICAgICBpID0gbWF0Y2hlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoLS1pID49IDAgJiYgbWF0Y2hlcy5pdGVtKGkpICE9PSB0aGlzKSB7fVxuICAgICAgcmV0dXJuIGkgPiAtMTtcbiAgICB9O1xufVxuXG5jb25zdCBDb0NyZWF0ZU9ic2VydmVyID0ge1xuICBpbml0VGFza3M6IG5ldyBNYXAoKSxcbiAgYXR0clRhc2tzOiBuZXcgTWFwKCksXG4gIHJ1bGVzOiBuZXcgTWFwKCksXG4gIHJ1bGVzQXJyYXk6IFtdLFxuXG4gIF9faW5pdDogZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zTGlzdCwgb2JzZXJ2ZXIpID0+IHNlbGYuX19jYWxsYmFjayhtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikpO1xuXG4gICAgLy8gc2V0VGltZW91dCgoKT0+e1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBjaGFyYWN0ZXJEYXRhOiBmYWxzZSxcbiAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICB9KTtcbiAgfSxcblxuICAvLyBpbml0OiBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICAgdGhpcy5hZGQoZGF0YSk7XG4gIC8vIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24oeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lLCBjYWxsYmFjayB9KSB7XG4gICAgY29uc29sZS5sb2coJyBhYWFhYWFhYWFhYWFhYSBvYnNlcnZlciBpbml0ICcsbmFtZSlcblxuICAgIC8vIGlmIChuYW1lID09ICdjY0F0dHJpYnV0ZScgfHwgbmFtZSA9PSAnY2NDc3MnKSB7XG4gICAgICBpZiAob2JzZXJ2ZS5zb21lKHggPT4geCA9PSBcImNoaWxkTGlzdFwiKSkge1xuICAgICAgICB0aGlzLmluaXRUYXNrcy5zZXQoY2FsbGJhY2ssIHsgb2JzZXJ2ZSwgaW5jbHVkZSwgZXhjbHVkZSwgYXR0cmlidXRlcywgbmFtZSB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9ic2VydmUuc29tZSh4ID0+IHggPT0gXCJhdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgIHRoaXMuYXR0clRhc2tzLnNldChjYWxsYmFjaywgeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lIH0pO1xuICAgICAgfVxuICAgIC8vIH1cblxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbml0VGFza3MuZGVsZXRlKGNhbGxiYWNrKVxuICAgIHRoaXMuYXR0clRhc2tzLmRlbGV0ZShjYWxsYmFjaylcbiAgfSxcblxuICBhZGRSdWxlOiBmdW5jdGlvbih7IGluY2x1ZGUsIGV4Y2x1ZGUsIG5hbWUgfSkge1xuICAgIHRoaXMucnVsZXMuc2V0KG5hbWUsIHsgaW5jbHVkZSwgZXhjbHVkZSB9KTtcbiAgICB0aGlzLnJ1bGVzQXJyYXkgPSBBcnJheS5mcm9tKHRoaXMucnVsZXMpO1xuICB9LFxuXG4gIHJlbW92ZVJ1bGU6IGZ1bmN0aW9uKHsgbmFtZSB9KSB7XG4gICAgdGhpcy5ydWxlcy5kZWxldGUobmFtZSk7XG4gICAgdGhpcy5ydWxlc0FycmF5ID0gQXJyYXkuZnJvbSh0aGlzLnJ1bGVzKTtcbiAgfSxcblxuICBfX2NhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikge1xuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpXG4gICAgd2luZG93LmNvdW50ZXIrKztcbiAgICBmb3IgKGxldCBtdXRhdGlvbiBvZiBtdXRhdGlvbnNMaXN0KSB7XG4gICAgICBpZiAobXV0YXRpb24udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLy4gcnVuIGluaXQgZnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX19pbml0Q2FsbGJhY2sobXV0YXRpb24pXG4gICAgICB9XG5cbiAgICAgIGlmIChtdXRhdGlvbi50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgIC8vLiBydW4gYXR0cmlidXRlcyBmdW5jdGlvbnNcbiAgICAgICAgdGhpcy5fX2F0dHJDYWxsYmFjayhtdXRhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9faW5pdENhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuICAgIGxldCBhZGRlZE5vZGVzID0gQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKTtcblxuICAgIHRoaXMuaW5pdFRhc2tzLmZvckVhY2goKHsgb2JzZXJ2ZSwgaW5jbHVkZSwgZXhjbHVkZSwgYXR0cmlidXRlcywgbmFtZSB9LCBjYWxsYmFjaykgPT4ge1xuXG4gICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGlmICghZWwudGFnTmFtZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChpbmNsdWRlICYmICEoZWwubWF0Y2hlcyhpbmNsdWRlKSB8fCBlbC5xdWVyeVNlbGVjdG9yKGluY2x1ZGUpKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChleGNsdWRlICYmIChlbC5tYXRjaGVzKGV4Y2x1ZGUpIHx8IGVsLnF1ZXJ5U2VsZWN0b3IoZXhjbHVkZSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKGVsLmNyZWF0ZWQpIHJldHVybjtcbiAgICAgICAgLy8gd2luZG93LmNvdW50ZXIyKys7XG4gICAgICAgIC8vIHdpbmRvdy5wcm9maWxlcltuYW1lXSA9IHdpbmRvdy5wcm9maWxlcltuYW1lXSAhPSB1bmRlZmluZWQgPyB3aW5kb3cucHJvZmlsZXJbbmFtZV0gKyAxIDogMDtcbiAgICAgICAgLy8gd2luZG93LnRhcmdldHNbbXV0YXRpb24udGFyZ2V0LmlkIHx8IG11dGF0aW9uLnRhcmdldC50YWdOYW1lXSA9XG4gICAgICAgIC8vICAgd2luZG93LnRhcmdldHNbbXV0YXRpb24udGFyZ2V0LmlkIHx8IG11dGF0aW9uLnRhcmdldC50YWdOYW1lXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICAvLyAgIHdpbmRvdy50YXJnZXRzW211dGF0aW9uLnRhcmdldC5pZCB8fCBtdXRhdGlvbi50YXJnZXQudGFnTmFtZV0gKyAxIDpcbiAgICAgICAgLy8gICAwO1xuXG4gICAgICAgIC8vIHdpbmRvdy5hdHRyaWJ1dGVOYW1lW211dGF0aW9uLmF0dHJpYnV0ZU5hbWVdID1cbiAgICAgICAgLy8gICB3aW5kb3cuYXR0cmlidXRlTmFtZVttdXRhdGlvbi5hdHRyaWJ1dGVOYW1lXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICAvLyAgIHdpbmRvdy5hdHRyaWJ1dGVOYW1lW211dGF0aW9uLmF0dHJpYnV0ZU5hbWVdICsgMSA6XG4gICAgICAgIC8vICAgMDtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW3sgdHlwZTogbXV0YXRpb24udHlwZSwgdGFyZ2V0OiBlbCB9XSk7XG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgLy8gYWRkZWROb2Rlcy5tYXAoZWwgPT4gZWwuY3JlYXRlZCA9IHRydWUpO1xuICB9LFxuXG4gIF9fYXR0ckNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuICAgIGZvciAobGV0IFtuYW1lLCB7IGluY2x1ZGUsIGV4Y2x1ZGUgfV0gb2YgdGhpcy5ydWxlc0FycmF5KSB7XG4gICAgICBpZiAoaW5jbHVkZSAmJiAhbXV0YXRpb24udGFyZ2V0Lm1hdGNoZXMoaW5jbHVkZSkpIHJldHVybjtcbiAgICAgIGlmIChleGNsdWRlICYmIG11dGF0aW9uLnRhcmdldC5tYXRjaGVzKGV4Y2x1ZGUpKSByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXR0clRhc2tzLmZvckVhY2goKHsgb2JzZXJ2ZSwgaW5jbHVkZSwgZXhjbHVkZSwgYXR0cmlidXRlcywgbmFtZSB9LCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgbXV0YXRpb24uYXR0cmlidXRlTmFtZSAmJiAhYXR0cmlidXRlcy5pbmNsdWRlcyhtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZSAmJiAhbXV0YXRpb24udGFyZ2V0Lm1hdGNoZXMoaW5jbHVkZSkpIHJldHVybjtcbiAgICAgIGlmIChleGNsdWRlICYmIG11dGF0aW9uLnRhcmdldC5tYXRjaGVzKGV4Y2x1ZGUpKSByZXR1cm47XG5cbiAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IG11dGF0aW9uLnRhcmdldC5nZXRBdHRyaWJ1dGUobXV0YXRpb24uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPSBtdXRhdGlvbi5vbGRWYWx1ZSkge1xuICAgICAgICAgIC8vIHdpbmRvdy5jb3VudGVyMisrO1xuICAgICAgICAgIC8vIHdpbmRvdy5wcm9maWxlcltuYW1lXSA9IHdpbmRvdy5wcm9maWxlcltuYW1lXSAhPSB1bmRlZmluZWQgPyB3aW5kb3cucHJvZmlsZXJbbmFtZV0gKyAxIDogMDtcbiAgICAgICAgICAvLyB3aW5kb3cudGFyZ2V0c1ttdXRhdGlvbi50YXJnZXQuaWQgfHwgbXV0YXRpb24udGFyZ2V0LnRhZ05hbWVdID1cbiAgICAgICAgICAvLyAgIHdpbmRvdy50YXJnZXRzW211dGF0aW9uLnRhcmdldC5pZCB8fCBtdXRhdGlvbi50YXJnZXQudGFnTmFtZV0gIT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAvLyAgIHdpbmRvdy50YXJnZXRzW211dGF0aW9uLnRhcmdldC5pZCB8fCBtdXRhdGlvbi50YXJnZXQudGFnTmFtZV0gKyAxIDpcbiAgICAgICAgICAvLyAgIDA7XG5cbiAgICAgICAgICAvLyB3aW5kb3cuYXR0cmlidXRlTmFtZVttdXRhdGlvbi5hdHRyaWJ1dGVOYW1lXSA9XG4gICAgICAgICAgLy8gICB3aW5kb3cuYXR0cmlidXRlTmFtZVttdXRhdGlvbi5hdHRyaWJ1dGVOYW1lXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICAgIC8vICAgd2luZG93LmF0dHJpYnV0ZU5hbWVbbXV0YXRpb24uYXR0cmlidXRlTmFtZV0gKyAxIDpcbiAgICAgICAgICAvLyAgIDA7XG4gICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW211dGF0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pXG4gIH0sXG5cbiAgc2V0SW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcbiAgICAvLyBlbGVtZW50LnNldEF0dHJpYnV0ZShgaW5pdGlhbGl6ZWRfJHt0eXBlfWAsIFwidHJ1ZVwiKTtcbiAgICB0eXBlID0gdHlwZSB8fCBcIlwiO1xuICAgIGxldCBrZXkgPSBcImNvX2luaXRpYWxpemVkX1wiICsgdHlwZTtcbiAgICBlbGVtZW50W2tleV0gPSB0cnVlO1xuICB9LFxuXG4gIGdldEluaXRpYWxpemVkOiBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgfHwgXCJcIjtcbiAgICBsZXQga2V5ID0gXCJjb19pbml0aWFsaXplZF9cIiArIHR5cGU7XG4gICAgaWYgKCFlbGVtZW50W2tleV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuQ29DcmVhdGVPYnNlcnZlci5fX2luaXQoKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZU9ic2VydmVyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/observer/src/index.js\n')},"./node_modules/@cocreate/socket-client/src/common-fun.js":function(module,exports){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        \treturn factory(window)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== \'undefined\' ? self : this, function (wnd) {\n  function getCommonParams() \n  {\n    let config = {};\n    if (wnd && wnd.config) {\n      config = wnd.config\n    }\n    \n    return {\n      "apiKey":           config.apiKey,\n      "securityKey":      config.securityKey,\n      "organization_id":  config.organization_Id,\n    }\n  }\n  \n  function getCommonParamsExtend(info) \n  {\n    let config = {};\n    if (wnd && wnd.config) config = wnd.config\n    \n    return {\n      "apiKey":           info.apiKey || config.apiKey,\n      "securityKey":      info.securityKey || config.securityKey,\n      "organization_id":  info.organization_id || config.organization_Id,\n    }\n  }\n  \n  function generateSocketClient (namespace, room) \n  {\n    let config = {};\n    if (wnd && wnd.config) config = wnd.config\n    \n    let ns = namespace || config.organization_Id\n    let rr = room || \'\';\n    if (rr) {\n      return `${ns}/${rr}`\n    } else {\n      return ns;\n    }\n  }\n  \n  function GenerateUUID(length = 36) {\n    let d = new Date().getTime();\n    let d2 = 0;\n    let pattern = "uxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";\n  \n    if (length <= pattern.length) {\n      pattern = pattern.substr(0, length);\n    } else {\n      let add_len = length - pattern.length;\n      let sub_pattern = "-xxxyyxxx";\n  \n      let group_n = Math.floor(add_len / sub_pattern.length);\n  \n      for (let i = 0; i < group_n; i++) {\n        pattern += sub_pattern;\n      }\n  \n      group_n = add_len - group_n * sub_pattern.length;\n      pattern += sub_pattern.substr(0, group_n);\n    }\n  \n    let uuid = pattern.replace(/[xy]/g, function (c) {\n      var r = Math.random() * 16;\n      if (d > 0) {\n        var r = (d + r) % 16 | 0;\n        d = Math.floor(d / 16);\n      } else {\n        var r = (d2 + r) % 16 | 0;\n        d2 = Math.floor(d2 / 16);\n      }\n      return (c == "x" ? r : (r & 0x7) | 0x8).toString(16);\n    });\n    return uuid;\n  }\n  \n  return {getCommonParams, getCommonParamsExtend, generateSocketClient, GenerateUUID};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvc29ja2V0LWNsaWVudC9zcmMvY29tbW9uLWZ1bi5qcz82OTEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRDtBQUNBLFFBQVEsaUNBQU8sRUFBRSxtQ0FBRTtBQUNuQjtBQUNBLFNBQVM7QUFBQSxrR0FBQztBQUNWLEtBQUssTUFBTSxFQVFSO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHLEdBQUcsR0FBRztBQUN6QixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsVUFBVTtBQUNWLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL3NvY2tldC1jbGllbnQvc3JjL2NvbW1vbi1mdW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgXHRyZXR1cm4gZmFjdG9yeSh3aW5kb3cpXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290LnJldHVybkV4cG9ydHMgPSBmYWN0b3J5KHdpbmRvdyk7XG4gIH1cbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uICh3bmQpIHtcbiAgZnVuY3Rpb24gZ2V0Q29tbW9uUGFyYW1zKCkgXG4gIHtcbiAgICBsZXQgY29uZmlnID0ge307XG4gICAgaWYgKHduZCAmJiB3bmQuY29uZmlnKSB7XG4gICAgICBjb25maWcgPSB3bmQuY29uZmlnXG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBcImFwaUtleVwiOiAgICAgICAgICAgY29uZmlnLmFwaUtleSxcbiAgICAgIFwic2VjdXJpdHlLZXlcIjogICAgICBjb25maWcuc2VjdXJpdHlLZXksXG4gICAgICBcIm9yZ2FuaXphdGlvbl9pZFwiOiAgY29uZmlnLm9yZ2FuaXphdGlvbl9JZCxcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldENvbW1vblBhcmFtc0V4dGVuZChpbmZvKSBcbiAge1xuICAgIGxldCBjb25maWcgPSB7fTtcbiAgICBpZiAod25kICYmIHduZC5jb25maWcpIGNvbmZpZyA9IHduZC5jb25maWdcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgXCJhcGlLZXlcIjogICAgICAgICAgIGluZm8uYXBpS2V5IHx8IGNvbmZpZy5hcGlLZXksXG4gICAgICBcInNlY3VyaXR5S2V5XCI6ICAgICAgaW5mby5zZWN1cml0eUtleSB8fCBjb25maWcuc2VjdXJpdHlLZXksXG4gICAgICBcIm9yZ2FuaXphdGlvbl9pZFwiOiAgaW5mby5vcmdhbml6YXRpb25faWQgfHwgY29uZmlnLm9yZ2FuaXphdGlvbl9JZCxcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU29ja2V0Q2xpZW50IChuYW1lc3BhY2UsIHJvb20pIFxuICB7XG4gICAgbGV0IGNvbmZpZyA9IHt9O1xuICAgIGlmICh3bmQgJiYgd25kLmNvbmZpZykgY29uZmlnID0gd25kLmNvbmZpZ1xuICAgIFxuICAgIGxldCBucyA9IG5hbWVzcGFjZSB8fCBjb25maWcub3JnYW5pemF0aW9uX0lkXG4gICAgbGV0IHJyID0gcm9vbSB8fCAnJztcbiAgICBpZiAocnIpIHtcbiAgICAgIHJldHVybiBgJHtuc30vJHtycn1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBucztcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIEdlbmVyYXRlVVVJRChsZW5ndGggPSAzNikge1xuICAgIGxldCBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgbGV0IGQyID0gMDtcbiAgICBsZXQgcGF0dGVybiA9IFwidXh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCI7XG4gIFxuICAgIGlmIChsZW5ndGggPD0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cigwLCBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYWRkX2xlbiA9IGxlbmd0aCAtIHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgbGV0IHN1Yl9wYXR0ZXJuID0gXCIteHh4eXl4eHhcIjtcbiAgXG4gICAgICBsZXQgZ3JvdXBfbiA9IE1hdGguZmxvb3IoYWRkX2xlbiAvIHN1Yl9wYXR0ZXJuLmxlbmd0aCk7XG4gIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cF9uOyBpKyspIHtcbiAgICAgICAgcGF0dGVybiArPSBzdWJfcGF0dGVybjtcbiAgICAgIH1cbiAgXG4gICAgICBncm91cF9uID0gYWRkX2xlbiAtIGdyb3VwX24gKiBzdWJfcGF0dGVybi5sZW5ndGg7XG4gICAgICBwYXR0ZXJuICs9IHN1Yl9wYXR0ZXJuLnN1YnN0cigwLCBncm91cF9uKTtcbiAgICB9XG4gIFxuICAgIGxldCB1dWlkID0gcGF0dGVybi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgICAgIGlmIChkID4gMCkge1xuICAgICAgICB2YXIgciA9IChkICsgcikgJSAxNiB8IDA7XG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IChkMiArIHIpICUgMTYgfCAwO1xuICAgICAgICBkMiA9IE1hdGguZmxvb3IoZDIgLyAxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGMgPT0gXCJ4XCIgPyByIDogKHIgJiAweDcpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHV1aWQ7XG4gIH1cbiAgXG4gIHJldHVybiB7Z2V0Q29tbW9uUGFyYW1zLCBnZXRDb21tb25QYXJhbXNFeHRlbmQsIGdlbmVyYXRlU29ja2V0Q2xpZW50LCBHZW5lcmF0ZVVVSUR9O1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/socket-client/src/common-fun.js\n')},"./node_modules/@cocreate/socket-client/src/index.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n(function (root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./common-fun.js */ \"./node_modules/@cocreate/socket-client/src/common-fun.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(commonFunc) {\n        \treturn factory(commonFunc, window, WebSocket, Blob)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== 'undefined' ? self : this, function (commonFunc, wnd, WebSocket, Blob) {\n\n    class CoCreateSocketClient\n\t{\n\t\tconstructor(prefix = \"crud\") {\n\t\t\tthis.prefix = prefix || \"crud\";\n\t\t\tthis.sockets = new Map();\n\t\t\tthis.listeners = new Map();\n\t\t\tthis.messageQueue =  new Map();\n\t\t\tthis.saveFileName =  '';\n\t\t\tthis.globalScope =  \"\";\n\t\t}\n\t\n\t\tsetGlobalScope(scope) {\n\t\t\tthis.globalScope = `${this.prefix}/${scope}`;\n\t\t}\n\t\t\n\t\tgetGlobalScope() {\n\t\t\treturn this.globalScope;\n\t\t}\n\t\t\n\t\t/**\n\t\t * config: {namespace, room, host}\n\t\t */\n\t\tcreate (config) {\n\t\t\t\n\t\t\tconst {namespace, room} = config;\n\t\t\tconst key = this.getKey(namespace, room);\n\t\t\tlet _this = this;\n\t\t\tif (namespace) {\n\t\t\t\tthis.setGlobalScope(namespace)\n\t\t\t}\n\t\t\t\n\t\t\tlet socket;\n\t\t\tif (this.sockets.get(key)) {\n\t\t\t\tsocket = this.sockets.get(key);\n\t\t\t\tconsole.log('SOcket already has been register');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlet w_protocol = wnd.location.protocol;\t\t\n\t\t\tif (wnd.location.protocol === \"about:\") {\n\t\t\t\tw_protocol = wnd.parent.location.protocol;\n\t\t\t\tif (!config.host) {\n\t\t\t\t\tconfig.host = wnd.parent.location.host;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet protocol = w_protocol === 'http:' ? 'ws' : 'wss';\n\t\t\t\n\t\t\tconst port = config.port ? config.port : 8088;\n\t\t\t\n\t\t\tlet socket_url = `${protocol}://${wnd.location.host}:${port}/${key}`;\n\t\t\t\n\t\t\tif (config.host) {\n\t\t\t\tif (config.host.includes(\"://\")) {\n\t\t\t\t\tsocket_url = `${config.host}/${key}`;\n\t\t\t\t} else {\n\t\t\t\t\tif (config.host.includes(\":\")) {\n\t\t\t\t\t\tsocket_url = `${protocol}://${config.host}/${key}`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsocket_url = `${protocol}://${config.host}:${port}/${key}`;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsocket = new WebSocket(socket_url);\n\t\t\t} catch(error) {\n\t\t\t\tconsole.log(error)\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsocket.onopen = function(event) {\n\t\t\t\tconst messages = _this.messageQueue.get(key) || [];\n\t\t\t\tmessages.forEach(msg => socket.send(JSON.stringify(msg)));\n\t\t\t\t\n\t\t\t\t_this.sockets.set(key, socket);\n\t\t\t\t_this.messageQueue.set(key, []);\n\t\t\t}\n\t\t\t\n\t\t\tsocket.onclose = function(event) {\n\t\t\t\tswitch(event.code) {\n\t\t\t\t\tcase 1000: // close normal\n\t\t\t\t\t\tconsole.log(\"websocket: closed\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: \n\t\t\t\t\t\t_this.destroy(socket, key);\n\t\t\t\t\t\t_this.reconnect(socket, config);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsocket.onerror = function(err) {\n\t\t\t\t_this.destroy(socket, key);\n\t\t\t\t_this.reconnect(socket, config);\n\t\t\t}\n\t\n\t\t\tsocket.onmessage = function(data) {\n\t\t\t\ttry {\n\t\t\t\t\tif (wnd.Blob) {\n\t\t\t\t\t\tif (data.data instanceof Blob) {\n\t\t\t\t\t\t\t_this.saveFile(data.data);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet rev_data = JSON.parse(data.data);\n\n\t\t\t\t\tif (rev_data.data.event) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (wnd.CustomEvent) {\n\t\t\t\t\t\t\tvar event = new wnd.CustomEvent(rev_data.data.event, {\n\t\t\t\t\t\t\t\tdetail: rev_data.data\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\twnd.document.dispatchEvent(event);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprocess.emit(rev_data.data.event, rev_data.data)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tlet action = rev_data.action;\n\t\t\t\t\tconst listeners = _this.listeners.get(rev_data.action);\n\t\t\t\t\tif (!listeners) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlisteners.forEach(listener => {\n\t\t\t\t\t\tlistener(rev_data.data, key);\n\t\t\t\t\t})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * \n\t\t */\n\t\tsend (action, data, room) {\n\t\t\tconst obj = {\n\t\t\t\taction: action,\n\t\t\t\tdata: {...data, uid: commonFunc.GenerateUUID()}\n\t\t\t}\n\t\t\tconst key = this.getKeyByRoom(room);\n\t\t\tconst socket = this.getByRoom(room);\n\n\t\t\tif (socket) {\n\t\t\t\tsocket.send(JSON.stringify(obj));\n\t\t\t} else {\n\t\t\t\tif (this.messageQueue.get(key)) {\n\t\t\t\t\tthis.messageQueue.get(key).push(obj);\n\t\t\t\t} else {\n\t\t\t\t\tthis.messageQueue.set(key, [obj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsendFile (file, room) {\n\t\t\tconst socket = this.getByRoom(room);\n\t\t\tif (socket) {\n\t\t\t\tsocket.send(file);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t\t * scope: ns/room\n\t\t */\n\t\tlisten(type, callback) {\n\t\t\tif (!this.listeners.get(type)) {\n\t\t\t\tthis.listeners.set(type, [callback]);\n\t\t\t} else {\n\t\t\t\tthis.listeners.get(type).push(callback);\n\t\t\t}\n\t\t}\n\t\t\n\t\treconnect(socket, config) {\n\t\t\tlet _this = this;\n\t\t\tsetTimeout(function() {\n\t\t\t\t_this.create(config);\n\t\t\t}, 1000)\n\t\t}\n\t\t\n\t\tdestroy(socket, key) {\n\t\t\tif (socket) {\n\t\t\t\tsocket.onerror = socket.onopen = socket.onclose = null;\n\t\t\t\tsocket.close();\n\t\t\t\tsocket = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.sockets.get(key)) {\n\t\t\t\tthis.sockets.delete(key);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdestroyByKey(key) {\n\t\t\tlet socket = this.sockets.get(key) \n\t\t\tif (socket) {\n\t\t\t\tthis.destroy(socket, key);\n\t\t\t}\n\t\t}\n\t\t\n\t\tgetKey(namespace, room) {\n\t\t\tlet key = `${this.prefix}`;\n\t\t\tif (namespace && namespace != '') {\n\t\t\t\tif (room &&  room != '') {\n\t\t\t\t\tkey += `/${namespace}/${room}`;\n\t\t\t\t} else {\n\t\t\t\t\tkey +=`/${namespace}`;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn key;\n\t\t}\n\t\t\n\t\tgetByRoom(room) {\n\t\t\tlet key = this.getKeyByRoom(room)\n\t\t\treturn this.sockets.get(key);\t\n\t\t}\n\t\t\n\t\tgetKeyByRoom(room) {\n\t\t\tlet key = this.globalScope;\n\t\t\tif (room) {\n\t\t\t\tkey = `${this.prefix}/${room}`;\n\t\t\t}\n\t\t\treturn key;\t\t\n\t\t}\n\t\t\n\t\t\n\t\tsaveFile(blob) {\n\t\t\tif (wnd.document) {\n\t\t\t\tconst file_name = this.saveFileName || 'downloadFile';\n\t\t\t\tvar a = wnd.document.createElement(\"a\");\n\t\t        wnd.document.body.appendChild(a);\n\t\t        a.style = \"display: none\";\n\t\t\n\t\t        let url = window.URL.createObjectURL(blob);\n\t\t        a.href = url;\n\t\t        a.download = file_name;\n\t\t        a.click();\n\t\t        wnd.URL.revokeObjectURL(url);\n\t\t\n\t\t        this.saveFileName = ''\n\t\t\t}\n\t\t}\n\t\t\n\t\tlistenAsync(eventname) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tif (wnd.document) { //. browser case\n\t\t\t\t\twnd.document.addEventListener(eventname, function(event) {\n\t\t\t\t\t    resolve(event.detail);\n\t\t\t\t\t}, { once: true })\n\t\t\t\t} else { //. node case\n\t\t\t\t\tprocess.once(eventname, (data) => {\n\t\t\t\t\t\tresolve(data)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n    return CoCreateSocketClient\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvc29ja2V0LWNsaWVudC9zcmMvaW5kZXguanM/YTkwOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRDtBQUNBLFFBQVEsaUNBQU8sQ0FBQyxzR0FBaUIsQ0FBQyxtQ0FBRTtBQUNwQztBQUNBLFNBQVM7QUFBQSxrR0FBQztBQUNWLEtBQUssTUFBTSxFQVlSO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixZQUFZLEdBQUcsTUFBTTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTLEtBQUssa0JBQWtCLEdBQUcsS0FBSyxHQUFHLElBQUk7O0FBRXRFO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxHQUFHLElBQUk7QUFDeEMsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLFNBQVMsS0FBSyxZQUFZLEdBQUcsSUFBSTtBQUN2RCxNQUFNO0FBQ04sc0JBQXNCLFNBQVMsS0FBSyxZQUFZLEdBQUcsS0FBSyxHQUFHLElBQUksRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEdBQUcsS0FBSztBQUNsQyxLQUFLO0FBQ0wsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWSxHQUFHLEtBQUs7QUFDakM7QUFDQSxjO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxNQUFNLEdBQUcsYUFBYTtBQUN0QixLQUFLLE9BQU87QUFDWjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL3NvY2tldC1jbGllbnQvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoWycuL2NvbW1vbi1mdW4uanMnXSwgZnVuY3Rpb24oY29tbW9uRnVuYykge1xuICAgICAgICBcdHJldHVybiBmYWN0b3J5KGNvbW1vbkZ1bmMsIHdpbmRvdywgV2ViU29ja2V0LCBCbG9iKVxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIGxldCB3bmRPYmogPSB7XG4gICAgICAgIFx0bG9jYXRpb246IHtcbiAgICAgICAgXHRcdHByb3RvY29sOiBcIlwiXG4gICAgICAgIFx0fVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdzID0gcmVxdWlyZShcIndzXCIpXG4gICAgICAgIGNvbnN0IGNvbW1vbkZ1bmMgPSByZXF1aXJlKFwiLi9jb21tb24tZnVuLmpzXCIpXG4gICAgXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoY29tbW9uRnVuYywgd25kT2JqLCB3cywgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeShyb290W1wiLi9jb21tb24tZnVuLmpzXCJdLCB3aW5kb3csIFdlYlNvY2tldCwgQmxvYik7XG4gIH1cbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uIChjb21tb25GdW5jLCB3bmQsIFdlYlNvY2tldCwgQmxvYikge1xuXG4gICAgY2xhc3MgQ29DcmVhdGVTb2NrZXRDbGllbnRcblx0e1xuXHRcdGNvbnN0cnVjdG9yKHByZWZpeCA9IFwiY3J1ZFwiKSB7XG5cdFx0XHR0aGlzLnByZWZpeCA9IHByZWZpeCB8fCBcImNydWRcIjtcblx0XHRcdHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMubGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXHRcdFx0dGhpcy5tZXNzYWdlUXVldWUgPSAgbmV3IE1hcCgpO1xuXHRcdFx0dGhpcy5zYXZlRmlsZU5hbWUgPSAgJyc7XG5cdFx0XHR0aGlzLmdsb2JhbFNjb3BlID0gIFwiXCI7XG5cdFx0fVxuXHRcblx0XHRzZXRHbG9iYWxTY29wZShzY29wZSkge1xuXHRcdFx0dGhpcy5nbG9iYWxTY29wZSA9IGAke3RoaXMucHJlZml4fS8ke3Njb3BlfWA7XG5cdFx0fVxuXHRcdFxuXHRcdGdldEdsb2JhbFNjb3BlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2xvYmFsU2NvcGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIGNvbmZpZzoge25hbWVzcGFjZSwgcm9vbSwgaG9zdH1cblx0XHQgKi9cblx0XHRjcmVhdGUgKGNvbmZpZykge1xuXHRcdFx0XG5cdFx0XHRjb25zdCB7bmFtZXNwYWNlLCByb29tfSA9IGNvbmZpZztcblx0XHRcdGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KG5hbWVzcGFjZSwgcm9vbSk7XG5cdFx0XHRsZXQgX3RoaXMgPSB0aGlzO1xuXHRcdFx0aWYgKG5hbWVzcGFjZSkge1xuXHRcdFx0XHR0aGlzLnNldEdsb2JhbFNjb3BlKG5hbWVzcGFjZSlcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bGV0IHNvY2tldDtcblx0XHRcdGlmICh0aGlzLnNvY2tldHMuZ2V0KGtleSkpIHtcblx0XHRcdFx0c29ja2V0ID0gdGhpcy5zb2NrZXRzLmdldChrZXkpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU09ja2V0IGFscmVhZHkgaGFzIGJlZW4gcmVnaXN0ZXInKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRsZXQgd19wcm90b2NvbCA9IHduZC5sb2NhdGlvbi5wcm90b2NvbDtcdFx0XG5cdFx0XHRpZiAod25kLmxvY2F0aW9uLnByb3RvY29sID09PSBcImFib3V0OlwiKSB7XG5cdFx0XHRcdHdfcHJvdG9jb2wgPSB3bmQucGFyZW50LmxvY2F0aW9uLnByb3RvY29sO1xuXHRcdFx0XHRpZiAoIWNvbmZpZy5ob3N0KSB7XG5cdFx0XHRcdFx0Y29uZmlnLmhvc3QgPSB3bmQucGFyZW50LmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxldCBwcm90b2NvbCA9IHdfcHJvdG9jb2wgPT09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBvcnQgPSBjb25maWcucG9ydCA/IGNvbmZpZy5wb3J0IDogODA4ODtcblx0XHRcdFxuXHRcdFx0bGV0IHNvY2tldF91cmwgPSBgJHtwcm90b2NvbH06Ly8ke3duZC5sb2NhdGlvbi5ob3N0fToke3BvcnR9LyR7a2V5fWA7XG5cdFx0XHRcblx0XHRcdGlmIChjb25maWcuaG9zdCkge1xuXHRcdFx0XHRpZiAoY29uZmlnLmhvc3QuaW5jbHVkZXMoXCI6Ly9cIikpIHtcblx0XHRcdFx0XHRzb2NrZXRfdXJsID0gYCR7Y29uZmlnLmhvc3R9LyR7a2V5fWA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5ob3N0LmluY2x1ZGVzKFwiOlwiKSkge1xuXHRcdFx0XHRcdFx0c29ja2V0X3VybCA9IGAke3Byb3RvY29sfTovLyR7Y29uZmlnLmhvc3R9LyR7a2V5fWA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNvY2tldF91cmwgPSBgJHtwcm90b2NvbH06Ly8ke2NvbmZpZy5ob3N0fToke3BvcnR9LyR7a2V5fWA7XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNvY2tldCA9IG5ldyBXZWJTb2NrZXQoc29ja2V0X3VybCk7XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGVycm9yKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRjb25zdCBtZXNzYWdlcyA9IF90aGlzLm1lc3NhZ2VRdWV1ZS5nZXQoa2V5KSB8fCBbXTtcblx0XHRcdFx0bWVzc2FnZXMuZm9yRWFjaChtc2cgPT4gc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobXNnKSkpO1xuXHRcdFx0XHRcblx0XHRcdFx0X3RoaXMuc29ja2V0cy5zZXQoa2V5LCBzb2NrZXQpO1xuXHRcdFx0XHRfdGhpcy5tZXNzYWdlUXVldWUuc2V0KGtleSwgW10pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHN3aXRjaChldmVudC5jb2RlKSB7XG5cdFx0XHRcdFx0Y2FzZSAxMDAwOiAvLyBjbG9zZSBub3JtYWxcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwid2Vic29ja2V0OiBjbG9zZWRcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OiBcblx0XHRcdFx0XHRcdF90aGlzLmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuXHRcdFx0XHRcdFx0X3RoaXMucmVjb25uZWN0KHNvY2tldCwgY29uZmlnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdF90aGlzLmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuXHRcdFx0XHRfdGhpcy5yZWNvbm5lY3Qoc29ja2V0LCBjb25maWcpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKHduZC5CbG9iKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGF0YS5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5zYXZlRmlsZShkYXRhLmRhdGEpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCByZXZfZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5kYXRhKTtcblxuXHRcdFx0XHRcdGlmIChyZXZfZGF0YS5kYXRhLmV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICh3bmQuQ3VzdG9tRXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IHduZC5DdXN0b21FdmVudChyZXZfZGF0YS5kYXRhLmV2ZW50LCB7XG5cdFx0XHRcdFx0XHRcdFx0ZGV0YWlsOiByZXZfZGF0YS5kYXRhXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdHduZC5kb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lbWl0KHJldl9kYXRhLmRhdGEuZXZlbnQsIHJldl9kYXRhLmRhdGEpXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgYWN0aW9uID0gcmV2X2RhdGEuYWN0aW9uO1xuXHRcdFx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IF90aGlzLmxpc3RlbmVycy5nZXQocmV2X2RhdGEuYWN0aW9uKTtcblx0XHRcdFx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lcihyZXZfZGF0YS5kYXRhLCBrZXkpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRzZW5kIChhY3Rpb24sIGRhdGEsIHJvb20pIHtcblx0XHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdFx0YWN0aW9uOiBhY3Rpb24sXG5cdFx0XHRcdGRhdGE6IHsuLi5kYXRhLCB1aWQ6IGNvbW1vbkZ1bmMuR2VuZXJhdGVVVUlEKCl9XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBrZXkgPSB0aGlzLmdldEtleUJ5Um9vbShyb29tKTtcblx0XHRcdGNvbnN0IHNvY2tldCA9IHRoaXMuZ2V0QnlSb29tKHJvb20pO1xuXG5cdFx0XHRpZiAoc29ja2V0KSB7XG5cdFx0XHRcdHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMubWVzc2FnZVF1ZXVlLmdldChrZXkpKSB7XG5cdFx0XHRcdFx0dGhpcy5tZXNzYWdlUXVldWUuZ2V0KGtleSkucHVzaChvYmopO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubWVzc2FnZVF1ZXVlLnNldChrZXksIFtvYmpdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRzZW5kRmlsZSAoZmlsZSwgcm9vbSkge1xuXHRcdFx0Y29uc3Qgc29ja2V0ID0gdGhpcy5nZXRCeVJvb20ocm9vbSk7XG5cdFx0XHRpZiAoc29ja2V0KSB7XG5cdFx0XHRcdHNvY2tldC5zZW5kKGZpbGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyoqXG5cdFx0ICogc2NvcGU6IG5zL3Jvb21cblx0XHQgKi9cblx0XHRsaXN0ZW4odHlwZSwgY2FsbGJhY2spIHtcblx0XHRcdGlmICghdGhpcy5saXN0ZW5lcnMuZ2V0KHR5cGUpKSB7XG5cdFx0XHRcdHRoaXMubGlzdGVuZXJzLnNldCh0eXBlLCBbY2FsbGJhY2tdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubGlzdGVuZXJzLmdldCh0eXBlKS5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmVjb25uZWN0KHNvY2tldCwgY29uZmlnKSB7XG5cdFx0XHRsZXQgX3RoaXMgPSB0aGlzO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0X3RoaXMuY3JlYXRlKGNvbmZpZyk7XG5cdFx0XHR9LCAxMDAwKVxuXHRcdH1cblx0XHRcblx0XHRkZXN0cm95KHNvY2tldCwga2V5KSB7XG5cdFx0XHRpZiAoc29ja2V0KSB7XG5cdFx0XHRcdHNvY2tldC5vbmVycm9yID0gc29ja2V0Lm9ub3BlbiA9IHNvY2tldC5vbmNsb3NlID0gbnVsbDtcblx0XHRcdFx0c29ja2V0LmNsb3NlKCk7XG5cdFx0XHRcdHNvY2tldCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnNvY2tldHMuZ2V0KGtleSkpIHtcblx0XHRcdFx0dGhpcy5zb2NrZXRzLmRlbGV0ZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRkZXN0cm95QnlLZXkoa2V5KSB7XG5cdFx0XHRsZXQgc29ja2V0ID0gdGhpcy5zb2NrZXRzLmdldChrZXkpIFxuXHRcdFx0aWYgKHNvY2tldCkge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRnZXRLZXkobmFtZXNwYWNlLCByb29tKSB7XG5cdFx0XHRsZXQga2V5ID0gYCR7dGhpcy5wcmVmaXh9YDtcblx0XHRcdGlmIChuYW1lc3BhY2UgJiYgbmFtZXNwYWNlICE9ICcnKSB7XG5cdFx0XHRcdGlmIChyb29tICYmICByb29tICE9ICcnKSB7XG5cdFx0XHRcdFx0a2V5ICs9IGAvJHtuYW1lc3BhY2V9LyR7cm9vbX1gO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGtleSArPWAvJHtuYW1lc3BhY2V9YDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9XG5cdFx0XG5cdFx0Z2V0QnlSb29tKHJvb20pIHtcblx0XHRcdGxldCBrZXkgPSB0aGlzLmdldEtleUJ5Um9vbShyb29tKVxuXHRcdFx0cmV0dXJuIHRoaXMuc29ja2V0cy5nZXQoa2V5KTtcdFxuXHRcdH1cblx0XHRcblx0XHRnZXRLZXlCeVJvb20ocm9vbSkge1xuXHRcdFx0bGV0IGtleSA9IHRoaXMuZ2xvYmFsU2NvcGU7XG5cdFx0XHRpZiAocm9vbSkge1xuXHRcdFx0XHRrZXkgPSBgJHt0aGlzLnByZWZpeH0vJHtyb29tfWA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ga2V5O1x0XHRcblx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0c2F2ZUZpbGUoYmxvYikge1xuXHRcdFx0aWYgKHduZC5kb2N1bWVudCkge1xuXHRcdFx0XHRjb25zdCBmaWxlX25hbWUgPSB0aGlzLnNhdmVGaWxlTmFtZSB8fCAnZG93bmxvYWRGaWxlJztcblx0XHRcdFx0dmFyIGEgPSB3bmQuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0ICAgICAgICB3bmQuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcblx0XHQgICAgICAgIGEuc3R5bGUgPSBcImRpc3BsYXk6IG5vbmVcIjtcblx0XHRcblx0XHQgICAgICAgIGxldCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0XHQgICAgICAgIGEuaHJlZiA9IHVybDtcblx0XHQgICAgICAgIGEuZG93bmxvYWQgPSBmaWxlX25hbWU7XG5cdFx0ICAgICAgICBhLmNsaWNrKCk7XG5cdFx0ICAgICAgICB3bmQuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuXHRcdFxuXHRcdCAgICAgICAgdGhpcy5zYXZlRmlsZU5hbWUgPSAnJ1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRsaXN0ZW5Bc3luYyhldmVudG5hbWUpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRcdGlmICh3bmQuZG9jdW1lbnQpIHsgLy8uIGJyb3dzZXIgY2FzZVxuXHRcdFx0XHRcdHduZC5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50bmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHQgICAgcmVzb2x2ZShldmVudC5kZXRhaWwpO1xuXHRcdFx0XHRcdH0sIHsgb25jZTogdHJ1ZSB9KVxuXHRcdFx0XHR9IGVsc2UgeyAvLy4gbm9kZSBjYXNlXG5cdFx0XHRcdFx0cHJvY2Vzcy5vbmNlKGV2ZW50bmFtZSwgKGRhdGEpID0+IHtcblx0XHRcdFx0XHRcdHJlc29sdmUoZGF0YSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuICAgIHJldHVybiBDb0NyZWF0ZVNvY2tldENsaWVudFxufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/socket-client/src/index.js\n")},"./node_modules/@cocreate/utils/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "generateUUID": () => (/* binding */ generateUUID),\n/* harmony export */   "getParentFromElement": () => (/* binding */ getParentFromElement),\n/* harmony export */   "isJsonString": () => (/* binding */ isJsonString),\n/* harmony export */   "getAttributes": () => (/* binding */ getAttributes),\n/* harmony export */   "checkValue": () => (/* binding */ checkValue),\n/* harmony export */   "allFrame": () => (/* binding */ allFrame),\n/* harmony export */   "cssPath": () => (/* binding */ cssPath),\n/* harmony export */   "getTopMostWindow": () => (/* binding */ getTopMostWindow),\n/* harmony export */   "findIframeFromElement": () => (/* binding */ findIframeFromElement),\n/* harmony export */   "getIframeFromPath": () => (/* binding */ getIframeFromPath),\n/* harmony export */   "configMatch": () => (/* binding */ configMatch),\n/* harmony export */   "configExecuter": () => (/* binding */ configExecuter),\n/* harmony export */   "UUID": () => (/* binding */ UUID),\n/* harmony export */   "parseTextToHtml": () => (/* binding */ parseTextToHtml),\n/* harmony export */   "splitBydelimiter": () => (/* binding */ splitBydelimiter),\n/* harmony export */   "joinBydelimiter": () => (/* binding */ joinBydelimiter),\n/* harmony export */   "isValidSelector": () => (/* binding */ isValidSelector),\n/* harmony export */   "getElementPath": () => (/* binding */ getElementPath),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Created by jin\n * 2020-04-03\n */\n\n\nfunction generateUUID(length = 36) {\n  // if (length == 10) {\n  //   var result           = \'\';\n  //   var characters       = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\';\n  //   var charactersLength = characters.length;\n  //   for ( var i = 0; i < length; i++ ) {\n  //     result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  //   }\n\n  //   var dd = new Date().toTimeString();\n  //   var random = dd.replace(/[\\W_]+/g, "").substr(0,6);\n  //   result += random;\n  //   return result;\n  // }\n\n  let d = new Date().getTime();\n  let d2 =\n    (window.performance &&\n      window.performance.now &&\n      window.performance.now() * 1000) ||\n    0;\n  let pattern = "uxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";\n\n  if (length <= pattern.length) {\n    pattern = pattern.substr(0, length);\n  }\n  else {\n    let add_len = length - pattern.length;\n    let sub_pattern = "-xxxyyxxx";\n\n    let group_n = Math.floor(add_len / sub_pattern.length);\n\n    for (let i = 0; i < group_n; i++) {\n      pattern += sub_pattern;\n    }\n\n    group_n = add_len - group_n * sub_pattern.length;\n    pattern += sub_pattern.substr(0, group_n);\n  }\n\n  let uuid = pattern.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16;\n    if (d > 0) {\n      var r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    }\n    else {\n      var r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c == "x" ? r : (r & 0x7) | 0x8).toString(16);\n  });\n  return uuid;\n}\n\nfunction getParentFromElement(element, parent_class, attributes) {\n  if (parent_class) {\n    if (element.classList.contains(parent_class)) {\n      return element;\n    }\n\n    let node = element.parentNode;\n    while (node != null && node.classList) {\n      if (node.classList.contains(parent_class)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n  }\n  else if (attributes) {\n    if (attributes.every((attr) => element.attributes.hasOwnProperty(attr))) {\n      return element;\n    }\n\n    let node = element.parentNode;\n    while (node != null && node.attributes) {\n      if (attributes.every((attr) => node.attributes.hasOwnProperty(attr))) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n  }\n\n  return false;\n}\n\n\nfunction isJsonString(str_data) {\n  try {\n    let json_data = JSON.parse(str_data);\n    if (typeof json_data === "object" && json_data != null) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n  catch (e) {\n    return false;\n  }\n}\n\nfunction getAttributes(element) {\n  return element.getAttributeNames().reduce((attrMap, name) => {\n    attrMap[name] = element.getAttribute(name);\n    return attrMap;\n  }, {});\n}\n\nfunction checkValue(value) {\n  if (!value) return false;\n  if (/{{\\s*([\\w\\W]+)\\s*}}/g.test(value)) {\n    return false;\n  }\n\n  return true;\n}\n// hosseins utills\n\n// function to go through all frames\nfunction allFrame(callback) {\n  let allFrames = [{ document, window }];\n  for (let frame of document.querySelectorAll("iframe")) {\n    let frameDocument = frame.contentDocument || frame.contentWindow.document;\n    let frameWindow = frame.contentWindow;\n    allFrames.push({\n      document: frameDocument,\n      window: frameWindow,\n      frameElement: frame,\n    });\n  }\n  let result = new Set();\n  for (let frame of allFrames) {\n    let callbackResult = callback(frame);\n    if (\n      callbackResult &&\n      typeof callbackResult[Symbol.iterator] === "function"\n    )\n      callbackResult.forEach((el) => result.add(el));\n    else if (callbackResult) result.add(callbackResult);\n  }\n\n  return Array.from(result);\n}\n\nfunction cssPath(node) {\n  let pathSplits = [];\n  do {\n    if (!node || !node.tagName) return false;\n    let pathSplit = node.tagName.toLowerCase();\n    if (node.id && node.tagName !== "BODY") pathSplit += "#" + node.id;\n\n    if (node.classList.length && node.tagName !== "BODY") {\n      node.classList.forEach((item) => {\n        if (item.indexOf(":") === -1) pathSplit += "." + item;\n      });\n    }\n\n    if (node.tagName !== "BODY" && node.parentNode) {\n      let index = Array.prototype.indexOf.call(\n        node.parentNode.children,\n        node\n      );\n      pathSplit += `:nth-child(${index + 1})`;\n    }\n\n    pathSplits.unshift(pathSplit);\n    node = node.parentNode;\n  } while (node.tagName !== "HTML");\n\n  return pathSplits.join(" > ");\n}\n\nfunction getTopMostWindow() {\n  let parentWindow = window;\n  while (parentWindow !== window.parent) parentWindow = window.parent;\n  return parentWindow;\n}\n\nfunction findIframeFromElement(windowObject, element) {\n  let frameElement;\n  allFrame((frame) => {\n    if (frame.document.contains(element)) frameElement = frame.frameElement;\n    // window.cc.findIframeFromElement(frame.window, element);\n  });\n  return frameElement;\n}\n\nfunction getIframeFromPath(path) {\n  let topWindow = getTopMostWindow;\n\n  path.forEach((selector) => {\n    if (topWindow) topWindow = topWindow.querySelector(selector);\n  });\n  return topWindow;\n}\n// DO NOT REMOVE\n\nfunction* configMatch(elementConfig, element) {\n  for (let config of elementConfig) {\n    // if (!Array.isArray(config.selector))\n    //   config.selector = [config.selector];\n\n    if (config.selector && element.matches(config.selector)) yield config;\n  }\n  return;\n}\n\n\n// export function configMatch2(elementConfig, element) {\n//   let result = [];\n//   for (let config of elementConfig) {\n//     if (config.selector && element.matches(config.selector)) result.push(config);\n//   }\n//   return result;\n// }\n\n// DO NOT REMOVE\n\n// an opiniated function uses configMatch2 to read configs\n// WARNING: the config iterated from top to bottom. for deseired effect elementConfig should be reveresed\n// typeof elementConfig: array of objects and every objects containing keys as false, true or a selector \n// element: the element to read attributes\n// key: the key in which is in elementConfig and on match onSuccess callback will be called\nfunction configExecuter(element, key, onSuccess, elementConfig) {\n  for (let config of configMatch(elementConfig || window.elementConfig, element))\n    if (config[key] === true) return onSuccess(element, config);\n    else if (config[key] === false) return false;\n  else if (config[key] === undefined) continue;\n  else if (isValidSelector(config[key]))\n    return onSuccess(element, config, true);\n  else console.warn("builder: wrong element config ", config);\n\n  return false;\n}\n\nfunction UUID(length = 10) {\n  var result = "";\n  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\n\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  var d = new Date().toTimeString();\n  var random = d.replace(/[\\W_]+/g, "").substr(0, 6);\n  result += random;\n  return result;\n}\n\nfunction parseTextToHtml(text) {\n  let doc = new DOMParser().parseFromString(text, "text/html");\n  if (doc.head.children[0]) return doc.head.children[0];\n  else return doc.body.children[0];\n}\n\nfunction splitBydelimiter(str, delimiter) {\n  return str.split(delimiter).map((s) => s.trim());\n}\n\nfunction joinBydelimiter(str, delimiter) {\n  return str.map((s) => s.trim()).join(delimiter);\n}\n\nfunction isValidSelector(selector) {\n  try {\n    document.createDocumentFragment().querySelector(selector);\n  }\n  catch (error) {\n    return false;\n  }\n  return true;\n}\n\nfunction getElementPath(element, returnContext) {\n  let path = [];\n\n  let topWindow = window;\n  let iframeElement = findIframeFromElement(topWindow, element);\n  let p = cssPath(iframeElement);\n  if (p) path.unshift(p);\n\n  return returnContext ? { path, document: iframeElement || document } : path;\n  //todo: support for nested iframe\n  // while(iframeElement !== findIframeFromElement(topWindow,iframeElement))\n  // {\n  //   iframeElement = findIframeFromElement(topWindow,iframeElement);\n  //   path.unshift(cssPath(iframeElement))\n  // }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  getElementPath,\n  isValidSelector,\n  joinBydelimiter,\n  splitBydelimiter,\n  parseTextToHtml,\n  UUID,\n  configExecuter,\n  configMatch,\n  getIframeFromPath,\n  findIframeFromElement,\n  getTopMostWindow,\n  cssPath,\n  allFrame,\n  checkValue,\n  getAttributes,\n  isJsonString,\n  getParentFromElement,\n  generateUUID\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvdXRpbHMvc3JjL2luZGV4LmpzPzZiMTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRU87QUFDUDtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsNENBQTRDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL3V0aWxzL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlZCBieSBqaW5cbiAqIDIwMjAtMDQtMDNcbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQobGVuZ3RoID0gMzYpIHtcbiAgLy8gaWYgKGxlbmd0aCA9PSAxMCkge1xuICAvLyAgIHZhciByZXN1bHQgICAgICAgICAgID0gJyc7XG4gIC8vICAgdmFyIGNoYXJhY3RlcnMgICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAvLyAgIHZhciBjaGFyYWN0ZXJzTGVuZ3RoID0gY2hhcmFjdGVycy5sZW5ndGg7XG4gIC8vICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gIC8vICAgICByZXN1bHQgKz0gY2hhcmFjdGVycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcmFjdGVyc0xlbmd0aCkpO1xuICAvLyAgIH1cblxuICAvLyAgIHZhciBkZCA9IG5ldyBEYXRlKCkudG9UaW1lU3RyaW5nKCk7XG4gIC8vICAgdmFyIHJhbmRvbSA9IGRkLnJlcGxhY2UoL1tcXFdfXSsvZywgXCJcIikuc3Vic3RyKDAsNik7XG4gIC8vICAgcmVzdWx0ICs9IHJhbmRvbTtcbiAgLy8gICByZXR1cm4gcmVzdWx0O1xuICAvLyB9XG5cbiAgbGV0IGQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgbGV0IGQyID1cbiAgICAod2luZG93LnBlcmZvcm1hbmNlICYmXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ICYmXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgKiAxMDAwKSB8fFxuICAgIDA7XG4gIGxldCBwYXR0ZXJuID0gXCJ1eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIjtcblxuICBpZiAobGVuZ3RoIDw9IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyKDAsIGxlbmd0aCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGV0IGFkZF9sZW4gPSBsZW5ndGggLSBwYXR0ZXJuLmxlbmd0aDtcbiAgICBsZXQgc3ViX3BhdHRlcm4gPSBcIi14eHh5eXh4eFwiO1xuXG4gICAgbGV0IGdyb3VwX24gPSBNYXRoLmZsb29yKGFkZF9sZW4gLyBzdWJfcGF0dGVybi5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cF9uOyBpKyspIHtcbiAgICAgIHBhdHRlcm4gKz0gc3ViX3BhdHRlcm47XG4gICAgfVxuXG4gICAgZ3JvdXBfbiA9IGFkZF9sZW4gLSBncm91cF9uICogc3ViX3BhdHRlcm4ubGVuZ3RoO1xuICAgIHBhdHRlcm4gKz0gc3ViX3BhdHRlcm4uc3Vic3RyKDAsIGdyb3VwX24pO1xuICB9XG5cbiAgbGV0IHV1aWQgPSBwYXR0ZXJuLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2O1xuICAgIGlmIChkID4gMCkge1xuICAgICAgdmFyIHIgPSAoZCArIHIpICUgMTYgfCAwO1xuICAgICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgciA9IChkMiArIHIpICUgMTYgfCAwO1xuICAgICAgZDIgPSBNYXRoLmZsb29yKGQyIC8gMTYpO1xuICAgIH1cbiAgICByZXR1cm4gKGMgPT0gXCJ4XCIgPyByIDogKHIgJiAweDcpIHwgMHg4KS50b1N0cmluZygxNik7XG4gIH0pO1xuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQsIHBhcmVudF9jbGFzcywgYXR0cmlidXRlcykge1xuICBpZiAocGFyZW50X2NsYXNzKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHBhcmVudF9jbGFzcykpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGxldCBub2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgbm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhwYXJlbnRfY2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYXR0cmlidXRlcykge1xuICAgIGlmIChhdHRyaWJ1dGVzLmV2ZXJ5KChhdHRyKSA9PiBlbGVtZW50LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAobm9kZSAhPSBudWxsICYmIG5vZGUuYXR0cmlidXRlcykge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMuZXZlcnkoKGF0dHIpID0+IG5vZGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNKc29uU3RyaW5nKHN0cl9kYXRhKSB7XG4gIHRyeSB7XG4gICAgbGV0IGpzb25fZGF0YSA9IEpTT04ucGFyc2Uoc3RyX2RhdGEpO1xuICAgIGlmICh0eXBlb2YganNvbl9kYXRhID09PSBcIm9iamVjdFwiICYmIGpzb25fZGF0YSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlTmFtZXMoKS5yZWR1Y2UoKGF0dHJNYXAsIG5hbWUpID0+IHtcbiAgICBhdHRyTWFwW25hbWVdID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIGF0dHJNYXA7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoL3t7XFxzKihbXFx3XFxXXSspXFxzKn19L2cudGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8vIGhvc3NlaW5zIHV0aWxsc1xuXG4vLyBmdW5jdGlvbiB0byBnbyB0aHJvdWdoIGFsbCBmcmFtZXNcbmV4cG9ydCBmdW5jdGlvbiBhbGxGcmFtZShjYWxsYmFjaykge1xuICBsZXQgYWxsRnJhbWVzID0gW3sgZG9jdW1lbnQsIHdpbmRvdyB9XTtcbiAgZm9yIChsZXQgZnJhbWUgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlmcmFtZVwiKSkge1xuICAgIGxldCBmcmFtZURvY3VtZW50ID0gZnJhbWUuY29udGVudERvY3VtZW50IHx8IGZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgbGV0IGZyYW1lV2luZG93ID0gZnJhbWUuY29udGVudFdpbmRvdztcbiAgICBhbGxGcmFtZXMucHVzaCh7XG4gICAgICBkb2N1bWVudDogZnJhbWVEb2N1bWVudCxcbiAgICAgIHdpbmRvdzogZnJhbWVXaW5kb3csXG4gICAgICBmcmFtZUVsZW1lbnQ6IGZyYW1lLFxuICAgIH0pO1xuICB9XG4gIGxldCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gIGZvciAobGV0IGZyYW1lIG9mIGFsbEZyYW1lcykge1xuICAgIGxldCBjYWxsYmFja1Jlc3VsdCA9IGNhbGxiYWNrKGZyYW1lKTtcbiAgICBpZiAoXG4gICAgICBjYWxsYmFja1Jlc3VsdCAmJlxuICAgICAgdHlwZW9mIGNhbGxiYWNrUmVzdWx0W1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIlxuICAgIClcbiAgICAgIGNhbGxiYWNrUmVzdWx0LmZvckVhY2goKGVsKSA9PiByZXN1bHQuYWRkKGVsKSk7XG4gICAgZWxzZSBpZiAoY2FsbGJhY2tSZXN1bHQpIHJlc3VsdC5hZGQoY2FsbGJhY2tSZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc1BhdGgobm9kZSkge1xuICBsZXQgcGF0aFNwbGl0cyA9IFtdO1xuICBkbyB7XG4gICAgaWYgKCFub2RlIHx8ICFub2RlLnRhZ05hbWUpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGF0aFNwbGl0ID0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG5vZGUuaWQgJiYgbm9kZS50YWdOYW1lICE9PSBcIkJPRFlcIikgcGF0aFNwbGl0ICs9IFwiI1wiICsgbm9kZS5pZDtcblxuICAgIGlmIChub2RlLmNsYXNzTGlzdC5sZW5ndGggJiYgbm9kZS50YWdOYW1lICE9PSBcIkJPRFlcIikge1xuICAgICAgbm9kZS5jbGFzc0xpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHBhdGhTcGxpdCArPSBcIi5cIiArIGl0ZW07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWdOYW1lICE9PSBcIkJPRFlcIiAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIGxldCBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoXG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5jaGlsZHJlbixcbiAgICAgICAgbm9kZVxuICAgICAgKTtcbiAgICAgIHBhdGhTcGxpdCArPSBgOm50aC1jaGlsZCgke2luZGV4ICsgMX0pYDtcbiAgICB9XG5cbiAgICBwYXRoU3BsaXRzLnVuc2hpZnQocGF0aFNwbGl0KTtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9IHdoaWxlIChub2RlLnRhZ05hbWUgIT09IFwiSFRNTFwiKTtcblxuICByZXR1cm4gcGF0aFNwbGl0cy5qb2luKFwiID4gXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wTW9zdFdpbmRvdygpIHtcbiAgbGV0IHBhcmVudFdpbmRvdyA9IHdpbmRvdztcbiAgd2hpbGUgKHBhcmVudFdpbmRvdyAhPT0gd2luZG93LnBhcmVudCkgcGFyZW50V2luZG93ID0gd2luZG93LnBhcmVudDtcbiAgcmV0dXJuIHBhcmVudFdpbmRvdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJZnJhbWVGcm9tRWxlbWVudCh3aW5kb3dPYmplY3QsIGVsZW1lbnQpIHtcbiAgbGV0IGZyYW1lRWxlbWVudDtcbiAgYWxsRnJhbWUoKGZyYW1lKSA9PiB7XG4gICAgaWYgKGZyYW1lLmRvY3VtZW50LmNvbnRhaW5zKGVsZW1lbnQpKSBmcmFtZUVsZW1lbnQgPSBmcmFtZS5mcmFtZUVsZW1lbnQ7XG4gICAgLy8gd2luZG93LmNjLmZpbmRJZnJhbWVGcm9tRWxlbWVudChmcmFtZS53aW5kb3csIGVsZW1lbnQpO1xuICB9KTtcbiAgcmV0dXJuIGZyYW1lRWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldElmcmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHRvcFdpbmRvdyA9IGdldFRvcE1vc3RXaW5kb3c7XG5cbiAgcGF0aC5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgIGlmICh0b3BXaW5kb3cpIHRvcFdpbmRvdyA9IHRvcFdpbmRvdy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfSk7XG4gIHJldHVybiB0b3BXaW5kb3c7XG59XG4vLyBETyBOT1QgUkVNT1ZFXG5cbmV4cG9ydCBmdW5jdGlvbiogY29uZmlnTWF0Y2goZWxlbWVudENvbmZpZywgZWxlbWVudCkge1xuICBmb3IgKGxldCBjb25maWcgb2YgZWxlbWVudENvbmZpZykge1xuICAgIC8vIGlmICghQXJyYXkuaXNBcnJheShjb25maWcuc2VsZWN0b3IpKVxuICAgIC8vICAgY29uZmlnLnNlbGVjdG9yID0gW2NvbmZpZy5zZWxlY3Rvcl07XG5cbiAgICBpZiAoY29uZmlnLnNlbGVjdG9yICYmIGVsZW1lbnQubWF0Y2hlcyhjb25maWcuc2VsZWN0b3IpKSB5aWVsZCBjb25maWc7XG4gIH1cbiAgcmV0dXJuO1xufVxuXG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBjb25maWdNYXRjaDIoZWxlbWVudENvbmZpZywgZWxlbWVudCkge1xuLy8gICBsZXQgcmVzdWx0ID0gW107XG4vLyAgIGZvciAobGV0IGNvbmZpZyBvZiBlbGVtZW50Q29uZmlnKSB7XG4vLyAgICAgaWYgKGNvbmZpZy5zZWxlY3RvciAmJiBlbGVtZW50Lm1hdGNoZXMoY29uZmlnLnNlbGVjdG9yKSkgcmVzdWx0LnB1c2goY29uZmlnKTtcbi8vICAgfVxuLy8gICByZXR1cm4gcmVzdWx0O1xuLy8gfVxuXG4vLyBETyBOT1QgUkVNT1ZFXG5cbi8vIGFuIG9waW5pYXRlZCBmdW5jdGlvbiB1c2VzIGNvbmZpZ01hdGNoMiB0byByZWFkIGNvbmZpZ3Ncbi8vIFdBUk5JTkc6IHRoZSBjb25maWcgaXRlcmF0ZWQgZnJvbSB0b3AgdG8gYm90dG9tLiBmb3IgZGVzZWlyZWQgZWZmZWN0IGVsZW1lbnRDb25maWcgc2hvdWxkIGJlIHJldmVyZXNlZFxuLy8gdHlwZW9mIGVsZW1lbnRDb25maWc6IGFycmF5IG9mIG9iamVjdHMgYW5kIGV2ZXJ5IG9iamVjdHMgY29udGFpbmluZyBrZXlzIGFzIGZhbHNlLCB0cnVlIG9yIGEgc2VsZWN0b3IgXG4vLyBlbGVtZW50OiB0aGUgZWxlbWVudCB0byByZWFkIGF0dHJpYnV0ZXNcbi8vIGtleTogdGhlIGtleSBpbiB3aGljaCBpcyBpbiBlbGVtZW50Q29uZmlnIGFuZCBvbiBtYXRjaCBvblN1Y2Nlc3MgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbmV4cG9ydCBmdW5jdGlvbiBjb25maWdFeGVjdXRlcihlbGVtZW50LCBrZXksIG9uU3VjY2VzcywgZWxlbWVudENvbmZpZykge1xuICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlnTWF0Y2goZWxlbWVudENvbmZpZyB8fCB3aW5kb3cuZWxlbWVudENvbmZpZywgZWxlbWVudCkpXG4gICAgaWYgKGNvbmZpZ1trZXldID09PSB0cnVlKSByZXR1cm4gb25TdWNjZXNzKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoY29uZmlnW2tleV0gPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIGVsc2UgaWYgKGNvbmZpZ1trZXldID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICBlbHNlIGlmIChpc1ZhbGlkU2VsZWN0b3IoY29uZmlnW2tleV0pKVxuICAgIHJldHVybiBvblN1Y2Nlc3MoZWxlbWVudCwgY29uZmlnLCB0cnVlKTtcbiAgZWxzZSBjb25zb2xlLndhcm4oXCJidWlsZGVyOiB3cm9uZyBlbGVtZW50IGNvbmZpZyBcIiwgY29uZmlnKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBVVUlEKGxlbmd0aCA9IDEwKSB7XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICB2YXIgY2hhcmFjdGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuXG4gIHZhciBjaGFyYWN0ZXJzTGVuZ3RoID0gY2hhcmFjdGVycy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gY2hhcmFjdGVycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcmFjdGVyc0xlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGQgPSBuZXcgRGF0ZSgpLnRvVGltZVN0cmluZygpO1xuICB2YXIgcmFuZG9tID0gZC5yZXBsYWNlKC9bXFxXX10rL2csIFwiXCIpLnN1YnN0cigwLCA2KTtcbiAgcmVzdWx0ICs9IHJhbmRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVGV4dFRvSHRtbCh0ZXh0KSB7XG4gIGxldCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHRleHQsIFwidGV4dC9odG1sXCIpO1xuICBpZiAoZG9jLmhlYWQuY2hpbGRyZW5bMF0pIHJldHVybiBkb2MuaGVhZC5jaGlsZHJlblswXTtcbiAgZWxzZSByZXR1cm4gZG9jLmJvZHkuY2hpbGRyZW5bMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEJ5ZGVsaW1pdGVyKHN0ciwgZGVsaW1pdGVyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoZGVsaW1pdGVyKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5CeWRlbGltaXRlcihzdHIsIGRlbGltaXRlcikge1xuICByZXR1cm4gc3RyLm1hcCgocykgPT4gcy50cmltKCkpLmpvaW4oZGVsaW1pdGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRTZWxlY3RvcihzZWxlY3Rvcikge1xuICB0cnkge1xuICAgIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50UGF0aChlbGVtZW50LCByZXR1cm5Db250ZXh0KSB7XG4gIGxldCBwYXRoID0gW107XG5cbiAgbGV0IHRvcFdpbmRvdyA9IHdpbmRvdztcbiAgbGV0IGlmcmFtZUVsZW1lbnQgPSBmaW5kSWZyYW1lRnJvbUVsZW1lbnQodG9wV2luZG93LCBlbGVtZW50KTtcbiAgbGV0IHAgPSBjc3NQYXRoKGlmcmFtZUVsZW1lbnQpO1xuICBpZiAocCkgcGF0aC51bnNoaWZ0KHApO1xuXG4gIHJldHVybiByZXR1cm5Db250ZXh0ID8geyBwYXRoLCBkb2N1bWVudDogaWZyYW1lRWxlbWVudCB8fCBkb2N1bWVudCB9IDogcGF0aDtcbiAgLy90b2RvOiBzdXBwb3J0IGZvciBuZXN0ZWQgaWZyYW1lXG4gIC8vIHdoaWxlKGlmcmFtZUVsZW1lbnQgIT09IGZpbmRJZnJhbWVGcm9tRWxlbWVudCh0b3BXaW5kb3csaWZyYW1lRWxlbWVudCkpXG4gIC8vIHtcbiAgLy8gICBpZnJhbWVFbGVtZW50ID0gZmluZElmcmFtZUZyb21FbGVtZW50KHRvcFdpbmRvdyxpZnJhbWVFbGVtZW50KTtcbiAgLy8gICBwYXRoLnVuc2hpZnQoY3NzUGF0aChpZnJhbWVFbGVtZW50KSlcbiAgLy8gfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0RWxlbWVudFBhdGgsXG4gIGlzVmFsaWRTZWxlY3RvcixcbiAgam9pbkJ5ZGVsaW1pdGVyLFxuICBzcGxpdEJ5ZGVsaW1pdGVyLFxuICBwYXJzZVRleHRUb0h0bWwsXG4gIFVVSUQsXG4gIGNvbmZpZ0V4ZWN1dGVyLFxuICBjb25maWdNYXRjaCxcbiAgZ2V0SWZyYW1lRnJvbVBhdGgsXG4gIGZpbmRJZnJhbWVGcm9tRWxlbWVudCxcbiAgZ2V0VG9wTW9zdFdpbmRvdyxcbiAgY3NzUGF0aCxcbiAgYWxsRnJhbWUsXG4gIGNoZWNrVmFsdWUsXG4gIGdldEF0dHJpYnV0ZXMsXG4gIGlzSnNvblN0cmluZyxcbiAgZ2V0UGFyZW50RnJvbUVsZW1lbnQsXG4gIGdlbmVyYXRlVVVJRFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/utils/src/index.js\n')},"./src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _observer = _interopRequireDefault(__webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\"));\n\nvar _crdt = _interopRequireDefault(__webpack_require__(/*! @cocreate/crdt */ \"./node_modules/@cocreate/crdt/src/index.js\"));\n\nvar _crudClient = _interopRequireDefault(__webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\"));\n\nvar _input = _interopRequireDefault(__webpack_require__(/*! @cocreate/input */ \"./node_modules/@cocreate/input/src/index.js\"));\n\nvar _floatingLabel = _interopRequireDefault(__webpack_require__(/*! @cocreate/floating-label */ \"./node_modules/@cocreate/floating-label/src/index.js\"));\n\nvar _htmltags = _interopRequireDefault(__webpack_require__(/*! @cocreate/htmltags */ \"./node_modules/@cocreate/htmltags/src/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CoCreateCalculation = {\n  init: function () {\n    this.initCalculationElements();\n  },\n  initCalculationElements: function (container) {\n    const mainContainer = container || document;\n\n    if (!mainContainer.querySelectorAll) {\n      return;\n    }\n\n    let calculationElements = mainContainer.querySelectorAll('[data-calculation]') || [];\n    calculationElements = Array.from(calculationElements);\n\n    if (mainContainer != document && mainContainer.hasAttribute('data-calculation')) {\n      calculationElements.push(mainContainer);\n    }\n\n    for (let i = 0; i < calculationElements.length; i++) {\n      if (_observer.default.getInitialized(calculationElements[i], \"calculation_init\")) {\n        return;\n      }\n\n      _observer.default.setInitialized(calculationElements[i], \"calculation_init\");\n\n      this.initCalculationElement(calculationElements[i]);\n    }\n  },\n  initCalculationElement: function (ele) {\n    const self = this;\n    let data_calculation = ele.getAttribute('data-calculation');\n    let ids = this.getIds(data_calculation);\n    let selectors = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      let id = ids[i];\n      let input = null;\n\n      try {\n        input = document.querySelector(id);\n      } catch (error) {\n        input = null;\n      }\n\n      if (input) {\n        input.addEventListener('input', function () {\n          self.setCalcationResult(ele);\n        });\n        input.addEventListener('CoCreateInput-setvalue', function () {// self.setCalcationResult(ele)\n        });\n\n        if (input.hasAttribute('data-calculation')) {\n          input.addEventListener('changedCalcValue', function (e) {\n            self.setCalcationResult(ele);\n          });\n        }\n      } else {\n        //. add event of special operator\n        let selector = this.__getOperatorSelector(id);\n\n        if (selector) {\n          selectors.push(selector);\n        }\n      }\n    }\n\n    if (selectors.length > 0) {\n      document.addEventListener('changedCalcValue', function (e) {\n        let isMatched = false;\n        selectors.forEach(selector => {\n          if (e.target.matches(selector)) {\n            isMatched = true;\n            return;\n          }\n        });\n\n        if (isMatched) {\n          self.setCalcationResult(ele);\n        }\n      });\n    }\n  },\n\n  __getOperatorSelector(value) {\n    let result = /SUM\\(\\s*([\\w\\W]+)\\s*\\)/g.exec(value);\n\n    if (result && result[1]) {\n      return result[1].trim();\n    }\n\n    return null;\n  },\n\n  calculationSpecialOperator(value) {\n    let self = this;\n    let sum = null;\n    let result = /SUM\\(\\s*([\\w\\W]+)\\s*\\)/g.exec(value);\n\n    if (result) {\n      let selector = result[1].trim();\n\n      if (value.trim().indexOf('SUM') == 0) {\n        let elements = document.querySelectorAll(selector);\n        sum = 0;\n        elements.forEach(el => {\n          let tmpValue = self.__getElementValue(el);\n\n          tmpValue = Number(tmpValue);\n\n          if (!Number.isNaN(tmpValue)) {\n            sum += tmpValue;\n          }\n        });\n      }\n    }\n\n    return sum;\n  },\n\n  setCalcationResult: function (ele) {\n    let data_calculation = ele.getAttribute('data-calculation');\n    let calString = this.replaceIdWithValue(data_calculation);\n\n    if (calString) {\n      let result = calculation(calString);\n\n      if (ele.tagName == 'INPUT' || ele.tagName == 'TEXTAREA' || ele.tagName == 'SELECT') {\n        ele.value = result;\n\n        if (_crudClient.default.isCRDT(ele)) {\n          ele.value = \"\";\n\n          _crdt.default.replaceText({\n            collection: ele.getAttribute('data-collection'),\n            document_id: ele.getAttribute('data-document_id'),\n            name: ele.getAttribute('name'),\n            value: result.toString()\n          });\n        } else {\n          _input.default.save(ele);\n        }\n\n        if (_floatingLabel.default) {\n          _floatingLabel.default.update(ele, ele.value);\n        }\n      } else {\n        ele.innerHTML = result;\n\n        _htmltags.default.saveContent(ele);\n      } //. set custom event\n\n\n      var event = new CustomEvent('changedCalcValue', {\n        bubbles: true\n      });\n      ele.dispatchEvent(event);\n    }\n  },\n  __getElementValue: function (element) {\n    if (element.tagName == 'INPUT' || element.tagName == 'TEXTAREA' || element.tagName == 'SELECT') {\n      return element.value;\n    } else {\n      return element.innerHTML;\n    }\n  },\n  replaceIdWithValue: function (data_calculation) {\n    let ids = this.getIds(data_calculation);\n\n    for (let i = 0; i < ids.length; i++) {\n      let id = ids[i];\n      let input = null;\n\n      try {\n        input = document.querySelector(id);\n      } catch (error) {\n        input = null;\n      }\n\n      let value = null;\n\n      if (input) {\n        value = Number(this.__getElementValue(input));\n      } else {\n        value = this.calculationSpecialOperator(id);\n      }\n\n      if (value != null && !Number.isNaN(value)) {\n        data_calculation = data_calculation.replaceAll('{' + id + '}', value);\n      }\n    }\n\n    return data_calculation;\n  },\n  getIds: function (string) {\n    let tmp = string;\n    let ids = [];\n    if (!tmp) return ids;\n\n    while (tmp.length > 0) {\n      let firstIndex = tmp.indexOf('{');\n      let secondIndex = tmp.indexOf('}', firstIndex);\n\n      if (firstIndex > -1 && secondIndex > -1) {\n        let id = tmp.substring(firstIndex + 1, secondIndex);\n        if (ids.indexOf(id) == -1) ids.push(id);\n        tmp = tmp.substring(secondIndex + 1);\n      } else {\n        return ids;\n      }\n    }\n\n    return ids;\n  }\n};\n\nfunction calculation(string) {\n  let index1, index2, index3, index4;\n  index1 = string.indexOf('+');\n  index2 = string.indexOf('-');\n  index3 = string.indexOf('*');\n  index4 = string.indexOf('/');\n\n  if (index1 > -1) {\n    let lStr = string.substr(0, index1);\n    let rStr = string.substr(index1 + 1);\n    return calculation(lStr) + calculation(rStr);\n  } else if (index2 > -1) {\n    let lStr = string.substr(0, index2);\n    let rStr = string.substr(index2 + 1);\n    return calculation(lStr) - calculation(rStr);\n  } else if (index3 > -1) {\n    let lStr = string.substr(0, index3);\n    let rStr = string.substr(index3 + 1);\n    return calculation(lStr) * calculation(rStr);\n  } else if (index4 > -1) {\n    let lStr = string.substr(0, index4);\n    let rStr = string.substr(index4 + 1);\n    let lValue = calculation(lStr);\n    let rValue = calculation(rStr);\n\n    if (rValue == 0) {\n      return 0;\n    } else {\n      return lValue / rValue;\n    }\n  } else {\n    let result = Number(string);\n\n    if (isNaN(result)) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n}\n\nCoCreateCalculation.init();\n\n_observer.default.init({\n  name: 'CoCreateCalculationChangeValue',\n  observe: ['attributes'],\n  attributes: ['value'],\n  include: 'input',\n  callback: function (mutation) {\n    console.log('-----------------------------------------------------');\n    console.log(mutation.target);\n  }\n});\n\n_observer.default.init({\n  name: 'CoCreateCalculationInit',\n  observe: ['subtree', 'childList'],\n  include: '[data-calculation]',\n  callback: function (mutation) {\n    CoCreateCalculation.initCalculationElements(mutation.target);\n  }\n});\n\nvar _default = CoCreateCalculation;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL3NyYy9pbmRleC5qcz9iNjM1Il0sIm5hbWVzIjpbIkNvQ3JlYXRlQ2FsY3VsYXRpb24iLCJpbml0IiwiaW5pdENhbGN1bGF0aW9uRWxlbWVudHMiLCJjb250YWluZXIiLCJtYWluQ29udGFpbmVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2FsY3VsYXRpb25FbGVtZW50cyIsIkFycmF5IiwiZnJvbSIsImhhc0F0dHJpYnV0ZSIsInB1c2giLCJpIiwibGVuZ3RoIiwiQ29DcmVhdGVPYnNlcnZlciIsImdldEluaXRpYWxpemVkIiwic2V0SW5pdGlhbGl6ZWQiLCJpbml0Q2FsY3VsYXRpb25FbGVtZW50IiwiZWxlIiwic2VsZiIsImRhdGFfY2FsY3VsYXRpb24iLCJnZXRBdHRyaWJ1dGUiLCJpZHMiLCJnZXRJZHMiLCJzZWxlY3RvcnMiLCJpZCIsImlucHV0IiwicXVlcnlTZWxlY3RvciIsImVycm9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldENhbGNhdGlvblJlc3VsdCIsImUiLCJzZWxlY3RvciIsIl9fZ2V0T3BlcmF0b3JTZWxlY3RvciIsImlzTWF0Y2hlZCIsImZvckVhY2giLCJ0YXJnZXQiLCJtYXRjaGVzIiwidmFsdWUiLCJyZXN1bHQiLCJleGVjIiwidHJpbSIsImNhbGN1bGF0aW9uU3BlY2lhbE9wZXJhdG9yIiwic3VtIiwiaW5kZXhPZiIsImVsZW1lbnRzIiwiZWwiLCJ0bXBWYWx1ZSIsIl9fZ2V0RWxlbWVudFZhbHVlIiwiTnVtYmVyIiwiaXNOYU4iLCJjYWxTdHJpbmciLCJyZXBsYWNlSWRXaXRoVmFsdWUiLCJjYWxjdWxhdGlvbiIsInRhZ05hbWUiLCJjcnVkIiwiaXNDUkRUIiwiY3JkdCIsInJlcGxhY2VUZXh0IiwiY29sbGVjdGlvbiIsImRvY3VtZW50X2lkIiwibmFtZSIsInRvU3RyaW5nIiwiQ29DcmVhdGVJbnB1dCIsInNhdmUiLCJmbG9hdGluZ0xhYmVsIiwidXBkYXRlIiwiaW5uZXJIVE1MIiwiaHRtbHRhZ3MiLCJzYXZlQ29udGVudCIsImV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiZGlzcGF0Y2hFdmVudCIsImVsZW1lbnQiLCJyZXBsYWNlQWxsIiwic3RyaW5nIiwidG1wIiwiZmlyc3RJbmRleCIsInNlY29uZEluZGV4Iiwic3Vic3RyaW5nIiwiaW5kZXgxIiwiaW5kZXgyIiwiaW5kZXgzIiwiaW5kZXg0IiwibFN0ciIsInN1YnN0ciIsInJTdHIiLCJsVmFsdWUiLCJyVmFsdWUiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImluY2x1ZGUiLCJjYWxsYmFjayIsIm11dGF0aW9uIiwiY29uc29sZSIsImxvZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUEsSUFBSUEsbUJBQW1CLEdBQUc7QUFDeEJDLE1BQUksRUFBRSxZQUFXO0FBQ2YsU0FBS0MsdUJBQUw7QUFDRCxHQUh1QjtBQU14QkEseUJBQXVCLEVBQUUsVUFBU0MsU0FBVCxFQUFvQjtBQUMzQyxVQUFNQyxhQUFhLEdBQUdELFNBQVMsSUFBSUUsUUFBbkM7O0FBQ0EsUUFBSSxDQUFDRCxhQUFhLENBQUNFLGdCQUFuQixFQUFxQztBQUNuQztBQUNEOztBQUNELFFBQUlDLG1CQUFtQixHQUFHSCxhQUFhLENBQUNFLGdCQUFkLENBQStCLG9CQUEvQixLQUF3RCxFQUFsRjtBQUNBQyx1QkFBbUIsR0FBR0MsS0FBSyxDQUFDQyxJQUFOLENBQVdGLG1CQUFYLENBQXRCOztBQUVBLFFBQUlILGFBQWEsSUFBSUMsUUFBakIsSUFBNkJELGFBQWEsQ0FBQ00sWUFBZCxDQUEyQixrQkFBM0IsQ0FBakMsRUFBaUY7QUFDL0VILHlCQUFtQixDQUFDSSxJQUFwQixDQUF5QlAsYUFBekI7QUFDRDs7QUFFRCxTQUFLLElBQUlRLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBQ0wsbUJBQW1CLENBQUNNLE1BQXBDLEVBQTRDRCxDQUFDLEVB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dUJBQW1CLENBQUNFLHVCQUFwQixDQUE0QzRGLFFBQVEsQ0FBQzFELE1BQXJEO0FBQ0E7QUFOb0IsQ0FBdEI7O2VBU2VwQyxtQiIsImZpbGUiOiIuL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb0NyZWF0ZU9ic2VydmVyIGZyb20gJ0Bjb2NyZWF0ZS9vYnNlcnZlcidcbmltcG9ydCBjcmR0IGZyb20gJ0Bjb2NyZWF0ZS9jcmR0J1xuaW1wb3J0IGNydWQgZnJvbSAnQGNvY3JlYXRlL2NydWQtY2xpZW50J1xuaW1wb3J0IENvQ3JlYXRlSW5wdXQgZnJvbSAnQGNvY3JlYXRlL2lucHV0J1xuaW1wb3J0IGZsb2F0aW5nTGFiZWwgZnJvbSAnQGNvY3JlYXRlL2Zsb2F0aW5nLWxhYmVsJ1xuaW1wb3J0IGh0bWx0YWdzIGZyb20gJ0Bjb2NyZWF0ZS9odG1sdGFncydcblxudmFyIENvQ3JlYXRlQ2FsY3VsYXRpb24gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5pdENhbGN1bGF0aW9uRWxlbWVudHMoKTtcbiAgfSxcbiAgICBcbiAgICBcbiAgaW5pdENhbGN1bGF0aW9uRWxlbWVudHM6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IG1haW5Db250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQ7XG4gICAgaWYgKCFtYWluQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNhbGN1bGF0aW9uRWxlbWVudHMgPSBtYWluQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhbGN1bGF0aW9uXScpIHx8IFtdO1xuICAgIGNhbGN1bGF0aW9uRWxlbWVudHMgPSBBcnJheS5mcm9tKGNhbGN1bGF0aW9uRWxlbWVudHMpO1xuICAgIFxuICAgIGlmIChtYWluQ29udGFpbmVyICE9IGRvY3VtZW50ICYmIG1haW5Db250YWluZXIuaGFzQXR0cmlidXRlKCdkYXRhLWNhbGN1bGF0aW9uJykpIHtcbiAgICAgIGNhbGN1bGF0aW9uRWxlbWVudHMucHVzaChtYWluQ29udGFpbmVyKTsgIFxuICAgIH1cbiAgICBcbiAgICBmb3IgKGxldCBpPTA7IGk8Y2FsY3VsYXRpb25FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIFx0aWYgKENvQ3JlYXRlT2JzZXJ2ZXIuZ2V0SW5pdGlhbGl6ZWQoY2FsY3VsYXRpb25FbGVtZW50c1tpXSwgXCJjYWxjdWxhdGlvbl9pbml0XCIpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdENvQ3JlYXRlT2JzZXJ2ZXIuc2V0SW5pdGlhbGl6ZWQoY2FsY3VsYXRpb25FbGVtZW50c1tpXSwgXCJjYWxjdWxhdGlvbl9pbml0XCIpXG4gIFx0XHRcbiAgICAgIHRoaXMuaW5pdENhbGN1bGF0aW9uRWxlbWVudChjYWxjdWxhdGlvbkVsZW1lbnRzW2ldKTsgIFxuICAgIH1cbiAgICBcbiAgfSxcbiAgICBcbiAgaW5pdENhbGN1bGF0aW9uRWxlbWVudDogZnVuY3Rpb24oZWxlKSB7XG4gICAgXG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBkYXRhX2NhbGN1bGF0aW9uID0gZWxlLmdldEF0dHJpYnV0ZSgnZGF0YS1jYWxjdWxhdGlvbicpO1xuICAgICAgbGV0IGlkcyA9IHRoaXMuZ2V0SWRzKGRhdGFfY2FsY3VsYXRpb24pO1xuXG4gICAgICBsZXQgc2VsZWN0b3JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgIFxuICAgICAgICBsZXQgaW5wdXQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IGlucHV0ID0gbnVsbDsgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0Q2FsY2F0aW9uUmVzdWx0KGVsZSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICBcbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdDb0NyZWF0ZUlucHV0LXNldHZhbHVlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIC8vIHNlbGYuc2V0Q2FsY2F0aW9uUmVzdWx0KGVsZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ2RhdGEtY2FsY3VsYXRpb24nKSkge1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlZENhbGNWYWx1ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRDYWxjYXRpb25SZXN1bHQoZWxlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8uIGFkZCBldmVudCBvZiBzcGVjaWFsIG9wZXJhdG9yXG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IHNlbGVjdG9yID0gdGhpcy5fX2dldE9wZXJhdG9yU2VsZWN0b3IoaWQpO1xuICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goc2VsZWN0b3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2VkQ2FsY1ZhbHVlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgbGV0IGlzTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlbGVjdG9ycy5mb3JFYWNoKHNlbGVjdG9yID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICBpc01hdGNoZWQgPSB0cnVlOyByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChpc01hdGNoZWQpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0Q2FsY2F0aW9uUmVzdWx0KGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICB9LFxuICBcbiAgX19nZXRPcGVyYXRvclNlbGVjdG9yKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IC9TVU1cXChcXHMqKFtcXHdcXFddKylcXHMqXFwpL2cuZXhlYyh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHRbMV0pIHtcbiAgICAgIHJldHVybiByZXN1bHRbMV0udHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgXG4gIGNhbGN1bGF0aW9uU3BlY2lhbE9wZXJhdG9yKHZhbHVlKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBzdW0gPSBudWxsO1xuICAgIGxldCByZXN1bHQgPSAvU1VNXFwoXFxzKihbXFx3XFxXXSspXFxzKlxcKS9nLmV4ZWModmFsdWUpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGxldCBzZWxlY3RvciA9IHJlc3VsdFsxXS50cmltKClcbiAgICAgIFxuICAgICAgaWYgKHZhbHVlLnRyaW0oKS5pbmRleE9mKCdTVU0nKSA9PSAwKSB7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGxldCB0bXBWYWx1ZSA9IHNlbGYuX19nZXRFbGVtZW50VmFsdWUoZWwpO1xuICAgICAgICAgIHRtcFZhbHVlID0gTnVtYmVyKHRtcFZhbHVlKTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc05hTih0bXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIHN1bSArPSB0bXBWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBcbiAgICByZXR1cm4gc3VtXG4gIH0sXG4gIFxuICAgIFxuICBzZXRDYWxjYXRpb25SZXN1bHQ6IGZ1bmN0aW9uKGVsZSkge1xuICAgIGxldCBkYXRhX2NhbGN1bGF0aW9uID0gZWxlLmdldEF0dHJpYnV0ZSgnZGF0YS1jYWxjdWxhdGlvbicpO1xuICAgIFxuICAgIGxldCBjYWxTdHJpbmcgPSB0aGlzLnJlcGxhY2VJZFdpdGhWYWx1ZShkYXRhX2NhbGN1bGF0aW9uKTtcbiAgICBcbiAgICBpZiAoY2FsU3RyaW5nKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gY2FsY3VsYXRpb24oY2FsU3RyaW5nKTtcbiAgICAgIGlmIChlbGUudGFnTmFtZSA9PSAnSU5QVVQnIHx8IGVsZS50YWdOYW1lID09ICdURVhUQVJFQScgfHwgZWxlLnRhZ05hbWUgPT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgZWxlLnZhbHVlID0gcmVzdWx0XG4gICAgICAgIFxuICAgICAgICBpZiAoY3J1ZC5pc0NSRFQoZWxlKSkge1xuICAgICAgICAgIGVsZS52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgY3JkdC5yZXBsYWNlVGV4dCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBlbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKSxcbiAgICAgICAgICAgIGRvY3VtZW50X2lkOiBlbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJyksXG4gICAgICAgICAgICBuYW1lOiBlbGUuZ2V0QXR0cmlidXRlKCduYW1lJyksXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnRvU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIENvQ3JlYXRlSW5wdXQuc2F2ZShlbGUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZmxvYXRpbmdMYWJlbCkgICB7XG4gICAgICAgICAgZmxvYXRpbmdMYWJlbC51cGRhdGUoZWxlLCBlbGUudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZS5pbm5lckhUTUwgPSByZXN1bHQ7XG4gICAgICAgIGh0bWx0YWdzLnNhdmVDb250ZW50KGVsZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vLiBzZXQgY3VzdG9tIGV2ZW50XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZWRDYWxjVmFsdWUnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICB9KVxuICAgICAgZWxlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBcbiAgfSxcbiAgXG4gIF9fZ2V0RWxlbWVudFZhbHVlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PSAnSU5QVVQnIHx8IGVsZW1lbnQudGFnTmFtZSA9PSAnVEVYVEFSRUEnIHx8IGVsZW1lbnQudGFnTmFtZSA9PSAnU0VMRUNUJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmlubmVySFRNTDtcbiAgICB9XG4gIH0sXG4gICAgXG4gIHJlcGxhY2VJZFdpdGhWYWx1ZTogZnVuY3Rpb24oZGF0YV9jYWxjdWxhdGlvbikge1xuICAgIGxldCBpZHMgPSB0aGlzLmdldElkcyhkYXRhX2NhbGN1bGF0aW9uKTtcblxuICAgIGZvciAobGV0IGk9MDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgXG4gICAgICBsZXQgaW5wdXQgPSBudWxsO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgaW5wdXQgPSBudWxsOyB9XG4gICAgICBcbiAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIodGhpcy5fX2dldEVsZW1lbnRWYWx1ZShpbnB1dCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNhbGN1bGF0aW9uU3BlY2lhbE9wZXJhdG9yKGlkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgIU51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgZGF0YV9jYWxjdWxhdGlvbiA9IGRhdGFfY2FsY3VsYXRpb24ucmVwbGFjZUFsbCgneycgKyBpZCArICd9JywgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YV9jYWxjdWxhdGlvbjtcbiAgfSxcbiAgICBcbiAgZ2V0SWRzOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBsZXQgdG1wID0gc3RyaW5nO1xuICAgIFxuICAgIGxldCBpZHMgPSBbXVxuICAgIGlmICghdG1wKSByZXR1cm4gaWRzO1xuICAgIHdoaWxlICh0bXAubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGZpcnN0SW5kZXggPSB0bXAuaW5kZXhPZigneycpO1xuICAgICAgbGV0IHNlY29uZEluZGV4ID0gdG1wLmluZGV4T2YoJ30nLCBmaXJzdEluZGV4KTtcbiAgICAgIFxuICAgICAgaWYgKGZpcnN0SW5kZXggPiAtMSAmJiBzZWNvbmRJbmRleCA+IC0xKSB7XG4gICAgICAgIGxldCBpZCA9IHRtcC5zdWJzdHJpbmcoZmlyc3RJbmRleCArIDEsIHNlY29uZEluZGV4KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpZHMuaW5kZXhPZihpZCkgPT0gLTEpIGlkcy5wdXNoKGlkKTtcbiAgXG4gICAgICAgIHRtcCA9IHRtcC5zdWJzdHJpbmcoc2Vjb25kSW5kZXggKyAxKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaWRzO1xuICB9LFxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGlvbihzdHJpbmcpIHtcbiAgbGV0IGluZGV4MSwgaW5kZXgyLCBpbmRleDMsIGluZGV4NDtcbiAgXG4gIGluZGV4MSA9IHN0cmluZy5pbmRleE9mKCcrJyk7XG4gIGluZGV4MiA9IHN0cmluZy5pbmRleE9mKCctJyk7XG4gIGluZGV4MyA9IHN0cmluZy5pbmRleE9mKCcqJyk7XG4gIGluZGV4NCA9IHN0cmluZy5pbmRleE9mKCcvJyk7XG4gIFxuICBcbiAgaWYgKGluZGV4MSA+IC0xKSB7XG4gICAgbGV0IGxTdHIgPSBzdHJpbmcuc3Vic3RyKDAsIGluZGV4MSk7XG4gICAgbGV0IHJTdHIgPSBzdHJpbmcuc3Vic3RyKGluZGV4MSArIDEpO1xuICAgIFxuICAgIHJldHVybiBjYWxjdWxhdGlvbihsU3RyKSArIGNhbGN1bGF0aW9uKHJTdHIpO1xuICAgIFxuICB9IGVsc2UgaWYgKGluZGV4MiA+IC0xKSB7XG4gICAgbGV0IGxTdHIgPSBzdHJpbmcuc3Vic3RyKDAsIGluZGV4Mik7XG4gICAgbGV0IHJTdHIgPSBzdHJpbmcuc3Vic3RyKGluZGV4MiArIDEpO1xuICAgIFxuICAgIHJldHVybiBjYWxjdWxhdGlvbihsU3RyKSAtIGNhbGN1bGF0aW9uKHJTdHIpO1xuICAgIFxuICB9IGVsc2UgaWYgKGluZGV4MyA+IC0xKSB7XG4gICAgbGV0IGxTdHIgPSBzdHJpbmcuc3Vic3RyKDAsIGluZGV4Myk7XG4gICAgbGV0IHJTdHIgPSBzdHJpbmcuc3Vic3RyKGluZGV4MyArIDEpO1xuICAgIFxuICAgIHJldHVybiBjYWxjdWxhdGlvbihsU3RyKSAqIGNhbGN1bGF0aW9uKHJTdHIpO1xuICB9IGVsc2UgaWYgKGluZGV4NCA+IC0xKSB7XG4gICAgbGV0IGxTdHIgPSBzdHJpbmcuc3Vic3RyKDAsIGluZGV4NCk7XG4gICAgbGV0IHJTdHIgPSBzdHJpbmcuc3Vic3RyKGluZGV4NCArIDEpO1xuICAgIFxuICAgIGxldCBsVmFsdWUgPSBjYWxjdWxhdGlvbihsU3RyKTtcbiAgICBsZXQgclZhbHVlID0gY2FsY3VsYXRpb24oclN0cik7XG4gICAgXG4gICAgaWYgKHJWYWx1ZSA9PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxWYWx1ZSAvIHJWYWx1ZTtcbiAgICB9XG4gICAgXG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc3VsdCA9IE51bWJlcihzdHJpbmcpO1xuICAgIFxuICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gMDsgXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFxuICAgIFxuICB9XG4gIFxufVxuXG5Db0NyZWF0ZUNhbGN1bGF0aW9uLmluaXQoKTtcblxuQ29DcmVhdGVPYnNlcnZlci5pbml0KHsgXG5cdG5hbWU6ICdDb0NyZWF0ZUNhbGN1bGF0aW9uQ2hhbmdlVmFsdWUnLCBcblx0b2JzZXJ2ZTogWydhdHRyaWJ1dGVzJ10sXG5cdGF0dHJpYnV0ZXM6IFsndmFsdWUnXSxcbiAgaW5jbHVkZTogJ2lucHV0Jyxcblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uKSB7XG5cdCAgY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJylcblx0XHRjb25zb2xlLmxvZyhtdXRhdGlvbi50YXJnZXQpXG5cdH1cbn0pO1xuXG5Db0NyZWF0ZU9ic2VydmVyLmluaXQoeyBcblx0bmFtZTogJ0NvQ3JlYXRlQ2FsY3VsYXRpb25Jbml0JywgXG5cdG9ic2VydmU6IFsnc3VidHJlZScsICdjaGlsZExpc3QnXSxcbiAgaW5jbHVkZTogJ1tkYXRhLWNhbGN1bGF0aW9uXScsXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuXHRcdENvQ3JlYXRlQ2FsY3VsYXRpb24uaW5pdENhbGN1bGF0aW9uRWxlbWVudHMobXV0YXRpb24udGFyZ2V0KVxuXHR9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVDYWxjdWxhdGlvbjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n")},"./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/cursors/src/CoCreate-cursors.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "4bae7f440ab1de156d0d0d0d0a566858.css");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3Vyc29ycy9zcmMvQ29DcmVhdGUtY3Vyc29ycy5jc3M/NzI1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUscUJBQXVCLHlDQUF5QyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9maWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3Vyc29ycy9zcmMvQ29DcmVhdGUtY3Vyc29ycy5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiNGJhZTdmNDQwYWIxZGUxNTZkMGQwZDBkMGE1NjY4NTguY3NzXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/cursors/src/CoCreate-cursors.css\n')},"./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/floating-label/src/CoCreate-floating-label.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "4f154bc545d869e8bebd258cb4bd438c.css");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvZmxvYXRpbmctbGFiZWwvc3JjL0NvQ3JlYXRlLWZsb2F0aW5nLWxhYmVsLmNzcz9hNWIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxxQkFBdUIseUNBQXlDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9mbG9hdGluZy1sYWJlbC9zcmMvQ29DcmVhdGUtZmxvYXRpbmctbGFiZWwuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjRmMTU0YmM1NDVkODY5ZThiZWJkMjU4Y2I0YmQ0MzhjLmNzc1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/floating-label/src/CoCreate-floating-label.css\n')},"./node_modules/isomorphic.js/browser.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"performance\": () => (/* binding */ performance),\n/* harmony export */   \"cryptoRandomBuffer\": () => (/* binding */ cryptoRandomBuffer)\n/* harmony export */ });\n/* eslint-env browser */\nconst performance = typeof window === 'undefined' ? null : (typeof window.performance !== 'undefined' && window.performance) || null\n\nconst isoCrypto = typeof crypto === 'undefined' ? null : crypto\n\n/**\n * @type {function(number):ArrayBuffer}\n */\nconst cryptoRandomBuffer = isoCrypto !== null\n  ? len => {\n    // browser\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    isoCrypto.getRandomValues(arr)\n    return buf\n  }\n  : len => {\n    // polyfill\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    for (let i = 0; i < len; i++) {\n      arr[i] = Math.ceil((Math.random() * 0xFFFFFFFF) >>> 0)\n    }\n    return buf\n  }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLmpzL2Jyb3dzZXIubWpzPzI2OTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNPOztBQUVQOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXNvbW9ycGhpYy5qcy9icm93c2VyLm1qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuZXhwb3J0IGNvbnN0IHBlcmZvcm1hbmNlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogKHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkgfHwgbnVsbFxuXG5jb25zdCBpc29DcnlwdG8gPSB0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBjcnlwdG9cblxuLyoqXG4gKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKTpBcnJheUJ1ZmZlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyeXB0b1JhbmRvbUJ1ZmZlciA9IGlzb0NyeXB0byAhPT0gbnVsbFxuICA/IGxlbiA9PiB7XG4gICAgLy8gYnJvd3NlclxuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pXG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGlzb0NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKVxuICAgIHJldHVybiBidWZcbiAgfVxuICA6IGxlbiA9PiB7XG4gICAgLy8gcG9seWZpbGxcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIobGVuKVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBNYXRoLmNlaWwoKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRkZGKSA+Pj4gMClcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/isomorphic.js/browser.mjs\n")},"./node_modules/lib0/array.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "last": () => (/* binding */ last),\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "copy": () => (/* binding */ copy),\n/* harmony export */   "appendTo": () => (/* binding */ appendTo),\n/* harmony export */   "from": () => (/* binding */ from),\n/* harmony export */   "every": () => (/* binding */ every),\n/* harmony export */   "some": () => (/* binding */ some),\n/* harmony export */   "equalFlat": () => (/* binding */ equalFlat),\n/* harmony export */   "flatten": () => (/* binding */ flatten)\n/* harmony export */ });\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nconst last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nconst create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nconst copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nconst appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nconst every = (arr, f) => arr.every(f)\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nconst some = (arr, f) => arr.some(f)\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nconst flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2FycmF5LmpzP2ZjYTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ08sZ0NBQWdDLFNBQVM7O0FBRWhEO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ08sNkJBQTZCLFNBQVM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNPO0FBQ1AsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLDRDQUE0QztBQUN2RCxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0NBQXNDO0FBQ2pELFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvYXJyYXkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBBcnJheXMuXG4gKlxuICogQG1vZHVsZSBhcnJheVxuICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFRoZSBlbGVtZW50IG11c3QgZXhpc3RcbiAqXG4gKiBAdGVtcGxhdGUgTFxuICogQHBhcmFtIHtBcnJheTxMPn0gYXJyXG4gKiBAcmV0dXJuIHtMfVxuICovXG5leHBvcnQgY29uc3QgbGFzdCA9IGFyciA9PiBhcnJbYXJyLmxlbmd0aCAtIDFdXG5cbi8qKlxuICogQHRlbXBsYXRlIENcbiAqIEByZXR1cm4ge0FycmF5PEM+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKCkgPT4gLyoqIEB0eXBlIHtBcnJheTxDPn0gKi8gKFtdKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBEXG4gKiBAcGFyYW0ge0FycmF5PEQ+fSBhXG4gKiBAcmV0dXJuIHtBcnJheTxEPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHkgPSBhID0+IC8qKiBAdHlwZSB7QXJyYXk8RD59ICovIChhLnNsaWNlKCkpXG5cbi8qKlxuICogQXBwZW5kIGVsZW1lbnRzIGZyb20gc3JjIHRvIGRlc3RcbiAqXG4gKiBAdGVtcGxhdGUgTVxuICogQHBhcmFtIHtBcnJheTxNPn0gZGVzdFxuICogQHBhcmFtIHtBcnJheTxNPn0gc3JjXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmRUbyA9IChkZXN0LCBzcmMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXN0LnB1c2goc3JjW2ldKVxuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBzb21ldGhpbmcgYXJyYXktbGlrZSB0byBhbiBhY3R1YWwgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheUxpa2U8VD58SXRlcmFibGU8VD59IGFycmF5bGlrZVxuICogQHJldHVybiB7VH1cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb20gPSBBcnJheS5mcm9tXG5cbi8qKlxuICogVHJ1ZSBpZmYgY29uZGl0aW9uIGhvbGRzIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIElURU1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PElURU0+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSVRFTSwgbnVtYmVyLCBBcnJheTxJVEVNPik6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZXJ5ID0gKGFyciwgZikgPT4gYXJyLmV2ZXJ5KGYpXG5cbi8qKlxuICogVHJ1ZSBpZmYgY29uZGl0aW9uIGhvbGRzIG9uIHNvbWUgZWxlbWVudCBpbiB0aGUgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtBcnJheTxTPn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFMsIG51bWJlciwgQXJyYXk8Uz4pOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gKGFyciwgZikgPT4gYXJyLnNvbWUoZilcblxuLyoqXG4gKiBAdGVtcGxhdGUgRUxFTVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RUxFTT59IGFcbiAqIEBwYXJhbSB7QXJyYXk8RUxFTT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGV2ZXJ5KGEsIChpdGVtLCBpbmRleCkgPT4gaXRlbSA9PT0gYltpbmRleF0pXG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8RUxFTT4+fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5PEVMRU0+fVxuICovXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IGFyciA9PiBhcnIucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpLCBbXSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/array.js\n')},"./node_modules/lib0/binary.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BIT1": () => (/* binding */ BIT1),\n/* harmony export */   "BIT2": () => (/* binding */ BIT2),\n/* harmony export */   "BIT3": () => (/* binding */ BIT3),\n/* harmony export */   "BIT4": () => (/* binding */ BIT4),\n/* harmony export */   "BIT5": () => (/* binding */ BIT5),\n/* harmony export */   "BIT6": () => (/* binding */ BIT6),\n/* harmony export */   "BIT7": () => (/* binding */ BIT7),\n/* harmony export */   "BIT8": () => (/* binding */ BIT8),\n/* harmony export */   "BIT9": () => (/* binding */ BIT9),\n/* harmony export */   "BIT10": () => (/* binding */ BIT10),\n/* harmony export */   "BIT11": () => (/* binding */ BIT11),\n/* harmony export */   "BIT12": () => (/* binding */ BIT12),\n/* harmony export */   "BIT13": () => (/* binding */ BIT13),\n/* harmony export */   "BIT14": () => (/* binding */ BIT14),\n/* harmony export */   "BIT15": () => (/* binding */ BIT15),\n/* harmony export */   "BIT16": () => (/* binding */ BIT16),\n/* harmony export */   "BIT17": () => (/* binding */ BIT17),\n/* harmony export */   "BIT18": () => (/* binding */ BIT18),\n/* harmony export */   "BIT19": () => (/* binding */ BIT19),\n/* harmony export */   "BIT20": () => (/* binding */ BIT20),\n/* harmony export */   "BIT21": () => (/* binding */ BIT21),\n/* harmony export */   "BIT22": () => (/* binding */ BIT22),\n/* harmony export */   "BIT23": () => (/* binding */ BIT23),\n/* harmony export */   "BIT24": () => (/* binding */ BIT24),\n/* harmony export */   "BIT25": () => (/* binding */ BIT25),\n/* harmony export */   "BIT26": () => (/* binding */ BIT26),\n/* harmony export */   "BIT27": () => (/* binding */ BIT27),\n/* harmony export */   "BIT28": () => (/* binding */ BIT28),\n/* harmony export */   "BIT29": () => (/* binding */ BIT29),\n/* harmony export */   "BIT30": () => (/* binding */ BIT30),\n/* harmony export */   "BIT31": () => (/* binding */ BIT31),\n/* harmony export */   "BIT32": () => (/* binding */ BIT32),\n/* harmony export */   "BITS0": () => (/* binding */ BITS0),\n/* harmony export */   "BITS1": () => (/* binding */ BITS1),\n/* harmony export */   "BITS2": () => (/* binding */ BITS2),\n/* harmony export */   "BITS3": () => (/* binding */ BITS3),\n/* harmony export */   "BITS4": () => (/* binding */ BITS4),\n/* harmony export */   "BITS5": () => (/* binding */ BITS5),\n/* harmony export */   "BITS6": () => (/* binding */ BITS6),\n/* harmony export */   "BITS7": () => (/* binding */ BITS7),\n/* harmony export */   "BITS8": () => (/* binding */ BITS8),\n/* harmony export */   "BITS9": () => (/* binding */ BITS9),\n/* harmony export */   "BITS10": () => (/* binding */ BITS10),\n/* harmony export */   "BITS11": () => (/* binding */ BITS11),\n/* harmony export */   "BITS12": () => (/* binding */ BITS12),\n/* harmony export */   "BITS13": () => (/* binding */ BITS13),\n/* harmony export */   "BITS14": () => (/* binding */ BITS14),\n/* harmony export */   "BITS15": () => (/* binding */ BITS15),\n/* harmony export */   "BITS16": () => (/* binding */ BITS16),\n/* harmony export */   "BITS17": () => (/* binding */ BITS17),\n/* harmony export */   "BITS18": () => (/* binding */ BITS18),\n/* harmony export */   "BITS19": () => (/* binding */ BITS19),\n/* harmony export */   "BITS20": () => (/* binding */ BITS20),\n/* harmony export */   "BITS21": () => (/* binding */ BITS21),\n/* harmony export */   "BITS22": () => (/* binding */ BITS22),\n/* harmony export */   "BITS23": () => (/* binding */ BITS23),\n/* harmony export */   "BITS24": () => (/* binding */ BITS24),\n/* harmony export */   "BITS25": () => (/* binding */ BITS25),\n/* harmony export */   "BITS26": () => (/* binding */ BITS26),\n/* harmony export */   "BITS27": () => (/* binding */ BITS27),\n/* harmony export */   "BITS28": () => (/* binding */ BITS28),\n/* harmony export */   "BITS29": () => (/* binding */ BITS29),\n/* harmony export */   "BITS30": () => (/* binding */ BITS30),\n/* harmony export */   "BITS31": () => (/* binding */ BITS31),\n/* harmony export */   "BITS32": () => (/* binding */ BITS32)\n/* harmony export */ });\n/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nconst BIT1 = 1\nconst BIT2 = 2\nconst BIT3 = 4\nconst BIT4 = 8\nconst BIT5 = 16\nconst BIT6 = 32\nconst BIT7 = 64\nconst BIT8 = 128\nconst BIT9 = 256\nconst BIT10 = 512\nconst BIT11 = 1024\nconst BIT12 = 2048\nconst BIT13 = 4096\nconst BIT14 = 8192\nconst BIT15 = 16384\nconst BIT16 = 32768\nconst BIT17 = 65536\nconst BIT18 = 1 << 17\nconst BIT19 = 1 << 18\nconst BIT20 = 1 << 19\nconst BIT21 = 1 << 20\nconst BIT22 = 1 << 21\nconst BIT23 = 1 << 22\nconst BIT24 = 1 << 23\nconst BIT25 = 1 << 24\nconst BIT26 = 1 << 25\nconst BIT27 = 1 << 26\nconst BIT28 = 1 << 27\nconst BIT29 = 1 << 28\nconst BIT30 = 1 << 29\nconst BIT31 = 1 << 30\nconst BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nconst BITS0 = 0\nconst BITS1 = 1\nconst BITS2 = 3\nconst BITS3 = 7\nconst BITS4 = 15\nconst BITS5 = 31\nconst BITS6 = 63\nconst BITS7 = 127\nconst BITS8 = 255\nconst BITS9 = 511\nconst BITS10 = 1023\nconst BITS11 = 2047\nconst BITS12 = 4095\nconst BITS13 = 8191\nconst BITS14 = 16383\nconst BITS15 = 32767\nconst BITS16 = 65535\nconst BITS17 = BIT18 - 1\nconst BITS18 = BIT19 - 1\nconst BITS19 = BIT20 - 1\nconst BITS20 = BIT21 - 1\nconst BITS21 = BIT22 - 1\nconst BITS22 = BIT23 - 1\nconst BITS23 = BIT24 - 1\nconst BITS24 = BIT25 - 1\nconst BITS25 = BIT26 - 1\nconst BITS26 = BIT27 - 1\nconst BITS27 = BIT28 - 1\nconst BITS28 = BIT29 - 1\nconst BITS29 = BIT30 - 1\nconst BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nconst BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nconst BITS32 = 0xFFFFFFFF\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2JpbmFyeS5qcz9jNzdmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0EsVUFBVTtBQUNWO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9iaW5hcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBCaW5hcnkgZGF0YSBjb25zdGFudHMuXG4gKlxuICogQG1vZHVsZSBiaW5hcnlcbiAqL1xuXG4vKipcbiAqIG4tdGggYml0IGFjdGl2YXRlZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUMSA9IDFcbmV4cG9ydCBjb25zdCBCSVQyID0gMlxuZXhwb3J0IGNvbnN0IEJJVDMgPSA0XG5leHBvcnQgY29uc3QgQklUNCA9IDhcbmV4cG9ydCBjb25zdCBCSVQ1ID0gMTZcbmV4cG9ydCBjb25zdCBCSVQ2ID0gMzJcbmV4cG9ydCBjb25zdCBCSVQ3ID0gNjRcbmV4cG9ydCBjb25zdCBCSVQ4ID0gMTI4XG5leHBvcnQgY29uc3QgQklUOSA9IDI1NlxuZXhwb3J0IGNvbnN0IEJJVDEwID0gNTEyXG5leHBvcnQgY29uc3QgQklUMTEgPSAxMDI0XG5leHBvcnQgY29uc3QgQklUMTIgPSAyMDQ4XG5leHBvcnQgY29uc3QgQklUMTMgPSA0MDk2XG5leHBvcnQgY29uc3QgQklUMTQgPSA4MTkyXG5leHBvcnQgY29uc3QgQklUMTUgPSAxNjM4NFxuZXhwb3J0IGNvbnN0IEJJVDE2ID0gMzI3NjhcbmV4cG9ydCBjb25zdCBCSVQxNyA9IDY1NTM2XG5leHBvcnQgY29uc3QgQklUMTggPSAxIDw8IDE3XG5leHBvcnQgY29uc3QgQklUMTkgPSAxIDw8IDE4XG5leHBvcnQgY29uc3QgQklUMjAgPSAxIDw8IDE5XG5leHBvcnQgY29uc3QgQklUMjEgPSAxIDw8IDIwXG5leHBvcnQgY29uc3QgQklUMjIgPSAxIDw8IDIxXG5leHBvcnQgY29uc3QgQklUMjMgPSAxIDw8IDIyXG5leHBvcnQgY29uc3QgQklUMjQgPSAxIDw8IDIzXG5leHBvcnQgY29uc3QgQklUMjUgPSAxIDw8IDI0XG5leHBvcnQgY29uc3QgQklUMjYgPSAxIDw8IDI1XG5leHBvcnQgY29uc3QgQklUMjcgPSAxIDw8IDI2XG5leHBvcnQgY29uc3QgQklUMjggPSAxIDw8IDI3XG5leHBvcnQgY29uc3QgQklUMjkgPSAxIDw8IDI4XG5leHBvcnQgY29uc3QgQklUMzAgPSAxIDw8IDI5XG5leHBvcnQgY29uc3QgQklUMzEgPSAxIDw8IDMwXG5leHBvcnQgY29uc3QgQklUMzIgPSAxIDw8IDMxXG5cbi8qKlxuICogRmlyc3QgbiBiaXRzIGFjdGl2YXRlZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUUzAgPSAwXG5leHBvcnQgY29uc3QgQklUUzEgPSAxXG5leHBvcnQgY29uc3QgQklUUzIgPSAzXG5leHBvcnQgY29uc3QgQklUUzMgPSA3XG5leHBvcnQgY29uc3QgQklUUzQgPSAxNVxuZXhwb3J0IGNvbnN0IEJJVFM1ID0gMzFcbmV4cG9ydCBjb25zdCBCSVRTNiA9IDYzXG5leHBvcnQgY29uc3QgQklUUzcgPSAxMjdcbmV4cG9ydCBjb25zdCBCSVRTOCA9IDI1NVxuZXhwb3J0IGNvbnN0IEJJVFM5ID0gNTExXG5leHBvcnQgY29uc3QgQklUUzEwID0gMTAyM1xuZXhwb3J0IGNvbnN0IEJJVFMxMSA9IDIwNDdcbmV4cG9ydCBjb25zdCBCSVRTMTIgPSA0MDk1XG5leHBvcnQgY29uc3QgQklUUzEzID0gODE5MVxuZXhwb3J0IGNvbnN0IEJJVFMxNCA9IDE2MzgzXG5leHBvcnQgY29uc3QgQklUUzE1ID0gMzI3NjdcbmV4cG9ydCBjb25zdCBCSVRTMTYgPSA2NTUzNVxuZXhwb3J0IGNvbnN0IEJJVFMxNyA9IEJJVDE4IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMxOCA9IEJJVDE5IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMxOSA9IEJJVDIwIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMCA9IEJJVDIxIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMSA9IEJJVDIyIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMiA9IEJJVDIzIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMyA9IEJJVDI0IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNCA9IEJJVDI1IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNSA9IEJJVDI2IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNiA9IEJJVDI3IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNyA9IEJJVDI4IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyOCA9IEJJVDI5IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyOSA9IEJJVDMwIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMzMCA9IEJJVDMxIC0gMVxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUUzMxID0gMHg3RkZGRkZGRlxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUUzMyID0gMHhGRkZGRkZGRlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/binary.js\n')},"./node_modules/lib0/broadcastchannel.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribe\": () => (/* binding */ subscribe),\n/* harmony export */   \"unsubscribe\": () => (/* binding */ unsubscribe),\n/* harmony export */   \"publish\": () => (/* binding */ publish)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ \"./node_modules/lib0/buffer.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage.js */ \"./node_modules/lib0/storage.js\");\n/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\n\n\n\n\n/**\n * @typedef {Object} Channel\n * @property {Set<Function>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    _storage_js__WEBPACK_IMPORTED_MODULE_0__.onChange(e => e.key === room && this.onmessage !== null && this.onmessage({ data: _buffer_js__WEBPACK_IMPORTED_MODULE_1__.fromBase64(e.newValue || '') }))\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    _storage_js__WEBPACK_IMPORTED_MODULE_0__.varStorage.setItem(this.room, _buffer_js__WEBPACK_IMPORTED_MODULE_1__.toBase64(_buffer_js__WEBPACK_IMPORTED_MODULE_1__.createUint8ArrayFromArrayBuffer(buf)))\n  }\n}\n\n// Use BroadcastChannel or Polyfill\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  _map_js__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(channels, room, () => {\n    const subs = new Set()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nconst subscribe = (room, f) => getChannel(room).subs.add(f)\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nconst unsubscribe = (room, f) => getChannel(room).subs.delete(f)\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n */\nconst publish = (room, data) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2Jyb2FkY2FzdGNoYW5uZWwuanM/NDdkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUUrQjtBQUNNO0FBQ0U7O0FBRXZDO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsY0FBYztBQUM1QixjQUFjLElBQUk7QUFDbEI7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0EsSUFBSSxpREFBZ0IsbUVBQW1FLE9BQU8sa0RBQWlCLG9CQUFvQjtBQUNuSTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0EsSUFBSSwyREFBMEIsWUFBWSxnREFBZSxDQUFDLHVFQUFzQztBQUNoRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxFQUFFLG1EQUFrQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLElBQUk7QUFDZjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9icm9hZGNhc3RjaGFubmVsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogSGVscGVycyBmb3IgY3Jvc3MtdGFiIGNvbW11bmljYXRpb24gdXNpbmcgYnJvYWRjYXN0Y2hhbm5lbCB3aXRoIExvY2FsU3RvcmFnZSBmYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQTpcbiAqIGJyb2FkY2FzdGNoYW5uZWwuc3Vic2NyaWJlKCdteSBldmVudHMnLCBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKVxuICogYnJvYWRjYXN0Y2hhbm5lbC5wdWJsaXNoKCdteSBldmVudHMnLCAnSGVsbG8gd29ybGQhJykgLy8gPT4gQTogJ0hlbGxvIHdvcmxkIScgZmlyZXMgc3luY2hyb25vdXNseSBpbiBzYW1lIHRhYlxuICpcbiAqIC8vIEluIGJyb3dzZXIgd2luZG93IEI6XG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdoZWxsbyBmcm9tIHRhYiBCJykgLy8gPT4gQTogJ2hlbGxvIGZyb20gdGFiIEInXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGJyb2FkY2FzdGNoYW5uZWxcbiAqL1xuXG4vLyBAdG9kbyBiZWZvcmUgbmV4dCBtYWpvcjogdXNlIFVpbnQ4QXJyYXkgaW5zdGVhZCBhcyBidWZmZXIgb2JqZWN0XG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYW5uZWxcbiAqIEBwcm9wZXJ0eSB7U2V0PEZ1bmN0aW9uPn0gQ2hhbm5lbC5zdWJzXG4gKiBAcHJvcGVydHkge2FueX0gQ2hhbm5lbC5iY1xuICovXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsIENoYW5uZWw+fVxuICovXG5jb25zdCBjaGFubmVscyA9IG5ldyBNYXAoKVxuXG5jbGFzcyBMb2NhbFN0b3JhZ2VQb2x5ZmlsbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb20pIHtcbiAgICB0aGlzLnJvb20gPSByb29tXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGx8ZnVuY3Rpb24oe2RhdGE6QXJyYXlCdWZmZXJ9KTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMub25tZXNzYWdlID0gbnVsbFxuICAgIHN0b3JhZ2Uub25DaGFuZ2UoZSA9PiBlLmtleSA9PT0gcm9vbSAmJiB0aGlzLm9ubWVzc2FnZSAhPT0gbnVsbCAmJiB0aGlzLm9ubWVzc2FnZSh7IGRhdGE6IGJ1ZmZlci5mcm9tQmFzZTY0KGUubmV3VmFsdWUgfHwgJycpIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZlxuICAgKi9cbiAgcG9zdE1lc3NhZ2UgKGJ1Zikge1xuICAgIHN0b3JhZ2UudmFyU3RvcmFnZS5zZXRJdGVtKHRoaXMucm9vbSwgYnVmZmVyLnRvQmFzZTY0KGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyKGJ1ZikpKVxuICB9XG59XG5cbi8vIFVzZSBCcm9hZGNhc3RDaGFubmVsIG9yIFBvbHlmaWxsXG5jb25zdCBCQyA9IHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsID09PSAndW5kZWZpbmVkJyA/IExvY2FsU3RvcmFnZVBvbHlmaWxsIDogQnJvYWRjYXN0Q2hhbm5lbFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcmV0dXJuIHtDaGFubmVsfVxuICovXG5jb25zdCBnZXRDaGFubmVsID0gcm9vbSA9PlxuICBtYXAuc2V0SWZVbmRlZmluZWQoY2hhbm5lbHMsIHJvb20sICgpID0+IHtcbiAgICBjb25zdCBzdWJzID0gbmV3IFNldCgpXG4gICAgY29uc3QgYmMgPSBuZXcgQkMocm9vbSlcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3tkYXRhOkFycmF5QnVmZmVyfX0gZVxuICAgICAqL1xuICAgIGJjLm9ubWVzc2FnZSA9IGUgPT4gc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIoZS5kYXRhKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmMsIHN1YnNcbiAgICB9XG4gIH0pXG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGdsb2JhbCBgcHVibGlzaGAgZXZlbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IHN1YnNjcmliZSA9IChyb29tLCBmKSA9PiBnZXRDaGFubmVsKHJvb20pLnN1YnMuYWRkKGYpXG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBgcHVibGlzaGAgZ2xvYmFsIGV2ZW50cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCB1bnN1YnNjcmliZSA9IChyb29tLCBmKSA9PiBnZXRDaGFubmVsKHJvb20pLnN1YnMuZGVsZXRlKGYpXG5cbi8qKlxuICogUHVibGlzaCBkYXRhIHRvIGFsbCBzdWJzY3JpYmVycyAoaW5jbHVkaW5nIHN1YnNjcmliZXJzIG9uIHRoaXMgdGFiKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7YW55fSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBwdWJsaXNoID0gKHJvb20sIGRhdGEpID0+IHtcbiAgY29uc3QgYyA9IGdldENoYW5uZWwocm9vbSlcbiAgYy5iYy5wb3N0TWVzc2FnZShkYXRhKVxuICBjLnN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGRhdGEpKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/broadcastchannel.js\n")},"./node_modules/lib0/buffer.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createUint8ArrayFromLen": () => (/* binding */ createUint8ArrayFromLen),\n/* harmony export */   "createUint8ArrayViewFromArrayBuffer": () => (/* binding */ createUint8ArrayViewFromArrayBuffer),\n/* harmony export */   "createUint8ArrayFromArrayBuffer": () => (/* binding */ createUint8ArrayFromArrayBuffer),\n/* harmony export */   "toBase64": () => (/* binding */ toBase64),\n/* harmony export */   "fromBase64": () => (/* binding */ fromBase64),\n/* harmony export */   "copyUint8Array": () => (/* binding */ copyUint8Array),\n/* harmony export */   "encodeAny": () => (/* binding */ encodeAny),\n/* harmony export */   "decodeAny": () => (/* binding */ decodeAny)\n/* harmony export */ });\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string.js */ "./node_modules/lib0/string.js");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "./node_modules/lib0/environment.js");\n/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var _decoding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decoding.js */ "./node_modules/lib0/decoding.js");\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n\n\n\n\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = \'\'\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += _string_js__WEBPACK_IMPORTED_MODULE_0__.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString(\'base64\')\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, \'base64\')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* istanbul ignore next */\nconst toBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? toBase64Browser : toBase64Node\n\n/* istanbul ignore next */\nconst fromBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nconst copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It\'s a pun on typescripts\'s `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nconst encodeAny = data => {\n  const encoder = _encoding_js__WEBPACK_IMPORTED_MODULE_2__.createEncoder()\n  _encoding_js__WEBPACK_IMPORTED_MODULE_2__.writeAny(encoder, data)\n  return _encoding_js__WEBPACK_IMPORTED_MODULE_2__.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nconst decodeAny = buf => _decoding_js__WEBPACK_IMPORTED_MODULE_3__.readAny(_decoding_js__WEBPACK_IMPORTED_MODULE_3__.createDecoder(buf))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2J1ZmZlci5qcz9kNzJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0U7QUFDRTtBQUNBOztBQUV6QztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxTQUFTLG9EQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLGlCQUFpQixzREFBYTs7QUFFckM7QUFDTyxtQkFBbUIsc0RBQWE7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsWUFBWTtBQUNaO0FBQ087QUFDUCxrQkFBa0IsdURBQXNCO0FBQ3hDLEVBQUUsa0RBQWlCO0FBQ25CLFNBQVMsc0RBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDTyx5QkFBeUIsaURBQWdCLENBQUMsdURBQXNCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvYnVmZmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggYnVmZmVycyAoVWludDhBcnJheSkuXG4gKlxuICogQG1vZHVsZSBidWZmZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi9zdHJpbmcuanMnXG5pbXBvcnQgKiBhcyBlbnYgZnJvbSAnLi9lbnZpcm9ubWVudC5qcydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJy4vZW5jb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICcuL2RlY29kaW5nLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuID0gbGVuID0+IG5ldyBVaW50OEFycmF5KGxlbilcblxuLyoqXG4gKiBDcmVhdGUgVWludDhBcnJheSB3aXRoIGluaXRpYWwgY29udGVudCBmcm9tIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyID0gKGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSA9PiBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aClcblxuLyoqXG4gKiBDcmVhdGUgVWludDhBcnJheSB3aXRoIGluaXRpYWwgY29udGVudCBmcm9tIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgVWludDhBcnJheShidWZmZXIpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9CYXNlNjRCcm93c2VyID0gYnl0ZXMgPT4ge1xuICBsZXQgcyA9ICcnXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgcyArPSBzdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICByZXR1cm4gYnRvYShzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9CYXNlNjROb2RlID0gYnl0ZXMgPT4gQnVmZmVyLmZyb20oYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKS50b1N0cmluZygnYmFzZTY0JylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGZyb21CYXNlNjRCcm93c2VyID0gcyA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBjb25zdCBhID0gYXRvYihzKVxuICBjb25zdCBieXRlcyA9IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuKGEubGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGEuY2hhckNvZGVBdChpKVxuICB9XG4gIHJldHVybiBieXRlc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKi9cbmNvbnN0IGZyb21CYXNlNjROb2RlID0gcyA9PiB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHMsICdiYXNlNjQnKVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHRvQmFzZTY0ID0gZW52LmlzQnJvd3NlciA/IHRvQmFzZTY0QnJvd3NlciA6IHRvQmFzZTY0Tm9kZVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGZyb21CYXNlNjQgPSBlbnYuaXNCcm93c2VyID8gZnJvbUJhc2U2NEJyb3dzZXIgOiBmcm9tQmFzZTY0Tm9kZVxuXG4vKipcbiAqIENvcHkgdGhlIGNvbnRlbnQgb2YgYW4gVWludDhBcnJheSB2aWV3IHRvIGEgbmV3IEFycmF5QnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlVaW50OEFycmF5ID0gdWludDhBcnJheSA9PiB7XG4gIGNvbnN0IG5ld0J1ZiA9IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuKHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aClcbiAgbmV3QnVmLnNldCh1aW50OEFycmF5KVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qKlxuICogRW5jb2RlIGFueXRoaW5nIGFzIGEgVUludDhBcnJheS4gSXQncyBhIHB1biBvbiB0eXBlc2NyaXB0cydzIGBhbnlgIHR5cGUuXG4gKiBTZWUgZW5jb2Rpbmcud3JpdGVBbnkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBbnkgPSBkYXRhID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBlbmNvZGluZy53cml0ZUFueShlbmNvZGVyLCBkYXRhKVxuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59XG5cbi8qKlxuICogRGVjb2RlIGFuIGFueS1lbmNvZGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVBbnkgPSBidWYgPT4gZGVjb2RpbmcucmVhZEFueShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/buffer.js\n')},"./node_modules/lib0/conditions.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "undefinedToNull": () => (/* binding */ undefinedToNull)\n/* harmony export */ });\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nconst undefinedToNull = v => v === undefined ? null : v\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2NvbmRpdGlvbnMuanM/ZTM5NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2NvbmRpdGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9mdGVuIHVzZWQgY29uZGl0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGNvbmRpdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8bnVsbHx1bmRlZmluZWR9IHZcbiAqIEByZXR1cm4ge1R8bnVsbH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB1bmRlZmluZWRUb051bGwgPSB2ID0+IHYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/conditions.js\n')},"./node_modules/lib0/decoding.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Decoder": () => (/* binding */ Decoder),\n/* harmony export */   "createDecoder": () => (/* binding */ createDecoder),\n/* harmony export */   "hasContent": () => (/* binding */ hasContent),\n/* harmony export */   "clone": () => (/* binding */ clone),\n/* harmony export */   "readUint8Array": () => (/* binding */ readUint8Array),\n/* harmony export */   "readVarUint8Array": () => (/* binding */ readVarUint8Array),\n/* harmony export */   "readTailAsUint8Array": () => (/* binding */ readTailAsUint8Array),\n/* harmony export */   "skip8": () => (/* binding */ skip8),\n/* harmony export */   "readUint8": () => (/* binding */ readUint8),\n/* harmony export */   "readUint16": () => (/* binding */ readUint16),\n/* harmony export */   "readUint32": () => (/* binding */ readUint32),\n/* harmony export */   "readUint32BigEndian": () => (/* binding */ readUint32BigEndian),\n/* harmony export */   "peekUint8": () => (/* binding */ peekUint8),\n/* harmony export */   "peekUint16": () => (/* binding */ peekUint16),\n/* harmony export */   "peekUint32": () => (/* binding */ peekUint32),\n/* harmony export */   "readVarUint": () => (/* binding */ readVarUint),\n/* harmony export */   "readVarInt": () => (/* binding */ readVarInt),\n/* harmony export */   "peekVarUint": () => (/* binding */ peekVarUint),\n/* harmony export */   "peekVarInt": () => (/* binding */ peekVarInt),\n/* harmony export */   "readVarString": () => (/* binding */ readVarString),\n/* harmony export */   "peekVarString": () => (/* binding */ peekVarString),\n/* harmony export */   "readFromDataView": () => (/* binding */ readFromDataView),\n/* harmony export */   "readFloat32": () => (/* binding */ readFloat32),\n/* harmony export */   "readFloat64": () => (/* binding */ readFloat64),\n/* harmony export */   "readBigInt64": () => (/* binding */ readBigInt64),\n/* harmony export */   "readBigUint64": () => (/* binding */ readBigUint64),\n/* harmony export */   "readAny": () => (/* binding */ readAny),\n/* harmony export */   "RleDecoder": () => (/* binding */ RleDecoder),\n/* harmony export */   "IntDiffDecoder": () => (/* binding */ IntDiffDecoder),\n/* harmony export */   "RleIntDiffDecoder": () => (/* binding */ RleIntDiffDecoder),\n/* harmony export */   "UintOptRleDecoder": () => (/* binding */ UintOptRleDecoder),\n/* harmony export */   "IncUintOptRleDecoder": () => (/* binding */ IncUintOptRleDecoder),\n/* harmony export */   "IntDiffOptRleDecoder": () => (/* binding */ IntDiffOptRleDecoder),\n/* harmony export */   "StringDecoder": () => (/* binding */ StringDecoder)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/lib0/buffer.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ "./node_modules/lib0/binary.js");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang\'s binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, \'Hello world!\')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => \'Hello world!\'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\n\n\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nconst hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nconst clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nconst skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0\n  let len = 0\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    num = num | ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS7) << len)\n    len += 7\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error(\'Integer out of range!\')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS6\n  let len = 6\n  const sign = (r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT7) > 0 ? -1 : 1\n  if ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) === 0) {\n    // don\'t continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    num = num | ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS7) << len)\n    len += 7\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error(\'Integer out of range!\')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nconst readVarString = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return \'\'\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nconst readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nconst readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nclass RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nclass IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nclass RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_2__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_2__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nclass IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = diff >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nclass StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2RlY29kaW5nLmpzPzFiMjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDQTtBQUNKOztBQUVqQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUCxlQUFlLDJFQUEwQztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFTztBQUNQO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGVjb2RpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZGVjb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2RlY29kaW5nXSB3aXRoIFtsaWIwL2VuY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gbmV3IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IG5ldyBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZGVjb2RpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnLi9idWZmZXIuanMnXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnLi9iaW5hcnkuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcblxuLyoqXG4gKiBBIERlY29kZXIgaGFuZGxlcyB0aGUgZGVjb2Rpbmcgb2YgYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5IEJpbmFyeSBkYXRhIHRvIGRlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICAvKipcbiAgICAgKiBEZWNvZGluZyB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IHVpbnQ4QXJyYXlcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRlY29kaW5nIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDBcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtEZWNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGVjb2RlciA9IHVpbnQ4QXJyYXkgPT4gbmV3IERlY29kZXIodWludDhBcnJheSlcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0NvbnRlbnQgPSBkZWNvZGVyID0+IGRlY29kZXIucG9zICE9PSBkZWNvZGVyLmFyci5sZW5ndGhcblxuLyoqXG4gKiBDbG9uZSBhIGRlY29kZXIgaW5zdGFuY2UuXG4gKiBPcHRpb25hbGx5IHNldCBhIG5ldyBwb3NpdGlvbiBwYXJhbWV0ZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3UG9zXSBEZWZhdWx0cyB0byBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtEZWNvZGVyfSBBIGNsb25lIG9mIGBkZWNvZGVyYFxuICovXG5leHBvcnQgY29uc3QgY2xvbmUgPSAoZGVjb2RlciwgbmV3UG9zID0gZGVjb2Rlci5wb3MpID0+IHtcbiAgY29uc3QgX2RlY29kZXIgPSBjcmVhdGVEZWNvZGVyKGRlY29kZXIuYXJyKVxuICBfZGVjb2Rlci5wb3MgPSBuZXdQb3NcbiAgcmV0dXJuIF9kZWNvZGVyXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIFVpbnQ4QXJyYXkgdmlldyBvZiB0aGUgbmV4dCBgbGVuYCBieXRlcyBhbmQgYWR2YW5jZSB0aGUgcG9zaXRpb24gYnkgYGxlbmAuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFRoZSBsZW5ndGggb2YgYnl0ZXMgdG8gcmVhZFxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50OEFycmF5ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCB2aWV3ID0gYnVmZmVyLmNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyKGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pXG4gIGRlY29kZXIucG9zICs9IGxlblxuICByZXR1cm4gdmlld1xufVxuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclVpbnQ4QXJyYXkgPSBkZWNvZGVyID0+IHJlYWRVaW50OEFycmF5KGRlY29kZXIsIHJlYWRWYXJVaW50KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQgYXMgYW4gQXJyYXlCdWZmZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFRhaWxBc1VpbnQ4QXJyYXkgPSBkZWNvZGVyID0+IHJlYWRVaW50OEFycmF5KGRlY29kZXIsIGRlY29kZXIuYXJyLmxlbmd0aCAtIGRlY29kZXIucG9zKVxuXG4vKipcbiAqIFNraXAgb25lIGJ5dGUsIGp1bXAgdG8gdGhlIG5leHQgcG9zaXRpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2tpcDggPSBkZWNvZGVyID0+IGRlY29kZXIucG9zKytcblxuLyoqXG4gKiBSZWFkIG9uZSBieXRlIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG5cbi8qKlxuICogUmVhZCAyIGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MTYgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KVxuICBkZWNvZGVyLnBvcyArPSAyXG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogUmVhZCA0IGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MzIgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMV0gPDwgOCkgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgM10gPDwgMjQpKSA+Pj4gMFxuICBkZWNvZGVyLnBvcyArPSA0XG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogUmVhZCA0IGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnIGVuZGlhbiBvcmRlci5cbiAqIChtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3QpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MzJCaWdFbmRpYW4gPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgM10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDgpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCAxNikgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gPDwgMjQpKSA+Pj4gMFxuICBkZWNvZGVyLnBvcyArPSA0XG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyB0aGUgcG9zaXRpb25cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcGVla1VpbnQ4ID0gZGVjb2RlciA9PiBkZWNvZGVyLmFycltkZWNvZGVyLnBvc11cblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHRoZSBwb3NpdGlvblxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVWludDE2ID0gZGVjb2RlciA9PlxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KVxuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgdGhlIHBvc2l0aW9uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtVaW50MzIgPSBkZWNvZGVyID0+IChcbiAgZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMV0gPDwgOCkgK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAyXSA8PCAxNikgK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSA8PCAyNClcbikgPj4+IDBcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRWYXJVaW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCBudW0gPSAwXG4gIGxldCBsZW4gPSAwXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gICAgbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbGVuICs9IDdcbiAgICBpZiAociA8IGJpbmFyeS5CSVQ4KSB7XG4gICAgICByZXR1cm4gbnVtID4+PiAwIC8vIHJldHVybiB1bnNpZ25lZCBudW1iZXIhXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChsZW4gPiAzNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VyIG91dCBvZiByYW5nZSEnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlYWQgc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKiBAdG9kbyBUaGlzIHNob3VsZCBwcm9iYWJseSBjcmVhdGUgdGhlIGludmVyc2Ugfm51bSBpZiBudW1iZXIgaXMgbmVnYXRpdmUgLSBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhckludCA9IGRlY29kZXIgPT4ge1xuICBsZXQgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gIGxldCBudW0gPSByICYgYmluYXJ5LkJJVFM2XG4gIGxldCBsZW4gPSA2XG4gIGNvbnN0IHNpZ24gPSAociAmIGJpbmFyeS5CSVQ3KSA+IDAgPyAtMSA6IDFcbiAgaWYgKChyICYgYmluYXJ5LkJJVDgpID09PSAwKSB7XG4gICAgLy8gZG9uJ3QgY29udGludWUgcmVhZGluZ1xuICAgIHJldHVybiBzaWduICogbnVtXG4gIH1cbiAgd2hpbGUgKHRydWUpIHtcbiAgICByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgICBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBsZW4gKz0gN1xuICAgIGlmIChyIDwgYmluYXJ5LkJJVDgpIHtcbiAgICAgIHJldHVybiBzaWduICogKG51bSA+Pj4gMClcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGxlbiA+IDQxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgb3V0IG9mIHJhbmdlIScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJVaW50IHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtWYXJVaW50ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFyVWludChkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyVWludCB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFySW50KGRlY29kZXIpXG4gIGRlY29kZXIucG9zID0gcG9zXG4gIHJldHVybiBzXG59XG5cbi8qKlxuICogUmVhZCBzdHJpbmcgb2YgdmFyaWFibGUgbGVuZ3RoXG4gKiAqIHZhclVpbnQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAqXG4gKiBUcmFuc2Zvcm1pbmcgdXRmOCB0byBhIHN0cmluZyBpcyBwcmV0dHkgZXhwZW5zaXZlLiBUaGUgY29kZSBwZXJmb3JtcyAxMHggYmV0dGVyXG4gKiB3aGVuIFN0cmluZy5mcm9tQ29kZVBvaW50IGlzIGZlZCB3aXRoIGFsbCBjaGFyYWN0ZXJzIGFzIGFyZ3VtZW50cy5cbiAqIEJ1dCBtb3N0IGVudmlyb25tZW50cyBoYXZlIGEgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHBlciBmdW5jdGlvbnMuXG4gKiBGb3IgZWZmaWVuY3kgcmVhc29ucyB3ZSBhcHBseSBhIG1heGltdW0gb2YgMTAwMDAgY2hhcmFjdGVycyBhdCBvbmNlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRWYXJTdHJpbmcgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGlmIChyZW1haW5pbmdMZW4gPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW5jb2RlZFN0cmluZyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSkgLy8gcmVtZW1iZXIgdG8gZGVjcmVhc2UgcmVtYWluaW5nTGVuXG4gICAgaWYgKC0tcmVtYWluaW5nTGVuIDwgMTAwKSB7IC8vIGRvIG5vdCBjcmVhdGUgYSBVaW50OEFycmF5IGZvciBzbWFsbCBzdHJpbmdzXG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuLS0pIHtcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwXG4gICAgICAgIC8vIHRoaXMgaXMgZGFuZ2Vyb3VzLCB3ZSBjcmVhdGUgYSBmcmVzaCBhcnJheSB2aWV3IGZyb20gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgICAgICBjb25zdCBieXRlcyA9IGRlY29kZXIuYXJyLnN1YmFycmF5KGRlY29kZXIucG9zLCBkZWNvZGVyLnBvcyArIG5leHRMZW4pXG4gICAgICAgIGRlY29kZXIucG9zICs9IG5leHRMZW5cbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSlcbiAgICAgICAgcmVtYWluaW5nTGVuIC09IG5leHRMZW5cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG4gIH1cbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclN0cmluZyB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVmFyU3RyaW5nID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gIGRlY29kZXIucG9zID0gcG9zXG4gIHJldHVybiBzXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcmV0dXJuIHtEYXRhVmlld31cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRGcm9tRGF0YVZpZXcgPSAoZGVjb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5hcnIuYnl0ZU9mZnNldCArIGRlY29kZXIucG9zLCBsZW4pXG4gIGRlY29kZXIucG9zICs9IGxlblxuICByZXR1cm4gZHZcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRGbG9hdDMyID0gZGVjb2RlciA9PiByZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDQpLmdldEZsb2F0MzIoMCwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRmxvYXQ2NCA9IGRlY29kZXIgPT4gcmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA4KS5nZXRGbG9hdDY0KDAsIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEJpZ0ludDY0ID0gZGVjb2RlciA9PiAvKiogQHR5cGUge2FueX0gKi8gKHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkpLmdldEJpZ0ludDY0KDAsIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEJpZ1VpbnQ2NCA9IGRlY29kZXIgPT4gLyoqIEB0eXBlIHthbnl9ICovIChyZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDgpKS5nZXRCaWdVaW50NjQoMCwgZmFsc2UpXG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKERlY29kZXIpOmFueT59XG4gKi9cbmNvbnN0IHJlYWRBbnlMb29rdXBUYWJsZSA9IFtcbiAgZGVjb2RlciA9PiB1bmRlZmluZWQsIC8vIENBU0UgMTI3OiB1bmRlZmluZWRcbiAgZGVjb2RlciA9PiBudWxsLCAvLyBDQVNFIDEyNjogbnVsbFxuICByZWFkVmFySW50LCAvLyBDQVNFIDEyNTogaW50ZWdlclxuICByZWFkRmxvYXQzMiwgLy8gQ0FTRSAxMjQ6IGZsb2F0MzJcbiAgcmVhZEZsb2F0NjQsIC8vIENBU0UgMTIzOiBmbG9hdDY0XG4gIHJlYWRCaWdJbnQ2NCwgLy8gQ0FTRSAxMjI6IGJpZ2ludFxuICBkZWNvZGVyID0+IGZhbHNlLCAvLyBDQVNFIDEyMTogYm9vbGVhbiAoZmFsc2UpXG4gIGRlY29kZXIgPT4gdHJ1ZSwgLy8gQ0FTRSAxMjA6IGJvb2xlYW4gKHRydWUpXG4gIHJlYWRWYXJTdHJpbmcsIC8vIENBU0UgMTE5OiBzdHJpbmdcbiAgZGVjb2RlciA9PiB7IC8vIENBU0UgMTE4OiBvYmplY3Q8c3RyaW5nLGFueT5cbiAgICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICovXG4gICAgY29uc3Qgb2JqID0ge31cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gICAgICBvYmpba2V5XSA9IHJlYWRBbnkoZGVjb2RlcilcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9LFxuICBkZWNvZGVyID0+IHsgLy8gQ0FTRSAxMTc6IGFycmF5PGFueT5cbiAgICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyLnB1c2gocmVhZEFueShkZWNvZGVyKSlcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9LFxuICByZWFkVmFyVWludDhBcnJheSAvLyBDQVNFIDExNjogVWludDhBcnJheVxuXVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEFueSA9IGRlY29kZXIgPT4gcmVhZEFueUxvb2t1cFRhYmxlWzEyNyAtIHJlYWRVaW50OChkZWNvZGVyKV0oZGVjb2RlcilcblxuLyoqXG4gKiBUIG11c3Qgbm90IGJlIG51bGwuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGNsYXNzIFJsZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKERlY29kZXIpOlR9IHJlYWRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXksIHJlYWRlcikge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogVGhlIHJlYWRlclxuICAgICAqL1xuICAgIHRoaXMucmVhZGVyID0gcmVhZGVyXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtUfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zID0gbnVsbFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zID0gdGhpcy5yZWFkZXIodGhpcylcbiAgICAgIGlmIChoYXNDb250ZW50KHRoaXMpKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDEgLy8gc2VlIGVuY29kZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZWFzb24gd2h5IHRoaXMgaXMgaW5jcmVtZW50ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAtMSAvLyByZWFkIHRoZSBjdXJyZW50IHZhbHVlIGZvcmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7VH0gKi8gKHRoaXMucylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW50RGlmZkRlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCBzdGFydCkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICB0aGlzLnMgKz0gcmVhZFZhckludCh0aGlzKVxuICAgIHJldHVybiB0aGlzLnNcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmxlSW50RGlmZkRlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCBzdGFydCkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgKz0gcmVhZFZhckludCh0aGlzKVxuICAgICAgaWYgKGhhc0NvbnRlbnQodGhpcykpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMSAvLyBzZWUgZW5jb2RlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBpbmNyZW1lbnRlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IC0xIC8vIHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUgZm9yZXZlclxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVpbnRPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBzaWduIGlzIG5lZ2F0aXZlLCB3ZSByZWFkIHRoZSBjb3VudCB0b28sIG90aGVyd2lzZSBjb3VudCBpcyAxXG4gICAgICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyh0aGlzLnMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zID0gLXRoaXMuc1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW5jVWludE9wdFJsZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zID0gcmVhZFZhckludCh0aGlzKVxuICAgICAgLy8gaWYgdGhlIHNpZ24gaXMgbmVnYXRpdmUsIHdlIHJlYWQgdGhlIGNvdW50IHRvbywgb3RoZXJ3aXNlIGNvdW50IGlzIDFcbiAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBtYXRoLmlzTmVnYXRpdmVaZXJvKHRoaXMucylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICB0aGlzLnMgPSAtdGhpcy5zXG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKyspXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludERpZmZPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICAgIHRoaXMuZGlmZiA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgY29uc3QgZGlmZiA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBmaXJzdCBiaXQgaXMgc2V0LCB3ZSByZWFkIG1vcmUgZGF0YVxuICAgICAgY29uc3QgaGFzQ291bnQgPSBkaWZmICYgMVxuICAgICAgdGhpcy5kaWZmID0gZGlmZiA+PiAxXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgaWYgKGhhc0NvdW50KSB7XG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zICs9IHRoaXMuZGlmZlxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiB0aGlzLnNcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3RyaW5nRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFVpbnRPcHRSbGVEZWNvZGVyKHVpbnQ4QXJyYXkpXG4gICAgdGhpcy5zdHIgPSByZWFkVmFyU3RyaW5nKHRoaXMuZGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3BvcyA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICBjb25zdCBlbmQgPSB0aGlzLnNwb3MgKyB0aGlzLmRlY29kZXIucmVhZCgpXG4gICAgY29uc3QgcmVzID0gdGhpcy5zdHIuc2xpY2UodGhpcy5zcG9zLCBlbmQpXG4gICAgdGhpcy5zcG9zID0gZW5kXG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/decoding.js\n')},"./node_modules/lib0/dom.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doc": () => (/* binding */ doc),\n/* harmony export */   "createElement": () => (/* binding */ createElement),\n/* harmony export */   "createDocumentFragment": () => (/* binding */ createDocumentFragment),\n/* harmony export */   "createTextNode": () => (/* binding */ createTextNode),\n/* harmony export */   "domParser": () => (/* binding */ domParser),\n/* harmony export */   "emitCustomEvent": () => (/* binding */ emitCustomEvent),\n/* harmony export */   "setAttributes": () => (/* binding */ setAttributes),\n/* harmony export */   "setAttributesMap": () => (/* binding */ setAttributesMap),\n/* harmony export */   "fragment": () => (/* binding */ fragment),\n/* harmony export */   "append": () => (/* binding */ append),\n/* harmony export */   "remove": () => (/* binding */ remove),\n/* harmony export */   "addEventListener": () => (/* binding */ addEventListener),\n/* harmony export */   "removeEventListener": () => (/* binding */ removeEventListener),\n/* harmony export */   "addEventListeners": () => (/* binding */ addEventListeners),\n/* harmony export */   "removeEventListeners": () => (/* binding */ removeEventListeners),\n/* harmony export */   "element": () => (/* binding */ element),\n/* harmony export */   "canvas": () => (/* binding */ canvas),\n/* harmony export */   "text": () => (/* binding */ text),\n/* harmony export */   "pairToStyleString": () => (/* binding */ pairToStyleString),\n/* harmony export */   "pairsToStyleString": () => (/* binding */ pairsToStyleString),\n/* harmony export */   "mapToStyleString": () => (/* binding */ mapToStyleString),\n/* harmony export */   "querySelector": () => (/* binding */ querySelector),\n/* harmony export */   "querySelectorAll": () => (/* binding */ querySelectorAll),\n/* harmony export */   "getElementById": () => (/* binding */ getElementById),\n/* harmony export */   "parseFragment": () => (/* binding */ parseFragment),\n/* harmony export */   "parseElement": () => (/* binding */ parseElement),\n/* harmony export */   "replaceWith": () => (/* binding */ replaceWith),\n/* harmony export */   "insertBefore": () => (/* binding */ insertBefore),\n/* harmony export */   "appendChild": () => (/* binding */ appendChild),\n/* harmony export */   "ELEMENT_NODE": () => (/* binding */ ELEMENT_NODE),\n/* harmony export */   "TEXT_NODE": () => (/* binding */ TEXT_NODE),\n/* harmony export */   "CDATA_SECTION_NODE": () => (/* binding */ CDATA_SECTION_NODE),\n/* harmony export */   "COMMENT_NODE": () => (/* binding */ COMMENT_NODE),\n/* harmony export */   "DOCUMENT_NODE": () => (/* binding */ DOCUMENT_NODE),\n/* harmony export */   "DOCUMENT_TYPE_NODE": () => (/* binding */ DOCUMENT_TYPE_NODE),\n/* harmony export */   "DOCUMENT_FRAGMENT_NODE": () => (/* binding */ DOCUMENT_FRAGMENT_NODE),\n/* harmony export */   "checkNodeType": () => (/* binding */ checkNodeType),\n/* harmony export */   "isParentOf": () => (/* binding */ isParentOf)\n/* harmony export */ });\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pair.js */ "./node_modules/lib0/pair.js");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ "./node_modules/lib0/map.js");\n/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\n\n\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nconst doc = /** @type {Document} */ (typeof document !== \'undefined\' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nconst createTextNode = text => doc.createTextNode(text)\n\n/* istanbul ignore next */\nconst domParser = /** @type {DOMParser} */ (typeof DOMParser !== \'undefined\' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nconst emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributes = (el, attrs) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, \'\')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nconst append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nconst remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst addEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst removeEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nconst element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nconst canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement(\'canvas\'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nconst text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nconst pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nconst pairsToStyleString = pairs => pairs.map(pairToStyleString).join(\'\')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nconst mapToStyleString = m => _map_js__WEBPACK_IMPORTED_MODULE_1__.map(m, (value, key) => `${key}:${value};`).join(\'\')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nconst querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nconst querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, \'text/html\').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nconst replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nconst appendChild = (parent, child) => parent.appendChild(child)\n\nconst ELEMENT_NODE = doc.ELEMENT_NODE\nconst TEXT_NODE = doc.TEXT_NODE\nconst CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nconst COMMENT_NODE = doc.COMMENT_NODE\nconst DOCUMENT_NODE = doc.DOCUMENT_NODE\nconst DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nconst DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nconst checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nconst isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2RvbS5qcz9iNmY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNGOztBQUUvQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ08sdUJBQXVCLFNBQVMsb0RBQW9EOztBQUUzRjtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ08sNkJBQTZCLFVBQVU7O0FBRTlDO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0NBQXdDO0FBQ25ELFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUCxFQUFFLDZDQUFZO0FBQ2Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG9CQUFvQjtBQUMvQixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLDhCQUE4QjtBQUMvRDtBQUNBOztBQUVBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyx1Q0FBdUM7QUFDbEQsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQLEVBQUUsNkNBQVk7QUFDZDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsdUNBQXVDO0FBQ2xELFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUCxFQUFFLDZDQUFZO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLDBEQUEwRDtBQUNyRSxXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ087QUFDUCx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ08scUNBQXFDLFVBQVUsR0FBRyxZQUFZOztBQUVyRTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1o7QUFDQTtBQUNPLDhCQUE4Qix3Q0FBTyx1QkFBdUIsSUFBSSxHQUFHLE9BQU87O0FBRWpGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTyx3Q0FBd0MsWUFBWTs7QUFFM0Q7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxnRUFBZ0UsS0FBSzs7QUFFckU7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTyxrREFBa0QsSUFBSTs7QUFFN0Q7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxPQUFPO0FBQ2xCO0FBQ087O0FBRVA7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kb20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBAbW9kdWxlIGRvbVxuICovXG5cbmltcG9ydCAqIGFzIHBhaXIgZnJvbSAnLi9wYWlyLmpzJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAdHlwZSB7RG9jdW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge30pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSBuYW1lID0+IGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpXG5cbi8qKlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gKCkgPT4gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtUZXh0fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRleHROb2RlID0gdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dClcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBkb21QYXJzZXIgPSAvKiogQHR5cGUge0RPTVBhcnNlcn0gKi8gKHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IERPTVBhcnNlcigpIDogbnVsbClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZW1pdEN1c3RvbUV2ZW50ID0gKGVsLCBuYW1lLCBvcHRzKSA9PiBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCBvcHRzKSlcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nfGJvb2xlYW4+Pn0gYXR0cnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHNldEF0dHJpYnV0ZXMgPSAoZWwsIGF0dHJzKSA9PiB7XG4gIHBhaXIuZm9yRWFjaChhdHRycywgKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksICcnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nPn0gYXR0cnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHNldEF0dHJpYnV0ZXNNYXAgPSAoZWwsIGF0dHJzKSA9PiB7XG4gIGF0dHJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHsgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIH0pXG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT58SFRNTENvbGxlY3Rpb259IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGZyYWdtZW50ID0gY2hpbGRyZW4gPT4ge1xuICBjb25zdCBmcmFnbWVudCA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kQ2hpbGQoZnJhZ21lbnQsIGNoaWxkcmVuW2ldKVxuICB9XG4gIHJldHVybiBmcmFnbWVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBhcHBlbmQgPSAocGFyZW50LCBub2RlcykgPT4ge1xuICBhcHBlbmRDaGlsZChwYXJlbnQsIGZyYWdtZW50KG5vZGVzKSlcbiAgcmV0dXJuIHBhcmVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcmVtb3ZlID0gZWwgPT4gZWwucmVtb3ZlKClcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gZlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50TGlzdGVuZXIgPSAoZWwsIG5hbWUsIGYpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZilcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gZlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoZWwsIG5hbWUsIGYpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZilcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxFdmVudExpc3RlbmVyPj59IGxpc3RlbmVyc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBhZGRFdmVudExpc3RlbmVycyA9IChub2RlLCBsaXN0ZW5lcnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGxpc3RlbmVycywgKG5hbWUsIGYpID0+IGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgZikpXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsRXZlbnRMaXN0ZW5lcj4+fSBsaXN0ZW5lcnNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSAobm9kZSwgbGlzdGVuZXJzKSA9PiB7XG4gIHBhaXIuZm9yRWFjaChsaXN0ZW5lcnMsIChuYW1lLCBmKSA9PiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIG5hbWUsIGYpKVxuICByZXR1cm4gbm9kZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPnxwYWlyLlBhaXI8c3RyaW5nLGJvb2xlYW4+Pn0gYXR0cnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBjaGlsZHJlblxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBlbGVtZW50ID0gKG5hbWUsIGF0dHJzID0gW10sIGNoaWxkcmVuID0gW10pID0+XG4gIGFwcGVuZChzZXRBdHRyaWJ1dGVzKGNyZWF0ZUVsZW1lbnQobmFtZSksIGF0dHJzKSwgY2hpbGRyZW4pXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY2FudmFzID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgY29uc3QgYyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChjcmVhdGVFbGVtZW50KCdjYW52YXMnKSlcbiAgYy5oZWlnaHQgPSBoZWlnaHRcbiAgYy53aWR0aCA9IHdpZHRoXG4gIHJldHVybiBjXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRcbiAqIEByZXR1cm4ge1RleHR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdGV4dCA9IGNyZWF0ZVRleHROb2RlXG5cbi8qKlxuICogQHBhcmFtIHtwYWlyLlBhaXI8c3RyaW5nLHN0cmluZz59IHBhaXJcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwYWlyVG9TdHlsZVN0cmluZyA9IHBhaXIgPT4gYCR7cGFpci5sZWZ0fToke3BhaXIucmlnaHR9O2BcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPj59IHBhaXJzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcGFpcnNUb1N0eWxlU3RyaW5nID0gcGFpcnMgPT4gcGFpcnMubWFwKHBhaXJUb1N0eWxlU3RyaW5nKS5qb2luKCcnKVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxzdHJpbmc+fSBtXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgbWFwVG9TdHlsZVN0cmluZyA9IG0gPT4gbWFwLm1hcChtLCAodmFsdWUsIGtleSkgPT4gYCR7a2V5fToke3ZhbHVlfTtgKS5qb2luKCcnKVxuXG4vKipcbiAqIEB0b2RvIHNob3VsZCBhbHdheXMgcXVlcnkgb24gYSBkb20gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U2hhZG93Um9vdH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuICogQHJldHVybiB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5U2VsZWN0b3IgPSAoZWwsIHF1ZXJ5KSA9PiBlbC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U2hhZG93Um9vdH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuICogQHJldHVybiB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcXVlcnlTZWxlY3RvckFsbCA9IChlbCwgcXVlcnkpID0+IGVsLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRFbGVtZW50QnlJZCA9IGlkID0+IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IF9wYXJzZSA9IGh0bWwgPT4gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyhgPGh0bWw+PGJvZHk+JHtodG1sfTwvYm9keT48L2h0bWw+YCwgJ3RleHQvaHRtbCcpLmJvZHlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwYXJzZUZyYWdtZW50ID0gaHRtbCA9PiBmcmFnbWVudCgvKiogQHR5cGUge2FueX0gKi8gKF9wYXJzZShodG1sKS5jaGlsZE5vZGVzKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcGFyc2VFbGVtZW50ID0gaHRtbCA9PiAvKiogQHR5cGUgSFRNTEVsZW1lbnQgKi8gKF9wYXJzZShodG1sKS5maXJzdEVsZW1lbnRDaGlsZClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvbGRFbFxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBuZXdFbFxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2VXaXRoID0gKG9sZEVsLCBuZXdFbCkgPT4gb2xkRWwucmVwbGFjZVdpdGgobmV3RWwpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtOb2RlfG51bGx9IHJlZlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaW5zZXJ0QmVmb3JlID0gKHBhcmVudCwgZWwsIHJlZikgPT4gcGFyZW50Lmluc2VydEJlZm9yZShlbCwgcmVmKVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge05vZGV9IGNoaWxkXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZENoaWxkID0gKHBhcmVudCwgY2hpbGQpID0+IHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZClcblxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfTk9ERSA9IGRvYy5FTEVNRU5UX05PREVcbmV4cG9ydCBjb25zdCBURVhUX05PREUgPSBkb2MuVEVYVF9OT0RFXG5leHBvcnQgY29uc3QgQ0RBVEFfU0VDVElPTl9OT0RFID0gZG9jLkNEQVRBX1NFQ1RJT05fTk9ERVxuZXhwb3J0IGNvbnN0IENPTU1FTlRfTk9ERSA9IGRvYy5DT01NRU5UX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9OT0RFID0gZG9jLkRPQ1VNRU5UX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9UWVBFX05PREUgPSBkb2MuRE9DVU1FTlRfVFlQRV9OT0RFXG5leHBvcnQgY29uc3QgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IGRvYy5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja05vZGVUeXBlID0gKG5vZGUsIHR5cGUpID0+IG5vZGUubm9kZVR5cGUgPT09IHR5cGVcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUGFyZW50T2YgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICBsZXQgcCA9IGNoaWxkLnBhcmVudE5vZGVcbiAgd2hpbGUgKHAgJiYgcCAhPT0gcGFyZW50KSB7XG4gICAgcCA9IHAucGFyZW50Tm9kZVxuICB9XG4gIHJldHVybiBwID09PSBwYXJlbnRcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dom.js\n')},"./node_modules/lib0/encoding.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Encoder": () => (/* binding */ Encoder),\n/* harmony export */   "createEncoder": () => (/* binding */ createEncoder),\n/* harmony export */   "length": () => (/* binding */ length),\n/* harmony export */   "toUint8Array": () => (/* binding */ toUint8Array),\n/* harmony export */   "write": () => (/* binding */ write),\n/* harmony export */   "set": () => (/* binding */ set),\n/* harmony export */   "writeUint8": () => (/* binding */ writeUint8),\n/* harmony export */   "setUint8": () => (/* binding */ setUint8),\n/* harmony export */   "writeUint16": () => (/* binding */ writeUint16),\n/* harmony export */   "setUint16": () => (/* binding */ setUint16),\n/* harmony export */   "writeUint32": () => (/* binding */ writeUint32),\n/* harmony export */   "writeUint32BigEndian": () => (/* binding */ writeUint32BigEndian),\n/* harmony export */   "setUint32": () => (/* binding */ setUint32),\n/* harmony export */   "writeVarUint": () => (/* binding */ writeVarUint),\n/* harmony export */   "writeVarInt": () => (/* binding */ writeVarInt),\n/* harmony export */   "writeVarString": () => (/* binding */ writeVarString),\n/* harmony export */   "writeBinaryEncoder": () => (/* binding */ writeBinaryEncoder),\n/* harmony export */   "writeUint8Array": () => (/* binding */ writeUint8Array),\n/* harmony export */   "writeVarUint8Array": () => (/* binding */ writeVarUint8Array),\n/* harmony export */   "writeOnDataView": () => (/* binding */ writeOnDataView),\n/* harmony export */   "writeFloat32": () => (/* binding */ writeFloat32),\n/* harmony export */   "writeFloat64": () => (/* binding */ writeFloat64),\n/* harmony export */   "writeBigInt64": () => (/* binding */ writeBigInt64),\n/* harmony export */   "writeBigUint64": () => (/* binding */ writeBigUint64),\n/* harmony export */   "writeAny": () => (/* binding */ writeAny),\n/* harmony export */   "RleEncoder": () => (/* binding */ RleEncoder),\n/* harmony export */   "IntDiffEncoder": () => (/* binding */ IntDiffEncoder),\n/* harmony export */   "RleIntDiffEncoder": () => (/* binding */ RleIntDiffEncoder),\n/* harmony export */   "UintOptRleEncoder": () => (/* binding */ UintOptRleEncoder),\n/* harmony export */   "IncUintOptRleEncoder": () => (/* binding */ IncUintOptRleEncoder),\n/* harmony export */   "IntDiffOptRleEncoder": () => (/* binding */ IntDiffOptRleEncoder),\n/* harmony export */   "StringEncoder": () => (/* binding */ StringEncoder)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/lib0/buffer.js");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./number.js */ "./node_modules/lib0/number.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary.js */ "./node_modules/lib0/binary.js");\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang\'s binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, \'Hello world!\')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => \'Hello world!\'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n\n\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nconst set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint16 = (encoder, num) => {\n  write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  write(encoder, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) {\n    write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don\'t use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarInt = (encoder, num) => {\n  const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_1__.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (isNegative ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 & num))\n  num >>>= 6\n  // We don\'t need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nconst writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = _math_js__WEBPACK_IMPORTED_MODULE_1__.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nconst writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can\'t be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nconst writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case \'string\':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case \'number\':\n      if (_number_js__WEBPACK_IMPORTED_MODULE_3__.isInteger(data) && data <= _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case \'bigint\':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case \'object\':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case \'boolean\':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nclass RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nclass IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nclass RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  /* istanbul ignore else */\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nclass UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nclass IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nclass IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nclass StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = \'\'\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = \'\'\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = \'\'\n    writeVarString(encoder, this.sarr.join(\'\'))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2VuY29kaW5nLmpzP2RiZGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNKO0FBQ0k7QUFDQTs7QUFFckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkVBQTBDO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJFQUEwQztBQUNoRSxrQ0FBa0MseUNBQVE7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZW5jb2RpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZW5jb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2VuY29kaW5nXSB3aXRoIFtsaWIwL2RlY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gbmV3IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IG5ldyBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnLi9idWZmZXIuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIG51bWJlciBmcm9tICcuL251bWJlci5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcblxuLyoqXG4gKiBBIEJpbmFyeUVuY29kZXIgaGFuZGxlcyB0aGUgZW5jb2RpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jcG9zID0gMFxuICAgIHRoaXMuY2J1ZiA9IG5ldyBVaW50OEFycmF5KDEwMClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VWludDhBcnJheT59XG4gICAgICovXG4gICAgdGhpcy5idWZzID0gW11cbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7RW5jb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVuY29kZXIgPSAoKSA9PiBuZXcgRW5jb2RlcigpXG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBlbmNvZGVkIGRhdGEuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IGVuY29kZXIgPT4ge1xuICBsZXQgbGVuID0gZW5jb2Rlci5jcG9zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGVuICs9IGVuY29kZXIuYnVmc1tpXS5sZW5ndGhcbiAgfVxuICByZXR1cm4gbGVuXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRvIFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IFRoZSBjcmVhdGVkIEFycmF5QnVmZmVyLlxuICovXG5leHBvcnQgY29uc3QgdG9VaW50OEFycmF5ID0gZW5jb2RlciA9PiB7XG4gIGNvbnN0IHVpbnQ4YXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKGVuY29kZXIpKVxuICBsZXQgY3VyUG9zID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGQgPSBlbmNvZGVyLmJ1ZnNbaV1cbiAgICB1aW50OGFyci5zZXQoZCwgY3VyUG9zKVxuICAgIGN1clBvcyArPSBkLmxlbmd0aFxuICB9XG4gIHVpbnQ4YXJyLnNldChidWZmZXIuY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIoZW5jb2Rlci5jYnVmLmJ1ZmZlciwgMCwgZW5jb2Rlci5jcG9zKSwgY3VyUG9zKVxuICByZXR1cm4gdWludDhhcnJcbn1cblxuLyoqXG4gKiBWZXJpZnkgdGhhdCBpdCBpcyBwb3NzaWJsZSB0byB3cml0ZSBgbGVuYCBieXRlcyB3dGlob3V0IGNoZWNraW5nLiBJZlxuICogbmVjZXNzYXJ5LCBhIG5ldyBCdWZmZXIgd2l0aCB0aGUgcmVxdWlyZWQgbGVuZ3RoIGlzIGF0dGFjaGVkLlxuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICovXG5jb25zdCB2ZXJpZnlMZW4gPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGJ1ZmZlckxlbiAtIGVuY29kZXIuY3BvcyA8IGxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcihlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpKVxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1hdGgubWF4KGJ1ZmZlckxlbiwgbGVuKSAqIDIpXG4gICAgZW5jb2Rlci5jcG9zID0gMFxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGJ5dGUgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGUgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGVuY29kZXIuY3BvcyA9PT0gYnVmZmVyTGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKVxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbiAqIDIpXG4gICAgZW5jb2Rlci5jcG9zID0gMFxuICB9XG4gIGVuY29kZXIuY2J1ZltlbmNvZGVyLmNwb3MrK10gPSBudW1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICogUG9zaXRpb24gbXVzdCBhbHJlYWR5IGJlIHdyaXR0ZW4gKGkuZS4gZW5jb2Rlci5sZW5ndGggPiBwb3MpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb24gdG8gd2hpY2ggdG8gd3JpdGUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgbGV0IGJ1ZmZlciA9IG51bGxcbiAgLy8gaXRlcmF0ZSBhbGwgYnVmZmVycyBhbmQgYWRqdXN0IHBvc2l0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aCAmJiBidWZmZXIgPT09IG51bGw7IGkrKykge1xuICAgIGNvbnN0IGIgPSBlbmNvZGVyLmJ1ZnNbaV1cbiAgICBpZiAocG9zIDwgYi5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlciA9IGIgLy8gZm91bmQgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyAtPSBiLmxlbmd0aFxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyID09PSBudWxsKSB7XG4gICAgLy8gdXNlIGN1cnJlbnQgYnVmZmVyXG4gICAgYnVmZmVyID0gZW5jb2Rlci5jYnVmXG4gIH1cbiAgYnVmZmVyW3Bvc10gPSBudW1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50OCA9IHdyaXRlXG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgYXMgYW4gdW5zaWduZWQgSW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDggPSBzZXRcblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDE2ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3cml0ZShlbmNvZGVyLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gIHdyaXRlKGVuY29kZXIsIChudW0gPj4+IDgpICYgYmluYXJ5LkJJVFM4KVxufVxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDE2ID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIHNldChlbmNvZGVyLCBwb3MsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgc2V0KGVuY29kZXIsIHBvcyArIDEsIChudW0gPj4+IDgpICYgYmluYXJ5LkJJVFM4KVxufVxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQzMiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB3cml0ZShlbmNvZGVyLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gICAgbnVtID4+Pj0gOFxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnIGVuZGlhbiBvcmRlci5cbiAqIChtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3QpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQzMkJpZ0VuZGlhbiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgKG51bSA+Pj4gKDggKiBpKSkgJiBiaW5hcnkuQklUUzgpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDMyID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2V0KGVuY29kZXIsIHBvcyArIGksIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgICBudW0gPj4+PSA4XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEVuY29kZXMgaW50ZWdlcnMgaW4gdGhlIHJhbmdlIGZyb20gWzAsIDQyOTQ5NjcyOTVdIC8gWzAsIDB4ZmZmZmZmZmZdLiAobWF4IDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2VyKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3aGlsZSAobnVtID4gYmluYXJ5LkJJVFM3KSB7XG4gICAgd3JpdGUoZW5jb2RlciwgYmluYXJ5LkJJVDggfCAoYmluYXJ5LkJJVFM3ICYgbnVtKSlcbiAgICBudW0gPj4+PSA3XG4gIH1cbiAgd3JpdGUoZW5jb2RlciwgYmluYXJ5LkJJVFM3ICYgbnVtKVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIuXG4gKlxuICogRW5jb2RlcyBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgZnJvbSBbLTIxNDc0ODM2NDgsIC0yMTQ3NDgzNjQ3XS5cbiAqXG4gKiBXZSBkb24ndCB1c2UgemlnLXphZyBlbmNvZGluZyBiZWNhdXNlIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3B0aW9uIG9wZW5cbiAqIHRvIHVzZSB0aGUgc2FtZSBmdW5jdGlvbiBmb3IgQmlnSW50IGFuZCA1M2JpdCBpbnRlZ2VycyAoZG91YmxlcykuXG4gKlxuICogV2UgdXNlIHRoZSA3dGggYml0IGluc3RlYWQgZm9yIHNpZ25hbGluZyB0aGF0IHRoaXMgaXMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhckludCA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8obnVtKVxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIG51bSA9IC1udW1cbiAgfVxuICAvLyAgICAgICAgICAgICB8LSB3aGV0aGVyIHRvIGNvbnRpbnVlIHJlYWRpbmcgICAgICAgICB8LSB3aGV0aGVyIGlzIG5lZ2F0aXZlICAgICB8LSBudW1iZXJcbiAgd3JpdGUoZW5jb2RlciwgKG51bSA+IGJpbmFyeS5CSVRTNiA/IGJpbmFyeS5CSVQ4IDogMCkgfCAoaXNOZWdhdGl2ZSA/IGJpbmFyeS5CSVQ3IDogMCkgfCAoYmluYXJ5LkJJVFM2ICYgbnVtKSlcbiAgbnVtID4+Pj0gNlxuICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBjYXNlIG9mIG51bSA9PT0gMCBzbyB3ZSBjYW4gdXNlIGEgZGlmZmVyZW50XG4gIC8vIHBhdHRlcm4gaGVyZSB0aGFuIGFib3ZlLlxuICB3aGlsZSAobnVtID4gMCkge1xuICAgIHdyaXRlKGVuY29kZXIsIChudW0gPiBiaW5hcnkuQklUUzcgPyBiaW5hcnkuQklUOCA6IDApIHwgKGJpbmFyeS5CSVRTNyAmIG51bSkpXG4gICAgbnVtID4+Pj0gN1xuICB9XG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJTdHJpbmcgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSlcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGhcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSkpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0aGUgY29udGVudCBvZiBhbm90aGVyIEVuY29kZXIuXG4gKlxuICogQFRPRE86IGNhbiBiZSBpbXByb3ZlZCFcbiAqICAgICAgICAtIE5vdGU6IFNob3VsZCBjb25zaWRlciB0aGF0IHdoZW4gYXBwZW5kaW5nIGEgbG90IG9mIHNtYWxsIEVuY29kZXJzLCB3ZSBzaG91bGQgcmF0aGVyIGNsb25lIHRoYW4gcmVmZXJlbmNpbmcgdGhlIG9sZCBzdHJ1Y3R1cmUuXG4gKiAgICAgICAgICAgICAgICBFbmNvZGVycyBzdGFydCB3aXRoIGEgcmF0aGVyIGJpZyBpbml0aWFsIGJ1ZmZlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciBUaGUgZW5VaW50OEFyclxuICogQHBhcmFtIHtFbmNvZGVyfSBhcHBlbmQgVGhlIEJpbmFyeUVuY29kZXIgdG8gYmUgd3JpdHRlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQmluYXJ5RW5jb2RlciA9IChlbmNvZGVyLCBhcHBlbmQpID0+IHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkoYXBwZW5kKSlcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zXG4gIGNvbnN0IGxlZnRDb3B5TGVuID0gbWF0aC5taW4oYnVmZmVyTGVuIC0gY3BvcywgdWludDhBcnJheS5sZW5ndGgpXG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW5cbiAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KDAsIGxlZnRDb3B5TGVuKSwgY3BvcylcbiAgZW5jb2Rlci5jcG9zICs9IGxlZnRDb3B5TGVuXG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1ZilcbiAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgc2l6ZSBvZiByZW1haW5pbmcgYnVmZmVyXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5tYXgoYnVmZmVyTGVuICogMiwgcmlnaHRDb3B5TGVuKSlcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSlcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW5cbiAgfVxufVxuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aClcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIERhdGFWaWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzLiBVc2UgaXQgdG8gd3JpdGUgZGF0YSBhZnRlclxuICogY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiAvLyB3cml0ZSBmbG9hdDMyIHVzaW5nIERhdGFWaWV3XG4gKiBjb25zdCBkdiA9IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuc2V0RmxvYXQzMigwLCAxLjEpXG4gKiAvLyByZWFkIGZsb2F0MzIgdXNpbmcgRGF0YVZpZXdcbiAqIGNvbnN0IGR2ID0gcmVhZEZyb21EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuZ2V0RmxvYXQzMigwKSAvLyA9PiAxLjEwMDAwMDAyMzg0MTg1OCAobGVhdmluZyBpdCB0byB0aGUgcmVhZGVyIHRvIGZpbmQgb3V0IHdoeSB0aGlzIGlzIHRoZSBjb3JyZWN0IHJlc3VsdClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybiB7RGF0YVZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZU9uRGF0YVZpZXcgPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIHZlcmlmeUxlbihlbmNvZGVyLCBsZW4pXG4gIGNvbnN0IGR2aWV3ID0gbmV3IERhdGFWaWV3KGVuY29kZXIuY2J1Zi5idWZmZXIsIGVuY29kZXIuY3BvcywgbGVuKVxuICBlbmNvZGVyLmNwb3MgKz0gbGVuXG4gIHJldHVybiBkdmlld1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVGbG9hdDMyID0gKGVuY29kZXIsIG51bSkgPT4gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDQpLnNldEZsb2F0MzIoMCwgbnVtLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlRmxvYXQ2NCA9IChlbmNvZGVyLCBudW0pID0+IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA4KS5zZXRGbG9hdDY0KDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge2JpZ2ludH0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpZ0ludDY0ID0gKGVuY29kZXIsIG51bSkgPT4gLyoqIEB0eXBlIHthbnl9ICovICh3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgOCkpLnNldEJpZ0ludDY0KDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge2JpZ2ludH0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpZ1VpbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdVaW50NjQoMCwgbnVtLCBmYWxzZSlcblxuY29uc3QgZmxvYXRUZXN0QmVkID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig0KSlcbi8qKlxuICogQ2hlY2sgaWYgYSBudW1iZXIgY2FuIGJlIGVuY29kZWQgYXMgYSAzMiBiaXQgZmxvYXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNGbG9hdDMyID0gbnVtID0+IHtcbiAgZmxvYXRUZXN0QmVkLnNldEZsb2F0MzIoMCwgbnVtKVxuICByZXR1cm4gZmxvYXRUZXN0QmVkLmdldEZsb2F0MzIoMCkgPT09IG51bVxufVxuXG4vKipcbiAqIEVuY29kZSBkYXRhIHdpdGggZWZmaWNpZW50IGJpbmFyeSBmb3JtYXQuXG4gKlxuICogRGlmZmVyZW5jZXMgdG8gSlNPTjpcbiAqIOKAoiBUcmFuc2Zvcm1zIGRhdGEgdG8gYSBiaW5hcnkgZm9ybWF0IChub3QgdG8gYSBzdHJpbmcpXG4gKiDigKIgRW5jb2RlcyB1bmRlZmluZWQsIE5hTiwgYW5kIEFycmF5QnVmZmVyICh0aGVzZSBjYW4ndCBiZSByZXByZXNlbnRlZCBpbiBKU09OKVxuICog4oCiIE51bWJlcnMgYXJlIGVmZmljaWVudGx5IGVuY29kZWQgZWl0aGVyIGFzIGEgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIsIGFzIGFcbiAqICAgMzIgYml0IGZsb2F0LCBhcyBhIDY0IGJpdCBmbG9hdCwgb3IgYXMgYSA2NCBiaXQgYmlnaW50LlxuICpcbiAqIEVuY29kaW5nIHRhYmxlOlxuICpcbiAqIHwgRGF0YSBUeXBlICAgICAgICAgICB8IFByZWZpeCAgIHwgRW5jb2RpbmcgTWV0aG9kICAgIHwgQ29tbWVudCB8XG4gKiB8IC0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0gfFxuICogfCB1bmRlZmluZWQgICAgICAgICAgIHwgMTI3ICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCBGdW5jdGlvbnMsIHN5bWJvbCwgYW5kIGV2ZXJ5dGhpbmcgdGhhdCBjYW5ub3QgYmUgaWRlbnRpZmllZCBpcyBlbmNvZGVkIGFzIHVuZGVmaW5lZCB8XG4gKiB8IG51bGwgICAgICAgICAgICAgICAgfCAxMjYgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IHxcbiAqIHwgaW50ZWdlciAgICAgICAgICAgICB8IDEyNSAgICAgIHwgd3JpdGVWYXJJbnQgICAgICAgIHwgT25seSBlbmNvZGVzIDMyIGJpdCBzaWduZWQgaW50ZWdlcnMgfFxuICogfCBmbG9hdDMyICAgICAgICAgICAgIHwgMTI0ICAgICAgfCB3cml0ZUZsb2F0MzIgICAgICAgfCB8XG4gKiB8IGZsb2F0NjQgICAgICAgICAgICAgfCAxMjMgICAgICB8IHdyaXRlRmxvYXQ2NCAgICAgICB8IHxcbiAqIHwgYmlnaW50ICAgICAgICAgICAgICB8IDEyMiAgICAgIHwgd3JpdGVCaWdJbnQ2NCAgICAgIHwgfFxuICogfCBib29sZWFuIChmYWxzZSkgICAgIHwgMTIxICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCBUcnVlIGFuZCBmYWxzZSBhcmUgZGlmZmVyZW50IGRhdGEgdHlwZXMgc28gd2Ugc2F2ZSB0aGUgZm9sbG93aW5nIGJ5dGUgfFxuICogfCBib29sZWFuICh0cnVlKSAgICAgIHwgMTIwICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCAtIDBiMDExMTEwMDAgc28gdGhlIGxhc3QgYml0IGRldGVybWluZXMgd2hldGhlciB0cnVlIG9yIGZhbHNlIHxcbiAqIHwgc3RyaW5nICAgICAgICAgICAgICB8IDExOSAgICAgIHwgd3JpdGVWYXJTdHJpbmcgICAgIHwgfFxuICogfCBvYmplY3Q8c3RyaW5nLGFueT4gIHwgMTE4ICAgICAgfCBjdXN0b20gICAgICAgICAgICAgfCBXcml0ZXMge2xlbmd0aH0gdGhlbiB7bGVuZ3RofSBrZXktdmFsdWUgcGFpcnMgfFxuICogfCBhcnJheTxhbnk+ICAgICAgICAgIHwgMTE3ICAgICAgfCBjdXN0b20gICAgICAgICAgICAgfCBXcml0ZXMge2xlbmd0aH0gdGhlbiB7bGVuZ3RofSBqc29uIHZhbHVlcyB8XG4gKiB8IFVpbnQ4QXJyYXkgICAgICAgICAgfCAxMTYgICAgICB8IHdyaXRlVmFyVWludDhBcnJheSB8IFdlIHVzZSBVaW50OEFycmF5IGZvciBhbnkga2luZCBvZiBiaW5hcnkgZGF0YSB8XG4gKlxuICogUmVhc29ucyBmb3IgdGhlIGRlY3JlYXNpbmcgcHJlZml4OlxuICogV2UgbmVlZCB0aGUgZmlyc3QgYml0IGZvciBleHRlbmRhYmlsaXR5IChsYXRlciB3ZSBtYXkgd2FudCB0byBlbmNvZGUgdGhlXG4gKiBwcmVmaXggd2l0aCB3cml0ZVZhclVpbnQpLiBUaGUgcmVtYWluaW5nIDcgYml0cyBhcmUgZGl2aWRlZCBhcyBmb2xsb3dzOlxuICogWzAtMzBdICAgdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF0YSByYW5nZSBpcyB1c2VkIGZvciBjdXN0b20gcHVycG9zZXNcbiAqICAgICAgICAgIChkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhpcyBsaWJyYXJ5KVxuICogWzMxLTEyN10gdGhlIGVuZCBvZiB0aGUgZGF0YSByYW5nZSBpcyB1c2VkIGZvciBkYXRhIGVuY29kaW5nIGJ5XG4gKiAgICAgICAgICBsaWIwL2VuY29kaW5nLmpzXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxudWxsfG51bWJlcnxiaWdpbnR8Ym9vbGVhbnxzdHJpbmd8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58VWludDhBcnJheX0gZGF0YVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVBbnkgPSAoZW5jb2RlciwgZGF0YSkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBkYXRhKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIFRZUEUgMTE5OiBTVFJJTkdcbiAgICAgIHdyaXRlKGVuY29kZXIsIDExOSlcbiAgICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAobnVtYmVyLmlzSW50ZWdlcihkYXRhKSAmJiBkYXRhIDw9IGJpbmFyeS5CSVRTMzEpIHtcbiAgICAgICAgLy8gVFlQRSAxMjU6IElOVEVHRVJcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTI1KVxuICAgICAgICB3cml0ZVZhckludChlbmNvZGVyLCBkYXRhKVxuICAgICAgfSBlbHNlIGlmIChpc0Zsb2F0MzIoZGF0YSkpIHtcbiAgICAgICAgLy8gVFlQRSAxMjQ6IEZMT0FUMzJcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTI0KVxuICAgICAgICB3cml0ZUZsb2F0MzIoZW5jb2RlciwgZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRZUEUgMTIzOiBGTE9BVDY0XG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyMylcbiAgICAgICAgd3JpdGVGbG9hdDY0KGVuY29kZXIsIGRhdGEpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAvLyBUWVBFIDEyMjogQmlnSW50XG4gICAgICB3cml0ZShlbmNvZGVyLCAxMjIpXG4gICAgICB3cml0ZUJpZ0ludDY0KGVuY29kZXIsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUWVBFIDEyNjogbnVsbFxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjYpXG4gICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAvLyBUWVBFIDExNzogQXJyYXlcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE3KVxuICAgICAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgZGF0YS5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdyaXRlQW55KGVuY29kZXIsIGRhdGFbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgLy8gVFlQRSAxMTY6IEFycmF5QnVmZmVyXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDExNilcbiAgICAgICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUWVBFIDExODogT2JqZWN0XG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDExOClcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBrZXlzLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGtleSlcbiAgICAgICAgICB3cml0ZUFueShlbmNvZGVyLCBkYXRhW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAvLyBUWVBFIDEyMC8xMjE6IGJvb2xlYW4gKHRydWUvZmFsc2UpXG4gICAgICB3cml0ZShlbmNvZGVyLCBkYXRhID8gMTIwIDogMTIxKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVFlQRSAxMjc6IHVuZGVmaW5lZFxuICAgICAgd3JpdGUoZW5jb2RlciwgMTI3KVxuICB9XG59XG5cbi8qKlxuICogTm93IGNvbWUgYSBmZXcgc3RhdGVmdWwgZW5jb2RlciB0aGF0IGhhdmUgdGhlaXIgb3duIGNsYXNzZXMuXG4gKi9cblxuLyoqXG4gKiBCYXNpYyBSdW4gTGVuZ3RoIEVuY29kZXIgLSBhIGJhc2ljIGNvbXByZXNzaW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEVuY29kZXMgWzEsMSwxLDddIHRvIFsxLDMsNywxXSAoMyB0aW1lcyAxLCAxIHRpbWUgNykuIFRoaXMgZW5jb2RlciBtaWdodCBkbyBtb3JlIGhhcm0gdGhhbiBnb29kIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiB2YWx1ZXMgdGhhdCBhcmUgbm90IHJlcGVhdGVkLlxuICpcbiAqIEl0IHdhcyBvcmlnaW5hbGx5IHVzZWQgZm9yIGltYWdlIGNvbXByZXNzaW9uLiBDb29sIC4uIGFydGljbGUgaHR0cDovL2NzYnJ1Y2UuY29tL2NibS90cmFuc2FjdG9yL3BkZnMvdHJhbnNfdjdfaTA2LnBkZlxuICpcbiAqIEBub3RlIFQgbXVzdCBub3QgYmUgbnVsbCFcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgY2xhc3MgUmxlRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFbmNvZGVyLCBUKTp2b2lkfSB3cml0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh3cml0ZXIpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogVGhlIHdyaXRlclxuICAgICAqL1xuICAgIHRoaXMudyA9IHdyaXRlclxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGxcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICAgIC8vIGZsdXNoIGNvdW50ZXIsIHVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCB2YWx1ZSAoY291bnQgPSAwKVxuICAgICAgICB3cml0ZVZhclVpbnQodGhpcywgdGhpcy5jb3VudCAtIDEpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDAsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgICB9XG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgLy8gd3JpdGUgZmlyc3QgdmFsdWVcbiAgICAgIHRoaXMudyh0aGlzLCB2KVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2ljIGRpZmYgZGVjb2RlciB1c2luZyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogRW5jb2RlcyB0aGUgdmFsdWVzIFszLCAxMTAwLCAxMTAxLCAxMDUwLCAwXSB0byBbMywgMTA5NywgMSwgLTUxLCAtMTA1MF0gdXNpbmcgd3JpdGVWYXJJbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnREaWZmRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RhcnQpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKVxuICAgIHRoaXMucyA9IHZcbiAgfVxufVxuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2YgSW50RGlmZkVuY29kZXIgYW5kIFJsZUVuY29kZXIuXG4gKlxuICogQmFzaWNhbGx5IGZpcnN0IHdyaXRlcyB0aGUgSW50RGlmZkVuY29kZXIgYW5kIHRoZW4gY291bnRzIGR1cGxpY2F0ZSBkaWZmcyB1c2luZyBSbGVFbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzEsMSwxLDIsMyw0LDUsNl0gYXMgWzEsMSwwLDIsMSw1XSAoUkxFKFsxLDAsMCwxLDEsMSwxLDFdKSDih5IgUmxlSW50RGlmZlsxLDEsMCwyLDEsNV0pXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVJbnREaWZmRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RhcnQpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYgJiYgdGhpcy5jb3VudCA+IDApIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSkgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMCwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICAgIH1cbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICAvLyB3cml0ZSBmaXJzdCB2YWx1ZVxuICAgICAgd3JpdGVWYXJJbnQodGhpcywgdiAtIHRoaXMucylcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnRPcHRSbGVFbmNvZGVyfSBlbmNvZGVyXG4gKi9cbmNvbnN0IGZsdXNoVWludE9wdFJsZUVuY29kZXIgPSBlbmNvZGVyID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVuY29kZXIuY291bnQgPiAwKSB7XG4gICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgLy8gY2FzZSAxOiBqdXN0IGEgc2luZ2xlIHZhbHVlLiBzZXQgc2lnbiB0byBwb3NpdGl2ZVxuICAgIC8vIGNhc2UgMjogd3JpdGUgc2V2ZXJhbCB2YWx1ZXMuIHNldCBzaWduIHRvIG5lZ2F0aXZlIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgaXMgYSBsZW5ndGggY29taW5nXG4gICAgd3JpdGVWYXJJbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50ID09PSAxID8gZW5jb2Rlci5zIDogLWVuY29kZXIucylcbiAgICBpZiAoZW5jb2Rlci5jb3VudCA+IDEpIHtcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgLSAyKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAxLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE9wdGltaXplZCBSbGUgZW5jb2RlciB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tIHRoZSBtZW50aW9uZWQgcHJvYmxlbSBvZiB0aGUgYmFzaWMgUmxlIGVuY29kZXIuXG4gKlxuICogSW50ZXJuYWxseSB1c2VzIFZhckludCBlbmNvZGVyIHRvIHdyaXRlIHVuc2lnbmVkIGludGVnZXJzLiBJZiB0aGUgaW5wdXQgb2NjdXJzIG11bHRpcGxlIHRpbWVzLCB3ZSB3cml0ZVxuICogd3JpdGUgaXQgYXMgYSBuZWdhdGl2ZSBudW1iZXIuIFRoZSBVaW50T3B0UmxlRGVjb2RlciB0aGVuIHVuZGVyc3RhbmRzIHRoYXQgaXQgbmVlZHMgdG8gcmVhZCBhIGNvdW50LlxuICpcbiAqIEVuY29kZXMgWzEsMiwzLDMsM10gYXMgWzEsMiwtMywzXSAob25jZSAxLCBvbmNlIDIsIHRocmVlIHRpbWVzIDMpXG4gKi9cbmV4cG9ydCBjbGFzcyBVaW50T3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEluY3JlYXNpbmcgVWludCBPcHRpbWl6ZWQgUkxFIEVuY29kZXJcbiAqXG4gKiBUaGUgUkxFIGVuY29kZXIgY291bnRzIHRoZSBudW1iZXIgb2Ygc2FtZSBvY2N1cmVuY2VzIG9mIHRoZSBzYW1lIHZhbHVlLlxuICogVGhlIEluY1VpbnRPcHRSbGUgZW5jb2RlciBjb3VudHMgaWYgdGhlIHZhbHVlIGluY3JlYXNlcy5cbiAqIEkuZS4gNywgOCwgOSwgMTAgd2lsbCBiZSBlbmNvZGVkIGFzIFstNywgNF0uIDEsIDMsIDUgd2lsbCBiZSBlbmNvZGVkXG4gKiBhcyBbMSwgMywgNV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmNVaW50T3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zICsgdGhpcy5jb3VudCA9PT0gdikge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ludERpZmZPcHRSbGVFbmNvZGVyfSBlbmNvZGVyXG4gKi9cbmNvbnN0IGZsdXNoSW50RGlmZk9wdFJsZUVuY29kZXIgPSBlbmNvZGVyID0+IHtcbiAgaWYgKGVuY29kZXIuY291bnQgPiAwKSB7XG4gICAgLy8gICAgICAgICAgMzEgYml0IG1ha2luZyB1cCB0aGUgZGlmZiB8IHdldGhlciB0byB3cml0ZSB0aGUgY291bnRlclxuICAgIGNvbnN0IGVuY29kZWREaWZmID0gZW5jb2Rlci5kaWZmIDw8IDEgfCAoZW5jb2Rlci5jb3VudCA9PT0gMSA/IDAgOiAxKVxuICAgIC8vIGZsdXNoIGNvdW50ZXIsIHVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCB2YWx1ZSAoY291bnQgPSAwKVxuICAgIC8vIGNhc2UgMToganVzdCBhIHNpbmdsZSB2YWx1ZS4gc2V0IGZpcnN0IGJpdCB0byBwb3NpdGl2ZVxuICAgIC8vIGNhc2UgMjogd3JpdGUgc2V2ZXJhbCB2YWx1ZXMuIHNldCBmaXJzdCBiaXQgdG8gbmVnYXRpdmUgdG8gaW5kaWNhdGUgdGhhdCB0aGVyZSBpcyBhIGxlbmd0aCBjb21pbmdcbiAgICB3cml0ZVZhckludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZWREaWZmKVxuICAgIGlmIChlbmNvZGVyLmNvdW50ID4gMSkge1xuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2Rlci5jb3VudCAtIDIpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDEsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSBjb21iaW5hdGlvbiBvZiB0aGUgSW50RGlmZkVuY29kZXIgYW5kIHRoZSBVaW50T3B0UmxlRW5jb2Rlci5cbiAqXG4gKiBUaGUgY291bnQgYXBwcm9hY2ggaXMgc2ltaWxhciB0byB0aGUgVWludERpZmZPcHRSbGVFbmNvZGVyLCBidXQgaW5zdGVhZCBvZiB1c2luZyB0aGUgbmVnYXRpdmUgYml0ZmxhZywgaXQgZW5jb2Rlc1xuICogaW4gdGhlIExTQiB3aGV0aGVyIGEgY291bnQgaXMgdG8gYmUgcmVhZC4gVGhlcmVmb3JlIHRoaXMgRW5jb2RlciBvbmx5IHN1cHBvcnRzIDMxIGJpdCBpbnRlZ2VycyFcbiAqXG4gKiBFbmNvZGVzIFsxLCAyLCAzLCAyXSBhcyBbMywgMSwgNiwgLTFdIChtb3JlIHNwZWNpZmljYWxseSBbKDEgPDwgMSkgfCAxLCAoMyA8PCAwKSB8IDAsIC0xXSlcbiAqXG4gKiBJbnRlcm5hbGx5IHVzZXMgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLiBDb250cmFyeSB0byBub3JtYWwgVWludFZhciBlbmNvZGluZywgdGhlIGZpcnN0IGJ5dGUgY29udGFpbnM6XG4gKiAqIDEgYml0IHRoYXQgZGVub3RlcyB3aGV0aGVyIHRoZSBuZXh0IHZhbHVlIGlzIGEgY291bnQgKExTQilcbiAqICogMSBiaXQgdGhhdCBkZW5vdGVzIHdoZXRoZXIgdGhpcyB2YWx1ZSBpcyBuZWdhdGl2ZSAoTVNCIC0gMSlcbiAqICogMSBiaXQgdGhhdCBkZW5vdGVzIHdoZXRoZXIgdG8gY29udGludWUgcmVhZGluZyB0aGUgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIgKE1TQilcbiAqXG4gKiBUaGVyZWZvcmUsIG9ubHkgZml2ZSBiaXRzIHJlbWFpbiB0byBlbmNvZGUgZGlmZiByYW5nZXMuXG4gKlxuICogVXNlIHRoaXMgRW5jb2RlciBvbmx5IHdoZW4gYXBwcm9wcmlhdGUuIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgcHJvYmFibHkgYSBiYWQgaWRlYS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludERpZmZPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICAgIHRoaXMuZGlmZiA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5kaWZmID09PSB2IC0gdGhpcy5zKSB7XG4gICAgICB0aGlzLnMgPSB2XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMuZGlmZiA9IHYgLSB0aGlzLnNcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoSW50RGlmZk9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIE9wdGltaXplZCBTdHJpbmcgRW5jb2Rlci5cbiAqXG4gKiBFbmNvZGluZyBtYW55IHNtYWxsIHN0cmluZ3MgaW4gYSBzaW1wbGUgRW5jb2RlciBpcyBub3QgdmVyeSBlZmZpY2llbnQuIFRoZSBmdW5jdGlvbiBjYWxsIHRvIGRlY29kZSBhIHN0cmluZyB0YWtlcyBzb21lIHRpbWUgYW5kIGNyZWF0ZXMgcmVmZXJlbmNlcyB0aGF0IG11c3QgYmUgZXZlbnR1YWxseSBkZWxldGVkLlxuICogSW4gcHJhY3RpY2UsIHdoZW4gZGVjb2Rpbmcgc2V2ZXJhbCBtaWxsaW9uIHNtYWxsIHN0cmluZ3MsIHRoZSBHQyB3aWxsIGtpY2sgaW4gbW9yZSBhbmQgbW9yZSBvZnRlbiB0byBjb2xsZWN0IG9ycGhhbmVkIHN0cmluZyBvYmplY3RzIChvciBtYXliZSB0aGVyZSBpcyBhbm90aGVyIHJlYXNvbj8pLlxuICpcbiAqIFRoaXMgc3RyaW5nIGVuY29kZXIgc29sdmVzIHRoZSBhYm92ZSBwcm9ibGVtLiBBbGwgc3RyaW5ncyBhcmUgY29uY2F0ZW5hdGVkIGFuZCB3cml0dGVuIGFzIGEgc2luZ2xlIHN0cmluZyB1c2luZyBhIHNpbmdsZSBlbmNvZGluZyBjYWxsLlxuICpcbiAqIFRoZSBsZW5ndGhzIGFyZSBlbmNvZGVkIHVzaW5nIGEgVWludE9wdFJsZUVuY29kZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuc2FyciA9IFtdXG4gICAgdGhpcy5zID0gJydcbiAgICB0aGlzLmxlbnNFID0gbmV3IFVpbnRPcHRSbGVFbmNvZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqL1xuICB3cml0ZSAoc3RyaW5nKSB7XG4gICAgdGhpcy5zICs9IHN0cmluZ1xuICAgIGlmICh0aGlzLnMubGVuZ3RoID4gMTkpIHtcbiAgICAgIHRoaXMuc2Fyci5wdXNoKHRoaXMucylcbiAgICAgIHRoaXMucyA9ICcnXG4gICAgfVxuICAgIHRoaXMubGVuc0Uud3JpdGUoc3RyaW5nLmxlbmd0aClcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICB0aGlzLnNhcnIucHVzaCh0aGlzLnMpXG4gICAgdGhpcy5zID0gJydcbiAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCB0aGlzLnNhcnIuam9pbignJykpXG4gICAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVuc0UudG9VaW50OEFycmF5KCkpXG4gICAgcmV0dXJuIHRvVWludDhBcnJheShlbmNvZGVyKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/encoding.js\n')},"./node_modules/lib0/environment.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isBrowser\": () => (/* binding */ isBrowser),\n/* harmony export */   \"isMac\": () => (/* binding */ isMac),\n/* harmony export */   \"hasParam\": () => (/* binding */ hasParam),\n/* harmony export */   \"getParam\": () => (/* binding */ getParam),\n/* harmony export */   \"getVariable\": () => (/* binding */ getVariable),\n/* harmony export */   \"getConf\": () => (/* binding */ getConf),\n/* harmony export */   \"hasConf\": () => (/* binding */ hasConf),\n/* harmony export */   \"production\": () => (/* binding */ production)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"./node_modules/lib0/string.js\");\n/* harmony import */ var _conditions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conditions.js */ \"./node_modules/lib0/conditions.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage.js */ \"./node_modules/lib0/storage.js\");\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\n\n\n\n\n\n/* istanbul ignore next */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name)\n/* istanbul ignore next */\nconst isBrowser = typeof window !== 'undefined' && !isNode\n/* istanbul ignore next */\nconst isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      const pargs = process.argv\n      let currParamName = null\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n    // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      // eslint-disable-next-line no-undef\n      ;(location.search || '?').slice(1).split('&').forEach(kv => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n          params.set(`-${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n    }\n  }\n  return params\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasParam = name => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nconst getParam = (name, defaultVal) => computeParams().get(name) || defaultVal\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nconst getVariable = name => isNode ? _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(process.env[name.toUpperCase()]) : _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(_storage_js__WEBPACK_IMPORTED_MODULE_3__.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nconst getConf = name => computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasConf = name => hasParam('--' + name) || getVariable(name) !== null\n\n/* istanbul ignore next */\nconst production = hasConf('production')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2Vudmlyb25tZW50LmpzPzFkOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQ007QUFDUTtBQUNOOztBQUV2QztBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTzs7QUFFUDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsMkNBQVU7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQixxREFBb0IsV0FBVztBQUN6RCx5QkFBeUIscURBQW9CLFdBQVc7QUFDeEQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGVBQWUsMkNBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ08scUNBQXFDLDJEQUEwQixvQ0FBb0MsMkRBQTBCLENBQUMsMkRBQTBCOztBQUUvSjtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9lbnZpcm9ubWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSXNvbW9ycGhpYyBtb2R1bGUgdG8gd29yayBhY2Nlc3MgdGhlIGVudmlyb25tZW50IChxdWVyeSBwYXJhbXMsIGVudiB2YXJpYWJsZXMpLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJy4vc3RyaW5nLmpzJ1xuaW1wb3J0ICogYXMgY29uZGl0aW9ucyBmcm9tICcuL2NvbmRpdGlvbnMuanMnXG5pbXBvcnQgKiBhcyBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZS5qcydcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5yZWxlYXNlICYmIC9ub2RlfGlvXFwuanMvLnRlc3QocHJvY2Vzcy5yZWxlYXNlLm5hbWUpXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFpc05vZGVcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNNYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsc3RyaW5nPn1cbiAqL1xubGV0IHBhcmFtc1xuY29uc3QgYXJncyA9IFtdXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBjb21wdXRlUGFyYW1zID0gKCkgPT4ge1xuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKClcbiAgICAgIGNvbnN0IHBhcmdzID0gcHJvY2Vzcy5hcmd2XG4gICAgICBsZXQgY3VyclBhcmFtTmFtZSA9IG51bGxcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmcgPSBwYXJnc1tpXVxuICAgICAgICBpZiAocGFyZ1swXSA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgJycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJQYXJhbU5hbWUgPSBwYXJnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgcGFyZylcbiAgICAgICAgICAgIGN1cnJQYXJhbU5hbWUgPSBudWxsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChwYXJnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCAnJylcbiAgICAgIH1cbiAgICAvLyBpbiBSZWFjdE5hdGl2ZSBmb3IgZXhhbXBsZSB0aGlzIHdvdWxkIG5vdCBiZSB0cnVlICh1bmxlc3MgY29ubmVjdGVkIHRvIHRoZSBSZW1vdGUgRGVidWdnZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKClcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgOyhsb2NhdGlvbi5zZWFyY2ggfHwgJz8nKS5zbGljZSgxKS5zcGxpdCgnJicpLmZvckVhY2goa3YgPT4ge1xuICAgICAgICBpZiAoa3YubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0ga3Yuc3BsaXQoJz0nKVxuICAgICAgICAgIHBhcmFtcy5zZXQoYC0tJHtzdHJpbmcuZnJvbUNhbWVsQ2FzZShrZXksICctJyl9YCwgdmFsdWUpXG4gICAgICAgICAgcGFyYW1zLnNldChgLSR7c3RyaW5nLmZyb21DYW1lbENhc2Uoa2V5LCAnLScpfWAsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGhhc1BhcmFtID0gbmFtZSA9PiBjb21wdXRlUGFyYW1zKCkuaGFzKG5hbWUpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0VmFsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZ2V0UGFyYW0gPSAobmFtZSwgZGVmYXVsdFZhbCkgPT4gY29tcHV0ZVBhcmFtcygpLmdldChuYW1lKSB8fCBkZWZhdWx0VmFsXG4vLyBleHBvcnQgY29uc3QgZ2V0QXJncyA9IG5hbWUgPT4gY29tcHV0ZVBhcmFtcygpICYmIGFyZ3NcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZ2V0VmFyaWFibGUgPSBuYW1lID0+IGlzTm9kZSA/IGNvbmRpdGlvbnMudW5kZWZpbmVkVG9OdWxsKHByb2Nlc3MuZW52W25hbWUudG9VcHBlckNhc2UoKV0pIDogY29uZGl0aW9ucy51bmRlZmluZWRUb051bGwoc3RvcmFnZS52YXJTdG9yYWdlLmdldEl0ZW0obmFtZSkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG5leHBvcnQgY29uc3QgZ2V0Q29uZiA9IG5hbWUgPT4gY29tcHV0ZVBhcmFtcygpLmdldCgnLS0nICsgbmFtZSkgfHwgZ2V0VmFyaWFibGUobmFtZSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBoYXNDb25mID0gbmFtZSA9PiBoYXNQYXJhbSgnLS0nICsgbmFtZSkgfHwgZ2V0VmFyaWFibGUobmFtZSkgIT09IG51bGxcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0aW9uID0gaGFzQ29uZigncHJvZHVjdGlvbicpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/environment.js\n")},"./node_modules/lib0/error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "methodUnimplemented": () => (/* binding */ methodUnimplemented),\n/* harmony export */   "unexpectedCase": () => (/* binding */ unexpectedCase)\n/* harmony export */ });\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* istanbul ignore next */\nconst create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst methodUnimplemented = () => {\n  throw create(\'Method unimplemented\')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst unexpectedCase = () => {\n  throw create(\'Unexpected case\')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2Vycm9yLmpzPzFlNTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZXJyb3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVycm9yIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBlcnJvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IHMgPT4gbmV3IEVycm9yKHMpXG5cbi8qKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcmV0dXJuIHtuZXZlcn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBtZXRob2RVbmltcGxlbWVudGVkID0gKCkgPT4ge1xuICB0aHJvdyBjcmVhdGUoJ01ldGhvZCB1bmltcGxlbWVudGVkJylcbn1cblxuLyoqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEByZXR1cm4ge25ldmVyfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHVuZXhwZWN0ZWRDYXNlID0gKCkgPT4ge1xuICB0aHJvdyBjcmVhdGUoJ1VuZXhwZWN0ZWQgY2FzZScpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/error.js\n')},"./node_modules/lib0/eventloop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "enqueue": () => (/* binding */ enqueue),\n/* harmony export */   "timeout": () => (/* binding */ timeout),\n/* harmony export */   "interval": () => (/* binding */ interval),\n/* harmony export */   "Animation": () => (/* binding */ Animation),\n/* harmony export */   "animationFrame": () => (/* binding */ animationFrame),\n/* harmony export */   "idleCallback": () => (/* binding */ idleCallback),\n/* harmony export */   "createDebouncer": () => (/* binding */ createDebouncer)\n/* harmony export */ });\n/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n/**\n * Utility module to work with EcmaScript\'s event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = []\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n}\n\n/**\n * @param {function():void} f\n */\nconst enqueue = f => {\n  queue.push(f)\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0)\n  }\n}\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId\n  }\n\n  destroy () {\n    clearFunction(this._)\n  }\n}\n\nconst Timeout = createTimeoutClass(clearTimeout)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout))\n\nconst Interval = createTimeoutClass(clearInterval)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst interval = (timeout, callback) => new Interval(setInterval(callback, timeout))\n\n/* istanbul ignore next */\nconst Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== \'undefined\' && cancelAnimationFrame(arg))\n\n/* istanbul ignore next */\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\nconst animationFrame = cb => typeof requestAnimationFrame === \'undefined\' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb))\n\n/* istanbul ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== \'undefined\' && cancelIdleCallback(arg))\n\n/* istanbul ignore next */\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n// @ts-ignore\nconst idleCallback = cb => typeof requestIdleCallback !== \'undefined\' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb)\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @return {function(function():void):void}\n */\nconst createDebouncer = timeout => {\n  let timer = -1\n  return f => {\n    clearTimeout(timer)\n    if (f) {\n      timer = /** @type {any} */ (setTimeout(f, timeout))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2V2ZW50bG9vcC5qcz8wNThhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2V2ZW50bG9vcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCByZXF1ZXN0SWRsZUNhbGxiYWNrLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbElkbGVDYWxsYmFjaywgY2FuY2VsQW5pbWF0aW9uRnJhbWUgKi9cblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggRWNtYVNjcmlwdCdzIGV2ZW50IGxvb3AuXG4gKlxuICogQG1vZHVsZSBldmVudGxvb3BcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59XG4gKi9cbmxldCBxdWV1ZSA9IFtdXG5cbmNvbnN0IF9ydW5RdWV1ZSA9ICgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldKClcbiAgfVxuICBxdWV1ZSA9IFtdXG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGVucXVldWUgPSBmID0+IHtcbiAgcXVldWUucHVzaChmKVxuICBpZiAocXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgc2V0VGltZW91dChfcnVuUXVldWUsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaW1lb3V0T2JqZWN0XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBUaW1lb3V0T2JqZWN0LmRlc3Ryb3lcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTp2b2lkfSBjbGVhckZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVRpbWVvdXRDbGFzcyA9IGNsZWFyRnVuY3Rpb24gPT4gY2xhc3MgVFQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRpbWVvdXRJZCkge1xuICAgIHRoaXMuXyA9IHRpbWVvdXRJZFxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgY2xlYXJGdW5jdGlvbih0aGlzLl8pXG4gIH1cbn1cblxuY29uc3QgVGltZW91dCA9IGNyZWF0ZVRpbWVvdXRDbGFzcyhjbGVhclRpbWVvdXQpXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtUaW1lb3V0T2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgdGltZW91dCA9ICh0aW1lb3V0LCBjYWxsYmFjaykgPT4gbmV3IFRpbWVvdXQoc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCkpXG5cbmNvbnN0IEludGVydmFsID0gY3JlYXRlVGltZW91dENsYXNzKGNsZWFySW50ZXJ2YWwpXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtUaW1lb3V0T2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgaW50ZXJ2YWwgPSAodGltZW91dCwgY2FsbGJhY2spID0+IG5ldyBJbnRlcnZhbChzZXRJbnRlcnZhbChjYWxsYmFjaywgdGltZW91dCkpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgQW5pbWF0aW9uID0gY3JlYXRlVGltZW91dENsYXNzKGFyZyA9PiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJyAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShhcmcpKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gY2JcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBhbmltYXRpb25GcmFtZSA9IGNiID0+IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnID8gdGltZW91dCgwLCBjYikgOiBuZXcgQW5pbWF0aW9uKHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBJZGxlID0gY3JlYXRlVGltZW91dENsYXNzKGFyZyA9PiB0eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBjYW5jZWxJZGxlQ2FsbGJhY2soYXJnKSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogTm90ZTogdGhpcyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHByb2JhYmx5IG9ubHkgdXNlZnVsIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXG4gKiBAcmV0dXJuIHtUaW1lb3V0T2JqZWN0fVxuICovXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3QgaWRsZUNhbGxiYWNrID0gY2IgPT4gdHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnID8gbmV3IElkbGUocmVxdWVzdElkbGVDYWxsYmFjayhjYikpIDogdGltZW91dCgxMDAwLCBjYilcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUaW1lb3V0IG9mIHRoZSBkZWJvdW5jZSBhY3Rpb25cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCk6dm9pZCk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURlYm91bmNlciA9IHRpbWVvdXQgPT4ge1xuICBsZXQgdGltZXIgPSAtMVxuICByZXR1cm4gZiA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgIGlmIChmKSB7XG4gICAgICB0aW1lciA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0VGltZW91dChmLCB0aW1lb3V0KSlcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/eventloop.js\n')},"./node_modules/lib0/function.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "callAll": () => (/* binding */ callAll),\n/* harmony export */   "nop": () => (/* binding */ nop),\n/* harmony export */   "apply": () => (/* binding */ apply),\n/* harmony export */   "id": () => (/* binding */ id),\n/* harmony export */   "equalityStrict": () => (/* binding */ equalityStrict),\n/* harmony export */   "equalityFlat": () => (/* binding */ equalityFlat),\n/* harmony export */   "equalityDeep": () => (/* binding */ equalityDeep)\n/* harmony export */ });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/lib0/array.js");\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object.js */ "./node_modules/lib0/object.js");\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nconst callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nconst nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nconst apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nconst id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nconst equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && _array_js__WEBPACK_IMPORTED_MODULE_0__.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === \'object\' && _object_js__WEBPACK_IMPORTED_MODULE_1__.equalFlat(a, b))))\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (_object_js__WEBPACK_IMPORTED_MODULE_1__.length(a) !== _object_js__WEBPACK_IMPORTED_MODULE_1__.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!_object_js__WEBPACK_IMPORTED_MODULE_1__.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2Z1bmN0aW9uLmpzPzIxNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDRTs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxXQUFXO0FBQ3RCO0FBQ087QUFDUDtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLGdCQUFnQjtBQUMzQixZQUFZO0FBQ1o7QUFDTyxnSUFBZ0ksZ0RBQWUsZUFBZSxTQUFTLHVDQUF1QyxpREFBZ0I7O0FBRXJPO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxJQUFJO0FBQ2YsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBYSxRQUFRLDhDQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Z1bmN0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21tb24gZnVuY3Rpb25zIGFuZCBmdW5jdGlvbiBjYWxsIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBmdW5jdGlvblxuICovXG5cbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vYXJyYXkuanMnXG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnLi9vYmplY3QuanMnXG5cbi8qKlxuICogQ2FsbHMgYWxsIGZ1bmN0aW9ucyBpbiBgZnNgIHdpdGggYXJncy4gT25seSB0aHJvd3MgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyB3ZXJlIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uPn0gZnNcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgY2FsbEFsbCA9IChmcywgYXJncywgaSA9IDApID0+IHtcbiAgdHJ5IHtcbiAgICBmb3IgKDsgaSA8IGZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmc1tpXSguLi5hcmdzKVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoaSA8IGZzLmxlbmd0aCkge1xuICAgICAgY2FsbEFsbChmcywgYXJncywgaSArIDEpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBub3AgPSAoKSA9PiB7fVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6VH0gZlxuICogQHJldHVybiB7VH1cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5ID0gZiA9PiBmKClcblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICpcbiAqIEBwYXJhbSB7QX0gYVxuICogQHJldHVybiB7QX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlkID0gYSA9PiBhXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge1R9IGFcbiAqIEBwYXJhbSB7VH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsaXR5U3RyaWN0ID0gKGEsIGIpID0+IGEgPT09IGJcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD58b2JqZWN0fSBhXG4gKiBAcGFyYW0ge0FycmF5PFQ+fG9iamVjdH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsaXR5RmxhdCA9IChhLCBiKSA9PiBhID09PSBiIHx8IChhICE9IG51bGwgJiYgYiAhPSBudWxsICYmIGEuY29uc3RydWN0b3IgPT09IGIuY29uc3RydWN0b3IgJiYgKChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYXJyYXkuZXF1YWxGbGF0KGEsIC8qKiBAdHlwZSB7QXJyYXk8VD59ICovIChiKSkpIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSkpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsaXR5RGVlcCA9IChhLCBiKSA9PiB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVxdWFsaXR5U3RyaWN0KGEsIGIpXG4gIH1cbiAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgc3dpdGNoIChhLmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBBcnJheUJ1ZmZlcjpcbiAgICAgIGEgPSBuZXcgVWludDhBcnJheShhKVxuICAgICAgYiA9IG5ldyBVaW50OEFycmF5KGIpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgY2FzZSBVaW50OEFycmF5OiB7XG4gICAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBTZXQ6IHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYSkge1xuICAgICAgICBpZiAoIWIuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE1hcDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpIHx8ICFlcXVhbGl0eURlZXAoYS5nZXQoa2V5KSwgYi5nZXQoa2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBPYmplY3Q6XG4gICAgICBpZiAob2JqZWN0Lmxlbmd0aChhKSAhPT0gb2JqZWN0Lmxlbmd0aChiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKCFvYmplY3QuaGFzUHJvcGVydHkoYSwga2V5KSB8fCAhZXF1YWxpdHlEZWVwKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgQXJyYXk6XG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZXF1YWxpdHlEZWVwKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/function.js\n')},"./node_modules/lib0/indexeddb.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rtop": () => (/* binding */ rtop),\n/* harmony export */   "openDB": () => (/* binding */ openDB),\n/* harmony export */   "deleteDB": () => (/* binding */ deleteDB),\n/* harmony export */   "createStores": () => (/* binding */ createStores),\n/* harmony export */   "transact": () => (/* binding */ transact),\n/* harmony export */   "count": () => (/* binding */ count),\n/* harmony export */   "get": () => (/* binding */ get),\n/* harmony export */   "del": () => (/* binding */ del),\n/* harmony export */   "put": () => (/* binding */ put),\n/* harmony export */   "add": () => (/* binding */ add),\n/* harmony export */   "addAutoKey": () => (/* binding */ addAutoKey),\n/* harmony export */   "getAll": () => (/* binding */ getAll),\n/* harmony export */   "getAllKeys": () => (/* binding */ getAllKeys),\n/* harmony export */   "queryFirst": () => (/* binding */ queryFirst),\n/* harmony export */   "getLastKey": () => (/* binding */ getLastKey),\n/* harmony export */   "getFirstKey": () => (/* binding */ getFirstKey),\n/* harmony export */   "getAllKeysValues": () => (/* binding */ getAllKeysValues),\n/* harmony export */   "iterate": () => (/* binding */ iterate),\n/* harmony export */   "iterateKeys": () => (/* binding */ iterateKeys),\n/* harmony export */   "getStore": () => (/* binding */ getStore),\n/* harmony export */   "createIDBKeyRangeBound": () => (/* binding */ createIDBKeyRangeBound),\n/* harmony export */   "createIDBKeyRangeUpperBound": () => (/* binding */ createIDBKeyRangeUpperBound),\n/* harmony export */   "createIDBKeyRangeLowerBound": () => (/* binding */ createIDBKeyRangeLowerBound)\n/* harmony export */ });\n/* harmony import */ var _promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./promise.js */ "./node_modules/lib0/promise.js");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error.js */ "./node_modules/lib0/error.js");\n/* eslint-env browser */\n\n/**\n * Helpers to work with IndexedDB.\n *\n * @module idb\n */\n\n\n\n\n/**\n * IDB Request to Promise transformer\n *\n * @param {IDBRequest} request\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nconst rtop = request => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onerror = event => reject(new Error(event.target.error))\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onblocked = () => location.reload()\n  // @ts-ignore\n  request.onsuccess = event => resolve(event.target.result)\n})\n\n/**\n * @param {string} name\n * @param {function(IDBDatabase):any} initDB Called when the database is first created\n * @return {Promise<IDBDatabase>}\n */\n/* istanbul ignore next */\nconst openDB = (name, initDB) => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  const request = indexedDB.open(name)\n  /**\n   * @param {any} event\n   */\n  request.onupgradeneeded = event => initDB(event.target.result)\n  /* istanbul ignore next */\n  /**\n   * @param {any} event\n   */\n  request.onerror = event => reject(_error_js__WEBPACK_IMPORTED_MODULE_1__.create(event.target.error))\n  /* istanbul ignore next */\n  request.onblocked = () => location.reload()\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    /**\n     * @type {IDBDatabase}\n     */\n    const db = event.target.result\n    /* istanbul ignore next */\n    db.onversionchange = () => { db.close() }\n    /* istanbul ignore if */\n    if (typeof addEventListener !== \'undefined\') {\n      addEventListener(\'unload\', () => db.close())\n    }\n    resolve(db)\n  }\n})\n\n/**\n * @param {string} name\n */\n/* istanbul ignore next */\nconst deleteDB = name => rtop(indexedDB.deleteDatabase(name))\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<Array<string>|Array<string|IDBObjectStoreParameters|undefined>>} definitions\n */\n/* istanbul ignore next */\nconst createStores = (db, definitions) => definitions.forEach(d =>\n  // @ts-ignore\n  db.createObjectStore.apply(db, d)\n)\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<string>} stores\n * @param {"readwrite"|"readonly"} [access]\n * @return {Array<IDBObjectStore>}\n */\nconst transact = (db, stores, access = \'readwrite\') => {\n  const transaction = db.transaction(stores, access)\n  return stores.map(store => getStore(transaction, store))\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<number>}\n */\n/* istanbul ignore next */\nconst count = (store, range) =>\n  rtop(store.count(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | Array<any> } key\n * @return {Promise<String | number | ArrayBuffer | Date | Array<any>>}\n */\n/* istanbul ignore next */\nconst get = (store, key) =>\n  rtop(store.get(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | IDBKeyRange | Array<any> } key\n */\n/* istanbul ignore next */\nconst del = (store, key) =>\n  rtop(store.delete(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean} item\n * @param {String | number | ArrayBuffer | Date | Array<any>} [key]\n */\n/* istanbul ignore next */\nconst put = (store, item, key) =>\n  rtop(store.put(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean}  item\n * @param {String | number | ArrayBuffer | Date | Array<any>}  key\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nconst add = (store, item, key) =>\n  rtop(store.add(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date}  item\n * @return {Promise<number>} Returns the generated key\n */\n/* istanbul ignore next */\nconst addAutoKey = (store, item) =>\n  rtop(store.add(item))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nconst getAll = (store, range) =>\n  rtop(store.getAll(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nconst getAllKeys = (store, range) =>\n  rtop(store.getAllKeys(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} query\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n * @return {Promise<any>}\n */\nconst queryFirst = (store, query, direction) => {\n  /**\n   * @type {any}\n   */\n  let first = null\n  return iterateKeys(store, query, key => {\n    first = key\n    return false\n  }, direction).then(() => first)\n}\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nconst getLastKey = store => queryFirst(store, null, \'prev\')\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nconst getFirstKey = store => queryFirst(store, null, \'prev\')\n\n/**\n * @typedef KeyValuePair\n * @type {Object}\n * @property {any} k key\n * @property {any} v Value\n */\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<KeyValuePair>>}\n */\n/* istanbul ignore next */\nconst getAllKeysValues = (store, range) =>\n  // @ts-ignore\n  _promise_js__WEBPACK_IMPORTED_MODULE_0__.all([getAllKeys(store, range), getAll(store, range)]).then(([ks, vs]) => ks.map((k, i) => ({ k, v: vs[i] })))\n\n/**\n * @param {any} request\n * @param {function(IDBCursorWithValue):void|boolean} f\n * @return {Promise<void>}\n */\n/* istanbul ignore next */\nconst iterateOnRequest = (request, f) => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  /* istanbul ignore next */\n  request.onerror = reject\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    const cursor = event.target.result\n    if (cursor === null || f(cursor) === false) {\n      return resolve()\n    }\n    cursor.continue()\n  }\n})\n\n/**\n * Iterate on keys and values\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any,any):void|boolean} f Callback that receives (value, key)\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n */\n/* istanbul ignore next */\nconst iterate = (store, keyrange, f, direction = \'next\') =>\n  iterateOnRequest(store.openCursor(keyrange, direction), cursor => f(cursor.value, cursor.key))\n\n/**\n * Iterate on the keys (no values)\n *\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any):void|boolean} f callback that receives the key\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n */\n/* istanbul ignore next */\nconst iterateKeys = (store, keyrange, f, direction = \'next\') =>\n  iterateOnRequest(store.openKeyCursor(keyrange, direction), cursor => f(cursor.key))\n\n/**\n * Open store from transaction\n * @param {IDBTransaction} t\n * @param {String} store\n * @returns {IDBObjectStore}\n */\n/* istanbul ignore next */\nconst getStore = (t, store) => t.objectStore(store)\n\n/**\n * @param {any} lower\n * @param {any} upper\n * @param {boolean} lowerOpen\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeBound = (lower, upper, lowerOpen, upperOpen) => IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n\n/**\n * @param {any} upper\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen)\n\n/**\n * @param {any} lower\n * @param {boolean} lowerOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2luZGV4ZWRkYi5qcz82MmExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QztBQUNKOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDTyx3QkFBd0IsK0NBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVywwQkFBMEI7QUFDckMsWUFBWTtBQUNaO0FBQ0E7QUFDTyxpQ0FBaUMsK0NBQWM7QUFDdEQ7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBLG9DQUFvQyw2Q0FBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLHNFQUFzRTtBQUNqRjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxtREFBbUQ7QUFDOUQsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUVBQWlFO0FBQzVFO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsK0NBQStDO0FBQzFELFdBQVcsa0RBQWtEO0FBQzdEO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsK0NBQStDO0FBQzFELFdBQVcsa0RBQWtEO0FBQzdELFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLHFDQUFxQztBQUNoRCxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyx3Q0FBd0M7QUFDbkQsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsSUFBSTtBQUNsQjs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EsRUFBRSw0Q0FBVyx5RkFBeUYsY0FBYzs7QUFFcEg7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLDBDQUEwQztBQUNyRCxZQUFZO0FBQ1o7QUFDQTtBQUNBLHlDQUF5QywrQ0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLHdDQUF3QztBQUNuRDtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyx3Q0FBd0M7QUFDbkQ7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9pbmRleGVkZGIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIZWxwZXJzIHRvIHdvcmsgd2l0aCBJbmRleGVkREIuXG4gKlxuICogQG1vZHVsZSBpZGJcbiAqL1xuXG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gJy4vcHJvbWlzZS5qcydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJy4vZXJyb3IuanMnXG5cbi8qKlxuICogSURCIFJlcXVlc3QgdG8gUHJvbWlzZSB0cmFuc2Zvcm1lclxuICpcbiAqIEBwYXJhbSB7SURCUmVxdWVzdH0gcmVxdWVzdFxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHJ0b3AgPSByZXF1ZXN0ID0+IHByb21pc2UuY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICByZXF1ZXN0Lm9uZXJyb3IgPSBldmVudCA9PiByZWplY3QobmV3IEVycm9yKGV2ZW50LnRhcmdldC5lcnJvcikpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmVxdWVzdC5vbmJsb2NrZWQgPSAoKSA9PiBsb2NhdGlvbi5yZWxvYWQoKVxuICAvLyBAdHMtaWdub3JlXG4gIHJlcXVlc3Qub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KVxufSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbihJREJEYXRhYmFzZSk6YW55fSBpbml0REIgQ2FsbGVkIHdoZW4gdGhlIGRhdGFiYXNlIGlzIGZpcnN0IGNyZWF0ZWRcbiAqIEByZXR1cm4ge1Byb21pc2U8SURCRGF0YWJhc2U+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG9wZW5EQiA9IChuYW1lLCBpbml0REIpID0+IHByb21pc2UuY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKG5hbWUpXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZXZlbnQgPT4gaW5pdERCKGV2ZW50LnRhcmdldC5yZXN1bHQpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub25lcnJvciA9IGV2ZW50ID0+IHJlamVjdChlcnJvci5jcmVhdGUoZXZlbnQudGFyZ2V0LmVycm9yKSlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmVxdWVzdC5vbmJsb2NrZWQgPSAoKSA9PiBsb2NhdGlvbi5yZWxvYWQoKVxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAqL1xuICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SURCRGF0YWJhc2V9XG4gICAgICovXG4gICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBkYi5vbnZlcnNpb25jaGFuZ2UgPSAoKSA9PiB7IGRiLmNsb3NlKCkgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsICgpID0+IGRiLmNsb3NlKCkpXG4gICAgfVxuICAgIHJlc29sdmUoZGIpXG4gIH1cbn0pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBkZWxldGVEQiA9IG5hbWUgPT4gcnRvcChpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJEYXRhYmFzZX0gZGJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8c3RyaW5nPnxBcnJheTxzdHJpbmd8SURCT2JqZWN0U3RvcmVQYXJhbWV0ZXJzfHVuZGVmaW5lZD4+fSBkZWZpbml0aW9uc1xuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0b3JlcyA9IChkYiwgZGVmaW5pdGlvbnMpID0+IGRlZmluaXRpb25zLmZvckVhY2goZCA9PlxuICAvLyBAdHMtaWdub3JlXG4gIGRiLmNyZWF0ZU9iamVjdFN0b3JlLmFwcGx5KGRiLCBkKVxuKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCRGF0YWJhc2V9IGRiXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHN0b3Jlc1xuICogQHBhcmFtIHtcInJlYWR3cml0ZVwifFwicmVhZG9ubHlcIn0gW2FjY2Vzc11cbiAqIEByZXR1cm4ge0FycmF5PElEQk9iamVjdFN0b3JlPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zYWN0ID0gKGRiLCBzdG9yZXMsIGFjY2VzcyA9ICdyZWFkd3JpdGUnKSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oc3RvcmVzLCBhY2Nlc3MpXG4gIHJldHVybiBzdG9yZXMubWFwKHN0b3JlID0+IGdldFN0b3JlKHRyYW5zYWN0aW9uLCBzdG9yZSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V9IFtyYW5nZV1cbiAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjb3VudCA9IChzdG9yZSwgcmFuZ2UpID0+XG4gIHJ0b3Aoc3RvcmUuY291bnQocmFuZ2UpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT4gfSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55Pj59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZ2V0ID0gKHN0b3JlLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUuZ2V0KGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgSURCS2V5UmFuZ2UgfCBBcnJheTxhbnk+IH0ga2V5XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZGVsID0gKHN0b3JlLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUuZGVsZXRlKGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYm9vbGVhbn0gaXRlbVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBBcnJheTxhbnk+fSBba2V5XVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHB1dCA9IChzdG9yZSwgaXRlbSwga2V5KSA9PlxuICBydG9wKHN0b3JlLnB1dChpdGVtLCBrZXkpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IGJvb2xlYW59ICBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT59ICBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBhZGQgPSAoc3RvcmUsIGl0ZW0sIGtleSkgPT5cbiAgcnRvcChzdG9yZS5hZGQoaXRlbSwga2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9ICBpdGVtXG4gKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcj59IFJldHVybnMgdGhlIGdlbmVyYXRlZCBrZXlcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBhZGRBdXRvS2V5ID0gKHN0b3JlLCBpdGVtKSA9PlxuICBydG9wKHN0b3JlLmFkZChpdGVtKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxhbnk+Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRBbGwgPSAoc3RvcmUsIHJhbmdlKSA9PlxuICBydG9wKHN0b3JlLmdldEFsbChyYW5nZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V9IFtyYW5nZV1cbiAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8YW55Pj59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZ2V0QWxsS2V5cyA9IChzdG9yZSwgcmFuZ2UpID0+XG4gIHJ0b3Aoc3RvcmUuZ2V0QWxsS2V5cyhyYW5nZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V8bnVsbH0gcXVlcnlcbiAqIEBwYXJhbSB7J25leHQnfCdwcmV2J3wnbmV4dHVuaXF1ZSd8J3ByZXZ1bmlxdWUnfSBkaXJlY3Rpb25cbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5Rmlyc3QgPSAoc3RvcmUsIHF1ZXJ5LCBkaXJlY3Rpb24pID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgZmlyc3QgPSBudWxsXG4gIHJldHVybiBpdGVyYXRlS2V5cyhzdG9yZSwgcXVlcnksIGtleSA9PiB7XG4gICAgZmlyc3QgPSBrZXlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSwgZGlyZWN0aW9uKS50aGVuKCgpID0+IGZpcnN0KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMYXN0S2V5ID0gc3RvcmUgPT4gcXVlcnlGaXJzdChzdG9yZSwgbnVsbCwgJ3ByZXYnKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGaXJzdEtleSA9IHN0b3JlID0+IHF1ZXJ5Rmlyc3Qoc3RvcmUsIG51bGwsICdwcmV2JylcblxuLyoqXG4gKiBAdHlwZWRlZiBLZXlWYWx1ZVBhaXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2FueX0gayBrZXlcbiAqIEBwcm9wZXJ0eSB7YW55fSB2IFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxLZXlWYWx1ZVBhaXI+Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRBbGxLZXlzVmFsdWVzID0gKHN0b3JlLCByYW5nZSkgPT5cbiAgLy8gQHRzLWlnbm9yZVxuICBwcm9taXNlLmFsbChbZ2V0QWxsS2V5cyhzdG9yZSwgcmFuZ2UpLCBnZXRBbGwoc3RvcmUsIHJhbmdlKV0pLnRoZW4oKFtrcywgdnNdKSA9PiBrcy5tYXAoKGssIGkpID0+ICh7IGssIHY6IHZzW2ldIH0pKSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICogQHBhcmFtIHtmdW5jdGlvbihJREJDdXJzb3JXaXRoVmFsdWUpOnZvaWR8Ym9vbGVhbn0gZlxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGl0ZXJhdGVPblJlcXVlc3QgPSAocmVxdWVzdCwgZikgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3RcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBldmVudCA9PiB7XG4gICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdFxuICAgIGlmIChjdXJzb3IgPT09IG51bGwgfHwgZihjdXJzb3IpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgIH1cbiAgICBjdXJzb3IuY29udGludWUoKVxuICB9XG59KVxuXG4vKipcbiAqIEl0ZXJhdGUgb24ga2V5cyBhbmQgdmFsdWVzXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZXxudWxsfSBrZXlyYW5nZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksYW55KTp2b2lkfGJvb2xlYW59IGYgQ2FsbGJhY2sgdGhhdCByZWNlaXZlcyAodmFsdWUsIGtleSlcbiAqIEBwYXJhbSB7J25leHQnfCdwcmV2J3wnbmV4dHVuaXF1ZSd8J3ByZXZ1bmlxdWUnfSBkaXJlY3Rpb25cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlID0gKHN0b3JlLCBrZXlyYW5nZSwgZiwgZGlyZWN0aW9uID0gJ25leHQnKSA9PlxuICBpdGVyYXRlT25SZXF1ZXN0KHN0b3JlLm9wZW5DdXJzb3Ioa2V5cmFuZ2UsIGRpcmVjdGlvbiksIGN1cnNvciA9PiBmKGN1cnNvci52YWx1ZSwgY3Vyc29yLmtleSkpXG5cbi8qKlxuICogSXRlcmF0ZSBvbiB0aGUga2V5cyAobm8gdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfG51bGx9IGtleXJhbmdlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6dm9pZHxib29sZWFufSBmIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGtleVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGVLZXlzID0gKHN0b3JlLCBrZXlyYW5nZSwgZiwgZGlyZWN0aW9uID0gJ25leHQnKSA9PlxuICBpdGVyYXRlT25SZXF1ZXN0KHN0b3JlLm9wZW5LZXlDdXJzb3Ioa2V5cmFuZ2UsIGRpcmVjdGlvbiksIGN1cnNvciA9PiBmKGN1cnNvci5rZXkpKVxuXG4vKipcbiAqIE9wZW4gc3RvcmUgZnJvbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJREJUcmFuc2FjdGlvbn0gdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlXG4gKiBAcmV0dXJucyB7SURCT2JqZWN0U3RvcmV9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZ2V0U3RvcmUgPSAodCwgc3RvcmUpID0+IHQub2JqZWN0U3RvcmUoc3RvcmUpXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGxvd2VyXG4gKiBAcGFyYW0ge2FueX0gdXBwZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG93ZXJPcGVuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVwcGVyT3BlblxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUlEQktleVJhbmdlQm91bmQgPSAobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3BlbikgPT4gSURCS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3BlbilcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdXBwZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBwZXJPcGVuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlSURCS2V5UmFuZ2VVcHBlckJvdW5kID0gKHVwcGVyLCB1cHBlck9wZW4pID0+IElEQktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsIHVwcGVyT3BlbilcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbG93ZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG93ZXJPcGVuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlSURCS2V5UmFuZ2VMb3dlckJvdW5kID0gKGxvd2VyLCBsb3dlck9wZW4pID0+IElEQktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsIGxvd2VyT3BlbilcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/indexeddb.js\n')},"./node_modules/lib0/iterator.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mapIterator": () => (/* binding */ mapIterator),\n/* harmony export */   "createIterator": () => (/* binding */ createIterator),\n/* harmony export */   "iteratorFilter": () => (/* binding */ iteratorFilter),\n/* harmony export */   "iteratorMap": () => (/* binding */ iteratorMap)\n/* harmony export */ });\n/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nconst mapIterator = (iterator, f) => ({\n  /**\n   * @param {function(T):R} f\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nconst createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nconst iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nconst iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2l0ZXJhdG9yLmpzPzQxMTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLG9CQUFvQjtBQUMvQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsY0FBYztBQUN6QjtBQUNPO0FBQ1AsU0FBUyxjQUFjO0FBQ3ZCLFVBQVU7QUFDVixDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvaXRlcmF0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIGNyZWF0ZSBhbmQgbWFuaXB1bGF0ZSBJdGVyYXRvcnMuXG4gKlxuICogQG1vZHVsZSBpdGVyYXRvclxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFQsUlxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Un0gZlxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcEl0ZXJhdG9yID0gKGl0ZXJhdG9yLCBmKSA9PiAoe1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUKTpSfSBmXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgLy8gQHRzLWlnbm9yZVxuICBuZXh0ICgpIHtcbiAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpXG4gICAgcmV0dXJuIHsgdmFsdWU6IHIuZG9uZSA/IHVuZGVmaW5lZCA6IGYoci52YWx1ZSksIGRvbmU6IHIuZG9uZSB9XG4gIH1cbn0pXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpJdGVyYXRvclJlc3VsdDxUPn0gbmV4dFxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUl0ZXJhdG9yID0gbmV4dCA9PiAoe1xuICAvKipcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICAvLyBAdHMtaWdub3JlXG4gIG5leHRcbn0pXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOmJvb2xlYW59IGZpbHRlclxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0b3JGaWx0ZXIgPSAoaXRlcmF0b3IsIGZpbHRlcikgPT4gY3JlYXRlSXRlcmF0b3IoKCkgPT4ge1xuICBsZXQgcmVzXG4gIGRvIHtcbiAgICByZXMgPSBpdGVyYXRvci5uZXh0KClcbiAgfSB3aGlsZSAoIXJlcy5kb25lICYmICFmaWx0ZXIocmVzLnZhbHVlKSlcbiAgcmV0dXJuIHJlc1xufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVCxNXG4gKiBAcGFyYW0ge0l0ZXJhdG9yPFQ+fSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpNfSBmbWFwXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRvck1hcCA9IChpdGVyYXRvciwgZm1hcCkgPT4gY3JlYXRlSXRlcmF0b3IoKCkgPT4ge1xuICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdGVyYXRvci5uZXh0KClcbiAgcmV0dXJuIHsgZG9uZSwgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBmbWFwKHZhbHVlKSB9XG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/iterator.js\n')},"./node_modules/lib0/json.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "stringify": () => (/* binding */ stringify),\n/* harmony export */   "parse": () => (/* binding */ parse)\n/* harmony export */ });\n/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nconst stringify = JSON.stringify\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nconst parse = JSON.parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2pzb24uanM/Y2JkMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvanNvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSlNPTiB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGpzb25cbiAqL1xuXG4vKipcbiAqIFRyYW5zZm9ybSBKYXZhU2NyaXB0IG9iamVjdCB0byBKU09OLlxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5XG5cbi8qKlxuICogUGFyc2UgSlNPTiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGpzb25cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlID0gSlNPTi5wYXJzZVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/json.js\n')},"./node_modules/lib0/logging.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BOLD\": () => (/* binding */ BOLD),\n/* harmony export */   \"UNBOLD\": () => (/* binding */ UNBOLD),\n/* harmony export */   \"BLUE\": () => (/* binding */ BLUE),\n/* harmony export */   \"GREY\": () => (/* binding */ GREY),\n/* harmony export */   \"GREEN\": () => (/* binding */ GREEN),\n/* harmony export */   \"RED\": () => (/* binding */ RED),\n/* harmony export */   \"PURPLE\": () => (/* binding */ PURPLE),\n/* harmony export */   \"ORANGE\": () => (/* binding */ ORANGE),\n/* harmony export */   \"UNCOLOR\": () => (/* binding */ UNCOLOR),\n/* harmony export */   \"print\": () => (/* binding */ print),\n/* harmony export */   \"warn\": () => (/* binding */ warn),\n/* harmony export */   \"printError\": () => (/* binding */ printError),\n/* harmony export */   \"printImg\": () => (/* binding */ printImg),\n/* harmony export */   \"printImgBase64\": () => (/* binding */ printImgBase64),\n/* harmony export */   \"group\": () => (/* binding */ group),\n/* harmony export */   \"groupCollapsed\": () => (/* binding */ groupCollapsed),\n/* harmony export */   \"groupEnd\": () => (/* binding */ groupEnd),\n/* harmony export */   \"printDom\": () => (/* binding */ printDom),\n/* harmony export */   \"printCanvas\": () => (/* binding */ printCanvas),\n/* harmony export */   \"vconsoles\": () => (/* binding */ vconsoles),\n/* harmony export */   \"VConsole\": () => (/* binding */ VConsole),\n/* harmony export */   \"createVConsole\": () => (/* binding */ createVConsole),\n/* harmony export */   \"createModuleLogger\": () => (/* binding */ createModuleLogger)\n/* harmony export */ });\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment.js */ \"./node_modules/lib0/environment.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol.js */ \"./node_modules/lib0/symbol.js\");\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pair.js */ \"./node_modules/lib0/pair.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ \"./node_modules/lib0/dom.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./json.js */ \"./node_modules/lib0/json.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var _eventloop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./eventloop.js */ \"./node_modules/lib0/eventloop.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math.js */ \"./node_modules/lib0/math.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./time.js */ \"./node_modules/lib0/time.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./function.js */ \"./node_modules/lib0/function.js\");\n/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst BOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNBOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst BLUE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREY = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREEN = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst RED = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst PURPLE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst ORANGE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNCOLOR = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [BOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'bold'),\n  [UNBOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'normal'),\n  [BLUE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'blue'),\n  [GREEN]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'green'),\n  [GREY]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'grey'),\n  [RED]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'red'),\n  [PURPLE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'purple'),\n  [ORANGE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'black')\n}\n\nconst _nodeStyleMap = {\n  [BOLD]: '\\u001b[1m',\n  [UNBOLD]: '\\u001b[2m',\n  [BLUE]: '\\x1b[34m',\n  [GREEN]: '\\x1b[32m',\n  [GREY]: '\\u001b[37m',\n  [RED]: '\\x1b[31m',\n  [PURPLE]: '\\x1b[35m',\n  [ORANGE]: '\\x1b[38;5;208m',\n  [UNCOLOR]: '\\x1b[0m'\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeBrowserLoggingArgs = args => {\n  const strBuilder = []\n  const styles = []\n  const currentStyle = _map_js__WEBPACK_IMPORTED_MODULE_2__.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNodeLoggingArgs = args => {\n  const strBuilder = []\n  const logArgs = []\n\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _nodeStyleMap[arg]\n    if (style !== undefined) {\n      strBuilder.push(style)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg)\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    strBuilder.push('\\x1b[0m')\n    logArgs.push(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    /* istanbul ignore else */\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/* istanbul ignore next */\nconst computeLoggingArgs = _environment_js__WEBPACK_IMPORTED_MODULE_4__.isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(ORANGE)\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Error} err\n */\nconst printError = err => {\n  console.error(err)\n  vconsoles.forEach(vc => vc.printError(err))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\nconst printImg = (url, height) => {\n  if (_environment_js__WEBPACK_IMPORTED_MODULE_4__.isBrowser) {\n    console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`)\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach(vc => vc.printImg(url, height))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} base64\n * @param {number} height\n */\nconst printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupCollapsed(args))\n}\n\nconst groupEnd = () => {\n  console.groupEnd()\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupEnd())\n}\n\n/* istanbul ignore next */\n/**\n * @param {function():Node} createNode\n */\nconst printDom = createNode =>\n  vconsoles.forEach(vc => vc.printDom(createNode()))\n\n/* istanbul ignore next */\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\nconst printCanvas = (canvas, height) => printImg(canvas.toDataURL(), height)\n\nconst vconsoles = new Set()\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\nconst _computeLineSpans = args => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle))], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(arg)])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + _json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(content) + ' '\n      }\n      spans.push(_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(/** @type {string} */ (content))]))\n    }\n  }\n  return spans\n}\n\nconst lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* istanbul ignore next */\nclass VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      const triangleDown = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:120%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('▼')])\n      const triangleRight = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', !collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:125%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('▶')])\n      const content = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], [triangleDown, triangleRight, _dom_js__WEBPACK_IMPORTED_MODULE_3__.text(' ')].concat(_computeLineSpans(args)))\n      const nextContainer = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed)])\n      const nextLine = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [], [content, nextContainer])\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.addEventListener(content, 'click', event => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], _computeLineSpans(args))])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([RED, BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('img', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('src', url), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('height', `${_math_js__WEBPACK_IMPORTED_MODULE_7__.round(height * 1.5)}px`)])])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @param {Element} dom\n */\nconst createVConsole = dom => new VConsole(dom)\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = _time_js__WEBPACK_IMPORTED_MODULE_8__.getUnixTime()\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = moduleName => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = _environment_js__WEBPACK_IMPORTED_MODULE_4__.getVariable('log')\n  const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n\n  return !doLogging ? _function_js__WEBPACK_IMPORTED_MODULE_9__.nop : (...args) => {\n    const timeNow = _time_js__WEBPACK_IMPORTED_MODULE_8__.getUnixTime()\n    const timeDiff = timeNow - lastLoggingTime\n    lastLoggingTime = timeNow\n    print(color, moduleName, UNCOLOR, ...args.map(arg => (typeof arg === 'string' || typeof arg === 'symbol') ? arg : JSON.stringify(arg)), color, ' +' + timeDiff + 'ms')\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL2xvZ2dpbmcuanM/Njc5ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QztBQUNGO0FBQ0o7QUFDRjtBQUNFO0FBQ0Y7QUFDWTtBQUNWO0FBQ0E7QUFDSTs7QUFFOUIsYUFBYSw4Q0FBYTtBQUMxQixlQUFlLDhDQUFhO0FBQzVCLGFBQWEsOENBQWE7QUFDMUIsYUFBYSw4Q0FBYTtBQUMxQixjQUFjLDhDQUFhO0FBQzNCLFlBQVksOENBQWE7QUFDekIsZUFBZSw4Q0FBYTtBQUM1QixlQUFlLDhDQUFhO0FBQzVCLGdCQUFnQiw4Q0FBYTs7QUFFcEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVUsNENBQVc7QUFDckIsWUFBWSw0Q0FBVztBQUN2QixVQUFVLDRDQUFXO0FBQ3JCLFdBQVcsNENBQVc7QUFDdEIsVUFBVSw0Q0FBVztBQUNyQixTQUFTLDRDQUFXO0FBQ3BCLFlBQVksNENBQVc7QUFDdkIsWUFBWSw0Q0FBVztBQUN2QixhQUFhLDRDQUFXO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQVU7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixxREFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1EQUFVOztBQUVyQztBQUNBLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNPO0FBQ1AsTUFBTSxzREFBYTtBQUNuQiwwREFBMEQsT0FBTyxHQUFHLDBCQUEwQiw4QkFBOEIseUJBQXlCLElBQUk7QUFDekosdURBQXVELE9BQU8sRUFBRSxtQkFBbUIsSUFBSSxZQUFZO0FBQ25HO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNPLG9FQUFvRSxTQUFTLE9BQU87O0FBRTNGO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxPQUFPO0FBQ2xCO0FBQ087O0FBRUE7O0FBRVA7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVcsVUFBVSw0Q0FBVyxVQUFVLHFEQUFvQixtQkFBbUIseUNBQVE7QUFDOUc7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUFjO0FBQ3RDO0FBQ0EsaUJBQWlCLDRDQUFXLGNBQWMseUNBQVEsWUFBWSxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxnQ0FBZ0MsWUFBWTs7QUFFckY7QUFDTztBQUNQO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLElBQUksa0RBQWlCO0FBQ3JCLDJCQUEyQiw0Q0FBVyxVQUFVLDRDQUFXLHVCQUF1Qiw0Q0FBVyxzQkFBc0IsZUFBZSxNQUFNLHlDQUFRO0FBQ2hKLDRCQUE0Qiw0Q0FBVyxVQUFVLDRDQUFXLHdCQUF3Qiw0Q0FBVyxzQkFBc0IsZUFBZSxNQUFNLHlDQUFRO0FBQ2xKLHNCQUFzQiw0Q0FBVyxTQUFTLDRDQUFXLGFBQWEsV0FBVyxlQUFlLGdCQUFnQixxQ0FBcUMseUNBQVE7QUFDekosNEJBQTRCLDRDQUFXLFNBQVMsNENBQVc7QUFDM0QsdUJBQXVCLDRDQUFXO0FBQ2xDLE1BQU0sMkNBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxrREFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJLGtEQUFpQjtBQUNyQixNQUFNLDJDQUFVLG1CQUFtQiw0Q0FBVyxTQUFTLDRDQUFXLGFBQWEsV0FBVyxlQUFlLGdCQUFnQjtBQUN6SCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJLGtEQUFpQjtBQUNyQixNQUFNLDJDQUFVLG1CQUFtQiw0Q0FBVyxTQUFTLDRDQUFXLGNBQWMsNENBQVcsY0FBYywyQ0FBVSxlQUFlO0FBQ2xJLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0EsSUFBSSxrREFBaUI7QUFDckIsTUFBTSwyQ0FBVTtBQUNoQixLQUFLO0FBQ0w7O0FBRUE7QUFDQSxJQUFJLGtEQUFpQjtBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDTzs7QUFFUDtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFnQjs7QUFFdEM7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLHdCQUF3Qix3REFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDZDQUFRO0FBQzlCLG9CQUFvQixpREFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2xvZ2dpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIElzb21vcnBoaWMgbG9nZ2luZyBtb2R1bGUgd2l0aCBzdXBwb3J0IGZvciBjb2xvcnMhXG4gKlxuICogQG1vZHVsZSBsb2dnaW5nXG4gKi9cblxuaW1wb3J0ICogYXMgZW52IGZyb20gJy4vZW52aXJvbm1lbnQuanMnXG5pbXBvcnQgKiBhcyBzeW1ib2wgZnJvbSAnLi9zeW1ib2wuanMnXG5pbXBvcnQgKiBhcyBwYWlyIGZyb20gJy4vcGFpci5qcydcbmltcG9ydCAqIGFzIGRvbSBmcm9tICcuL2RvbS5qcydcbmltcG9ydCAqIGFzIGpzb24gZnJvbSAnLi9qc29uLmpzJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgZXZlbnRsb29wIGZyb20gJy4vZXZlbnRsb29wLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJy4vdGltZS5qcydcbmltcG9ydCAqIGFzIGZ1bmMgZnJvbSAnLi9mdW5jdGlvbi5qcydcblxuZXhwb3J0IGNvbnN0IEJPTEQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBVTkJPTEQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBCTFVFID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgR1JFWSA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IEdSRUVOID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgUkVEID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgUFVSUExFID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgT1JBTkdFID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgVU5DT0xPUiA9IHN5bWJvbC5jcmVhdGUoKVxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8U3ltYm9sLHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPj59XG4gKi9cbmNvbnN0IF9icm93c2VyU3R5bGVNYXAgPSB7XG4gIFtCT0xEXTogcGFpci5jcmVhdGUoJ2ZvbnQtd2VpZ2h0JywgJ2JvbGQnKSxcbiAgW1VOQk9MRF06IHBhaXIuY3JlYXRlKCdmb250LXdlaWdodCcsICdub3JtYWwnKSxcbiAgW0JMVUVdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnYmx1ZScpLFxuICBbR1JFRU5dOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnZ3JlZW4nKSxcbiAgW0dSRVldOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnZ3JleScpLFxuICBbUkVEXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ3JlZCcpLFxuICBbUFVSUExFXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ3B1cnBsZScpLFxuICBbT1JBTkdFXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ29yYW5nZScpLCAvLyBub3Qgd2VsbCBzdXBwb3J0ZWQgaW4gY2hyb21lIHdoZW4gZGVidWdnaW5nIG5vZGUgd2l0aCBpbnNwZWN0b3IgLSBUT0RPOiBkZXByZWNhdGVcbiAgW1VOQ09MT1JdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnYmxhY2snKVxufVxuXG5jb25zdCBfbm9kZVN0eWxlTWFwID0ge1xuICBbQk9MRF06ICdcXHUwMDFiWzFtJyxcbiAgW1VOQk9MRF06ICdcXHUwMDFiWzJtJyxcbiAgW0JMVUVdOiAnXFx4MWJbMzRtJyxcbiAgW0dSRUVOXTogJ1xceDFiWzMybScsXG4gIFtHUkVZXTogJ1xcdTAwMWJbMzdtJyxcbiAgW1JFRF06ICdcXHgxYlszMW0nLFxuICBbUFVSUExFXTogJ1xceDFiWzM1bScsXG4gIFtPUkFOR0VdOiAnXFx4MWJbMzg7NTsyMDhtJyxcbiAgW1VOQ09MT1JdOiAnXFx4MWJbMG0nXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG9iamVjdHxudW1iZXI+fVxuICovXG5jb25zdCBjb21wdXRlQnJvd3NlckxvZ2dpbmdBcmdzID0gYXJncyA9PiB7XG4gIGNvbnN0IHN0ckJ1aWxkZXIgPSBbXVxuICBjb25zdCBzdHlsZXMgPSBbXVxuICBjb25zdCBjdXJyZW50U3R5bGUgPSBtYXAuY3JlYXRlKClcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmd8T2JqZWN0fG51bWJlcj59XG4gICAqL1xuICBsZXQgbG9nQXJncyA9IFtdXG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwXG5cbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9icm93c2VyU3R5bGVNYXBbYXJnXVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdXJyZW50U3R5bGUuc2V0KHN0eWxlLmxlZnQsIHN0eWxlLnJpZ2h0KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgfHwgYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBkb20ubWFwVG9TdHlsZVN0cmluZyhjdXJyZW50U3R5bGUpXG4gICAgICAgIGlmIChpID4gMCB8fCBzdHlsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3RyQnVpbGRlci5wdXNoKCclYycgKyBhcmcpXG4gICAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyQnVpbGRlci5wdXNoKGFyZylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaSA+IDApIHtcbiAgICAvLyBjcmVhdGUgbG9nQXJncyB3aXRoIHdoYXQgd2UgaGF2ZSBzbyBmYXJcbiAgICBsb2dBcmdzID0gc3R5bGVzXG4gICAgbG9nQXJncy51bnNoaWZ0KHN0ckJ1aWxkZXIuam9pbignJykpXG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBsb2dBcmdzLnB1c2goYXJnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbG9nQXJnc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG9iamVjdHxudW1iZXI+fVxuICovXG5jb25zdCBjb21wdXRlTm9kZUxvZ2dpbmdBcmdzID0gYXJncyA9PiB7XG4gIGNvbnN0IHN0ckJ1aWxkZXIgPSBbXVxuICBjb25zdCBsb2dBcmdzID0gW11cblxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuXG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3R5bGUgPSBfbm9kZVN0eWxlTWFwW2FyZ11cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RyQnVpbGRlci5wdXNoKHN0eWxlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgfHwgYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgc3RyQnVpbGRlci5wdXNoKGFyZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpID4gMCkge1xuICAgIC8vIGNyZWF0ZSBsb2dBcmdzIHdpdGggd2hhdCB3ZSBoYXZlIHNvIGZhclxuICAgIHN0ckJ1aWxkZXIucHVzaCgnXFx4MWJbMG0nKVxuICAgIGxvZ0FyZ3MucHVzaChzdHJCdWlsZGVyLmpvaW4oJycpKVxuICB9XG4gIC8vIGFwcGVuZCB0aGUgcmVzdFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBsb2dBcmdzLnB1c2goYXJnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbG9nQXJnc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgY29tcHV0ZUxvZ2dpbmdBcmdzID0gZW52LmlzTm9kZSA/IGNvbXB1dGVOb2RlTG9nZ2luZ0FyZ3MgOiBjb21wdXRlQnJvd3NlckxvZ2dpbmdBcmdzXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBwcmludCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUubG9nKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnQoYXJncykpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5leHBvcnQgY29uc3Qgd2FybiA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUud2FybiguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIGFyZ3MudW5zaGlmdChPUkFOR0UpXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLnByaW50KGFyZ3MpKVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW50RXJyb3IgPSBlcnIgPT4ge1xuICBjb25zb2xlLmVycm9yKGVycilcbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnRFcnJvcihlcnIpKVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIGltYWdlIGxvY2F0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodCBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nID0gKHVybCwgaGVpZ2h0KSA9PiB7XG4gIGlmIChlbnYuaXNCcm93c2VyKSB7XG4gICAgY29uc29sZS5sb2coJyVjICAgICAgICAgICAgICAgICAgICAgICcsIGBmb250LXNpemU6ICR7aGVpZ2h0fXB4OyBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7IGJhY2tncm91bmQtaW1hZ2U6IHVybCgke3VybH0pYClcbiAgICAvLyBjb25zb2xlLmxvZygnJWMgICAgICAgICAgICAgICAgJywgYGZvbnQtc2l6ZTogJHtoZWlnaHR9eDsgYmFja2dyb3VuZDogdXJsKCR7dXJsfSkgbm8tcmVwZWF0O2ApXG4gIH1cbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnRJbWcodXJsLCBoZWlnaHQpKVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBwcmludEltZ0Jhc2U2NCA9IChiYXNlNjQsIGhlaWdodCkgPT4gcHJpbnRJbWcoYGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCwke2Jhc2U2NH1gLCBoZWlnaHQpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBncm91cCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXAoLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5ncm91cChhcmdzKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwQ29sbGFwc2VkID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5ncm91cENvbGxhcHNlZCguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLmdyb3VwQ29sbGFwc2VkKGFyZ3MpKVxufVxuXG5leHBvcnQgY29uc3QgZ3JvdXBFbmQgPSAoKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5ncm91cEVuZCgpKVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6Tm9kZX0gY3JlYXRlTm9kZVxuICovXG5leHBvcnQgY29uc3QgcHJpbnREb20gPSBjcmVhdGVOb2RlID0+XG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLnByaW50RG9tKGNyZWF0ZU5vZGUoKSkpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICovXG5leHBvcnQgY29uc3QgcHJpbnRDYW52YXMgPSAoY2FudmFzLCBoZWlnaHQpID0+IHByaW50SW1nKGNhbnZhcy50b0RhdGFVUkwoKSwgaGVpZ2h0KVxuXG5leHBvcnQgY29uc3QgdmNvbnNvbGVzID0gbmV3IFNldCgpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8RWxlbWVudD59XG4gKi9cbmNvbnN0IF9jb21wdXRlTGluZVNwYW5zID0gYXJncyA9PiB7XG4gIGNvbnN0IHNwYW5zID0gW11cbiAgY29uc3QgY3VycmVudFN0eWxlID0gbmV3IE1hcCgpXG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwXG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3R5bGUgPSBfYnJvd3NlclN0eWxlTWFwW2FyZ11cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudFN0eWxlLnNldChzdHlsZS5sZWZ0LCBzdHlsZS5yaWdodClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvbS5lbGVtZW50KCdzcGFuJywgW3BhaXIuY3JlYXRlKCdzdHlsZScsIGRvbS5tYXBUb1N0eWxlU3RyaW5nKGN1cnJlbnRTdHlsZSkpXSwgW2RvbS50ZXh0KGFyZyldKVxuICAgICAgICBpZiAoc3Bhbi5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgICAgICAgc3Bhbi5pbm5lckhUTUwgPSAnJm5ic3A7J1xuICAgICAgICB9XG4gICAgICAgIHNwYW5zLnB1c2goc3BhbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGFwcGVuZCB0aGUgcmVzdFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY29udGVudCA9IGFyZ3NbaV1cbiAgICBpZiAoIShjb250ZW50IGluc3RhbmNlb2YgU3ltYm9sKSkge1xuICAgICAgaWYgKGNvbnRlbnQuY29uc3RydWN0b3IgIT09IFN0cmluZyAmJiBjb250ZW50LmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpIHtcbiAgICAgICAgY29udGVudCA9ICcgJyArIGpzb24uc3RyaW5naWZ5KGNvbnRlbnQpICsgJyAnXG4gICAgICB9XG4gICAgICBzcGFucy5wdXNoKGRvbS5lbGVtZW50KCdzcGFuJywgW10sIFtkb20udGV4dCgvKiogQHR5cGUge3N0cmluZ30gKi8gKGNvbnRlbnQpKV0pKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3BhbnNcbn1cblxuY29uc3QgbGluZVN0eWxlID0gJ2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZTJlMmUyO3BhZGRpbmc6MnB4OydcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjbGFzcyBWQ29uc29sZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvbSkge1xuICAgIHRoaXMuZG9tID0gZG9tXG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jY29udGFpbmVyID0gdGhpcy5kb21cbiAgICB0aGlzLmRlcHRoID0gMFxuICAgIHZjb25zb2xlcy5hZGQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzZWRcbiAgICovXG4gIGdyb3VwIChhcmdzLCBjb2xsYXBzZWQgPSBmYWxzZSkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyaWFuZ2xlRG93biA9IGRvbS5lbGVtZW50KCdzcGFuJywgW3BhaXIuY3JlYXRlKCdoaWRkZW4nLCBjb2xsYXBzZWQpLCBwYWlyLmNyZWF0ZSgnc3R5bGUnLCAnY29sb3I6Z3JleTtmb250LXNpemU6MTIwJTsnKV0sIFtkb20udGV4dCgn4pa8JyldKVxuICAgICAgY29uc3QgdHJpYW5nbGVSaWdodCA9IGRvbS5lbGVtZW50KCdzcGFuJywgW3BhaXIuY3JlYXRlKCdoaWRkZW4nLCAhY29sbGFwc2VkKSwgcGFpci5jcmVhdGUoJ3N0eWxlJywgJ2NvbG9yOmdyZXk7Zm9udC1zaXplOjEyNSU7JyldLCBbZG9tLnRleHQoJ+KWticpXSlcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb20uZWxlbWVudCgnZGl2JywgW3BhaXIuY3JlYXRlKCdzdHlsZScsIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YCldLCBbdHJpYW5nbGVEb3duLCB0cmlhbmdsZVJpZ2h0LCBkb20udGV4dCgnICcpXS5jb25jYXQoX2NvbXB1dGVMaW5lU3BhbnMoYXJncykpKVxuICAgICAgY29uc3QgbmV4dENvbnRhaW5lciA9IGRvbS5lbGVtZW50KCdkaXYnLCBbcGFpci5jcmVhdGUoJ2hpZGRlbicsIGNvbGxhcHNlZCldKVxuICAgICAgY29uc3QgbmV4dExpbmUgPSBkb20uZWxlbWVudCgnZGl2JywgW10sIFtjb250ZW50LCBuZXh0Q29udGFpbmVyXSlcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbbmV4dExpbmVdKVxuICAgICAgdGhpcy5jY29udGFpbmVyID0gbmV4dENvbnRhaW5lclxuICAgICAgdGhpcy5kZXB0aCsrXG4gICAgICAvLyB3aGVuIGhlYWRlciBpcyBjbGlja2VkLCBjb2xsYXBzZS91bmNvbGxhcHNlIGNvbnRhaW5lclxuICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoY29udGVudCwgJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICBuZXh0Q29udGFpbmVyLnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJylcbiAgICAgICAgdHJpYW5nbGVEb3duLnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJylcbiAgICAgICAgdHJpYW5nbGVSaWdodC50b2dnbGVBdHRyaWJ1dGUoJ2hpZGRlbicpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gICAqL1xuICBncm91cENvbGxhcHNlZCAoYXJncykge1xuICAgIHRoaXMuZ3JvdXAoYXJncywgdHJ1ZSlcbiAgfVxuXG4gIGdyb3VwRW5kICgpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXB0aCA+IDApIHtcbiAgICAgICAgdGhpcy5kZXB0aC0tXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5jY29udGFpbmVyID0gdGhpcy5jY29udGFpbmVyLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gICAqL1xuICBwcmludCAoYXJncykge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbZG9tLmVsZW1lbnQoJ2RpdicsIFtwYWlyLmNyZWF0ZSgnc3R5bGUnLCBgJHtsaW5lU3R5bGV9O3BhZGRpbmctbGVmdDoke3RoaXMuZGVwdGggKiAxMH1weGApXSwgX2NvbXB1dGVMaW5lU3BhbnMoYXJncykpXSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKi9cbiAgcHJpbnRFcnJvciAoZXJyKSB7XG4gICAgdGhpcy5wcmludChbUkVELCBCT0xELCBlcnIudG9TdHJpbmcoKV0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAqL1xuICBwcmludEltZyAodXJsLCBoZWlnaHQpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW2RvbS5lbGVtZW50KCdpbWcnLCBbcGFpci5jcmVhdGUoJ3NyYycsIHVybCksIHBhaXIuY3JlYXRlKCdoZWlnaHQnLCBgJHttYXRoLnJvdW5kKGhlaWdodCAqIDEuNSl9cHhgKV0pXSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKi9cbiAgcHJpbnREb20gKG5vZGUpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW25vZGVdKVxuICAgIH0pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICB2Y29uc29sZXMuZGVsZXRlKHRoaXMpXG4gICAgfSlcbiAgfVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVkNvbnNvbGUgPSBkb20gPT4gbmV3IFZDb25zb2xlKGRvbSlcblxuY29uc3QgbG9nZ2luZ0NvbG9ycyA9IFtHUkVFTiwgUFVSUExFLCBPUkFOR0UsIEJMVUVdXG5sZXQgbmV4dENvbG9yID0gMFxubGV0IGxhc3RMb2dnaW5nVGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5hbnkpOnZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNb2R1bGVMb2dnZXIgPSBtb2R1bGVOYW1lID0+IHtcbiAgY29uc3QgY29sb3IgPSBsb2dnaW5nQ29sb3JzW25leHRDb2xvcl1cbiAgY29uc3QgZGVidWdSZWdleFZhciA9IGVudi5nZXRWYXJpYWJsZSgnbG9nJylcbiAgY29uc3QgZG9Mb2dnaW5nID0gZGVidWdSZWdleFZhciAhPT0gbnVsbCAmJiAoZGVidWdSZWdleFZhciA9PT0gJyonIHx8IGRlYnVnUmVnZXhWYXIgPT09ICd0cnVlJyB8fCBuZXcgUmVnRXhwKGRlYnVnUmVnZXhWYXIsICdnaScpLnRlc3QobW9kdWxlTmFtZSkpXG4gIG5leHRDb2xvciA9IChuZXh0Q29sb3IgKyAxKSAlIGxvZ2dpbmdDb2xvcnMubGVuZ3RoXG4gIG1vZHVsZU5hbWUgKz0gJzogJ1xuXG4gIHJldHVybiAhZG9Mb2dnaW5nID8gZnVuYy5ub3AgOiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHRpbWVOb3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICBjb25zdCB0aW1lRGlmZiA9IHRpbWVOb3cgLSBsYXN0TG9nZ2luZ1RpbWVcbiAgICBsYXN0TG9nZ2luZ1RpbWUgPSB0aW1lTm93XG4gICAgcHJpbnQoY29sb3IsIG1vZHVsZU5hbWUsIFVOQ09MT1IsIC4uLmFyZ3MubWFwKGFyZyA9PiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcpID8gYXJnIDogSlNPTi5zdHJpbmdpZnkoYXJnKSksIGNvbG9yLCAnICsnICsgdGltZURpZmYgKyAnbXMnKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/logging.js\n")},"./node_modules/lib0/map.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "copy": () => (/* binding */ copy),\n/* harmony export */   "setIfUndefined": () => (/* binding */ setIfUndefined),\n/* harmony export */   "map": () => (/* binding */ map),\n/* harmony export */   "any": () => (/* binding */ any),\n/* harmony export */   "all": () => (/* binding */ all)\n/* harmony export */ });\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nconst copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, \'eventName\', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template T,K\n * @param {Map<K, T>} map\n * @param {K} key\n * @param {function():T} createT\n * @return {T}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nconst map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL21hcC5qcz8yMzA5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEVBQUU7QUFDYixXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxnQkFBZ0I7QUFDM0IsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLHNCQUFzQjtBQUNqQyxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLHNCQUFzQjtBQUNqQyxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGgga2V5LXZhbHVlIHN0b3Jlcy5cbiAqXG4gKiBAbW9kdWxlIG1hcFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBNYXAgaW5zdGFuY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtNYXA8YW55LCBhbnk+fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKCkgPT4gbmV3IE1hcCgpXG5cbi8qKlxuICogQ29weSBhIE1hcCBvYmplY3QgaW50byBhIGZyZXNoIE1hcCBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgWCxZXG4gKiBAcGFyYW0ge01hcDxYLFk+fSBtXG4gKiBAcmV0dXJuIHtNYXA8WCxZPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHkgPSBtID0+IHtcbiAgY29uc3QgciA9IGNyZWF0ZSgpXG4gIG0uZm9yRWFjaCgodiwgaykgPT4geyByLnNldChrLCB2KSB9KVxuICByZXR1cm4gclxufVxuXG4vKipcbiAqIEdldCBtYXAgcHJvcGVydHkuIENyZWF0ZSBUIGlmIHByb3BlcnR5IGlzIHVuZGVmaW5lZCBhbmQgc2V0IFQgb24gbWFwLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaXN0ZW5lcnMgPSBtYXAuc2V0SWZVbmRlZmluZWQoZXZlbnRzLCAnZXZlbnROYW1lJywgc2V0LmNyZWF0ZSlcbiAqIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpXG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBULEtcbiAqIEBwYXJhbSB7TWFwPEssIFQ+fSBtYXBcbiAqIEBwYXJhbSB7S30ga2V5XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6VH0gY3JlYXRlVFxuICogQHJldHVybiB7VH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldElmVW5kZWZpbmVkID0gKG1hcCwga2V5LCBjcmVhdGVUKSA9PiB7XG4gIGxldCBzZXQgPSBtYXAuZ2V0KGtleSlcbiAgaWYgKHNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFwLnNldChrZXksIHNldCA9IGNyZWF0ZVQoKSlcbiAgfVxuICByZXR1cm4gc2V0XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBBcnJheSBhbmQgcG9wdWxhdGVzIGl0IHdpdGggdGhlIGNvbnRlbnQgb2YgYWxsIGtleS12YWx1ZSBwYWlycyB1c2luZyB0aGUgYGYodmFsdWUsIGtleSlgIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIEtcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAdGVtcGxhdGUgUlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOlJ9IGZcbiAqIEByZXR1cm4ge0FycmF5PFI+fVxuICovXG5leHBvcnQgY29uc3QgbWFwID0gKG0sIGYpID0+IHtcbiAgY29uc3QgcmVzID0gW11cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIHJlcy5wdXNoKGYodmFsdWUsIGtleSkpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgYW55IGtleS12YWx1ZSBwYWlycyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IGBmKHZhbHVlLCBrZXkpYC5cbiAqXG4gKiBAdG9kbyBzaG91bGQgcmVuYW1lIHRvIHNvbWUgLSBzaW1pbGFybHkgdG8gQXJyYXkuc29tZVxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIEtcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge01hcDxLLFY+fSBtXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFYsSyk6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFueSA9IChtLCBmKSA9PiB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG0pIHtcbiAgICBpZiAoZih2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBhbGwga2V5LXZhbHVlIHBhaXJzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgYGYodmFsdWUsIGtleSlgLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIEtcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge01hcDxLLFY+fSBtXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFYsSyk6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFsbCA9IChtLCBmKSA9PiB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG0pIHtcbiAgICBpZiAoIWYodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/map.js\n')},"./node_modules/lib0/math.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "floor": () => (/* binding */ floor),\n/* harmony export */   "ceil": () => (/* binding */ ceil),\n/* harmony export */   "abs": () => (/* binding */ abs),\n/* harmony export */   "imul": () => (/* binding */ imul),\n/* harmony export */   "round": () => (/* binding */ round),\n/* harmony export */   "log10": () => (/* binding */ log10),\n/* harmony export */   "log2": () => (/* binding */ log2),\n/* harmony export */   "log": () => (/* binding */ log),\n/* harmony export */   "sqrt": () => (/* binding */ sqrt),\n/* harmony export */   "add": () => (/* binding */ add),\n/* harmony export */   "min": () => (/* binding */ min),\n/* harmony export */   "max": () => (/* binding */ max),\n/* harmony export */   "isNaN": () => (/* binding */ isNaN),\n/* harmony export */   "pow": () => (/* binding */ pow),\n/* harmony export */   "exp10": () => (/* binding */ exp10),\n/* harmony export */   "sign": () => (/* binding */ sign),\n/* harmony export */   "isNegativeZero": () => (/* binding */ isNegativeZero)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor\nconst ceil = Math.ceil\nconst abs = Math.abs\nconst imul = Math.imul\nconst round = Math.round\nconst log10 = Math.log10\nconst log2 = Math.log2\nconst log = Math.log\nconst sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nconst add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b\n\nconst isNaN = Number.isNaN\n\nconst pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nconst exp10 = exp => Math.pow(10, exp)\n\nconst sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nconst isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL21hdGguanM/Y2EwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNPOztBQUVBOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPOztBQUVBOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvbWF0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tbW9uIE1hdGggZXhwcmVzc2lvbnMuXG4gKlxuICogQG1vZHVsZSBtYXRoXG4gKi9cblxuZXhwb3J0IGNvbnN0IGZsb29yID0gTWF0aC5mbG9vclxuZXhwb3J0IGNvbnN0IGNlaWwgPSBNYXRoLmNlaWxcbmV4cG9ydCBjb25zdCBhYnMgPSBNYXRoLmFic1xuZXhwb3J0IGNvbnN0IGltdWwgPSBNYXRoLmltdWxcbmV4cG9ydCBjb25zdCByb3VuZCA9IE1hdGgucm91bmRcbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTBcbmV4cG9ydCBjb25zdCBsb2cyID0gTWF0aC5sb2cyXG5leHBvcnQgY29uc3QgbG9nID0gTWF0aC5sb2dcbmV4cG9ydCBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHN1bSBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBjb25zdCBhZGQgPSAoYSwgYikgPT4gYSArIGJcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc21hbGxlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IG1pbiA9IChhLCBiKSA9PiBhIDwgYiA/IGEgOiBiXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJpZ2dlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IG1heCA9IChhLCBiKSA9PiBhID4gYiA/IGEgOiBiXG5cbmV4cG9ydCBjb25zdCBpc05hTiA9IE51bWJlci5pc05hTlxuXG5leHBvcnQgY29uc3QgcG93ID0gTWF0aC5wb3dcbi8qKlxuICogQmFzZSAxMCBleHBvbmVudGlhbCBmdW5jdGlvbi4gUmV0dXJucyB0aGUgdmFsdWUgb2YgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZiBwb3cuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGV4cFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZXhwMTAgPSBleHAgPT4gTWF0aC5wb3coMTAsIGV4cClcblxuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ25cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHJldHVybiB7Ym9vbGVhbn0gV2V0aGVyIG4gaXMgbmVnYXRpdmUuIFRoaXMgZnVuY3Rpb24gYWxzbyBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIC0wIGFuZCArMFxuICovXG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSBuID0+IG4gIT09IDAgPyBuIDwgMCA6IDEgLyBuIDwgMFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/math.js\n')},"./node_modules/lib0/metric.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "yotta": () => (/* binding */ yotta),\n/* harmony export */   "zetta": () => (/* binding */ zetta),\n/* harmony export */   "exa": () => (/* binding */ exa),\n/* harmony export */   "peta": () => (/* binding */ peta),\n/* harmony export */   "tera": () => (/* binding */ tera),\n/* harmony export */   "giga": () => (/* binding */ giga),\n/* harmony export */   "mega": () => (/* binding */ mega),\n/* harmony export */   "kilo": () => (/* binding */ kilo),\n/* harmony export */   "hecto": () => (/* binding */ hecto),\n/* harmony export */   "deca": () => (/* binding */ deca),\n/* harmony export */   "deci": () => (/* binding */ deci),\n/* harmony export */   "centi": () => (/* binding */ centi),\n/* harmony export */   "milli": () => (/* binding */ milli),\n/* harmony export */   "micro": () => (/* binding */ micro),\n/* harmony export */   "nano": () => (/* binding */ nano),\n/* harmony export */   "pico": () => (/* binding */ pico),\n/* harmony export */   "femto": () => (/* binding */ femto),\n/* harmony export */   "atto": () => (/* binding */ atto),\n/* harmony export */   "zepto": () => (/* binding */ zepto),\n/* harmony export */   "yocto": () => (/* binding */ yocto),\n/* harmony export */   "prefix": () => (/* binding */ prefix)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/**\n * Utility module to convert metric values.\n *\n * @module metric\n */\n\n\n\nconst yotta = 1e24\nconst zetta = 1e21\nconst exa = 1e18\nconst peta = 1e15\nconst tera = 1e12\nconst giga = 1e9\nconst mega = 1e6\nconst kilo = 1e3\nconst hecto = 1e2\nconst deca = 10\nconst deci = 0.1\nconst centi = 0.01\nconst milli = 1e-3\nconst micro = 1e-6\nconst nano = 1e-9\nconst pico = 1e-12\nconst femto = 1e-15\nconst atto = 1e-18\nconst zepto = 1e-21\nconst yocto = 1e-24\n\nconst prefixUp = [\'\', \'k\', \'M\', \'G\', \'T\', \'P\', \'E\', \'Z\', \'Y\']\nconst prefixDown = [\'\', \'m\', \'μ\', \'n\', \'p\', \'f\', \'a\', \'z\', \'y\']\n\n/**\n * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: \'k\' }`\n *\n * @param {number} n\n * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds\n * @return {{n:number,prefix:string}}\n */\nconst prefix = (n, baseMultiplier = 0) => {\n  const nPow = n === 0 ? 0 : _math_js__WEBPACK_IMPORTED_MODULE_0__.log10(n)\n  let mult = 0\n  while (nPow < mult * 3 && baseMultiplier > -8) {\n    baseMultiplier--\n    mult--\n  }\n  while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {\n    baseMultiplier++\n    mult++\n  }\n  const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier]\n  return {\n    n: _math_js__WEBPACK_IMPORTED_MODULE_0__.round((mult > 0 ? n / _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * 3) : n * _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * -3)) * 1e12) / 1e12,\n    prefix\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL21ldHJpYy5qcz9hMDgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFLG9CQUFvQjtBQUMvRjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsMkNBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMkNBQVUsaUJBQWlCLDJDQUFVLGlCQUFpQiwyQ0FBVTtBQUN2RTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9tZXRyaWMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIGNvbnZlcnQgbWV0cmljIHZhbHVlcy5cbiAqXG4gKiBAbW9kdWxlIG1ldHJpY1xuICovXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuXG5leHBvcnQgY29uc3QgeW90dGEgPSAxZTI0XG5leHBvcnQgY29uc3QgemV0dGEgPSAxZTIxXG5leHBvcnQgY29uc3QgZXhhID0gMWUxOFxuZXhwb3J0IGNvbnN0IHBldGEgPSAxZTE1XG5leHBvcnQgY29uc3QgdGVyYSA9IDFlMTJcbmV4cG9ydCBjb25zdCBnaWdhID0gMWU5XG5leHBvcnQgY29uc3QgbWVnYSA9IDFlNlxuZXhwb3J0IGNvbnN0IGtpbG8gPSAxZTNcbmV4cG9ydCBjb25zdCBoZWN0byA9IDFlMlxuZXhwb3J0IGNvbnN0IGRlY2EgPSAxMFxuZXhwb3J0IGNvbnN0IGRlY2kgPSAwLjFcbmV4cG9ydCBjb25zdCBjZW50aSA9IDAuMDFcbmV4cG9ydCBjb25zdCBtaWxsaSA9IDFlLTNcbmV4cG9ydCBjb25zdCBtaWNybyA9IDFlLTZcbmV4cG9ydCBjb25zdCBuYW5vID0gMWUtOVxuZXhwb3J0IGNvbnN0IHBpY28gPSAxZS0xMlxuZXhwb3J0IGNvbnN0IGZlbXRvID0gMWUtMTVcbmV4cG9ydCBjb25zdCBhdHRvID0gMWUtMThcbmV4cG9ydCBjb25zdCB6ZXB0byA9IDFlLTIxXG5leHBvcnQgY29uc3QgeW9jdG8gPSAxZS0yNFxuXG5jb25zdCBwcmVmaXhVcCA9IFsnJywgJ2snLCAnTScsICdHJywgJ1QnLCAnUCcsICdFJywgJ1onLCAnWSddXG5jb25zdCBwcmVmaXhEb3duID0gWycnLCAnbScsICfOvCcsICduJywgJ3AnLCAnZicsICdhJywgJ3onLCAneSddXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBtZXRyaWMgcHJlZml4IGZvciBhIG51bWJlci4gQXNzdW1lcyBFLmcuIGBwcmVmaXgoMTAwMCkgPSB7IG46IDEsIHByZWZpeDogJ2snIH1gXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYmFzZU11bHRpcGxpZXJdIE11bHRpcGxpZXIgb2YgdGhlIGJhc2UgKDEwXigzKmJhc2VNdWx0aXBsaWVyKSkuIEUuZy4gYGNvbnZlcnQodGltZSwgLTMpYCBpZiB0aW1lIGlzIGFscmVhZHkgaW4gbWlsbGkgc2Vjb25kc1xuICogQHJldHVybiB7e246bnVtYmVyLHByZWZpeDpzdHJpbmd9fVxuICovXG5leHBvcnQgY29uc3QgcHJlZml4ID0gKG4sIGJhc2VNdWx0aXBsaWVyID0gMCkgPT4ge1xuICBjb25zdCBuUG93ID0gbiA9PT0gMCA/IDAgOiBtYXRoLmxvZzEwKG4pXG4gIGxldCBtdWx0ID0gMFxuICB3aGlsZSAoblBvdyA8IG11bHQgKiAzICYmIGJhc2VNdWx0aXBsaWVyID4gLTgpIHtcbiAgICBiYXNlTXVsdGlwbGllci0tXG4gICAgbXVsdC0tXG4gIH1cbiAgd2hpbGUgKG5Qb3cgPj0gMyArIG11bHQgKiAzICYmIGJhc2VNdWx0aXBsaWVyIDwgOCkge1xuICAgIGJhc2VNdWx0aXBsaWVyKytcbiAgICBtdWx0KytcbiAgfVxuICBjb25zdCBwcmVmaXggPSBiYXNlTXVsdGlwbGllciA8IDAgPyBwcmVmaXhEb3duWy1iYXNlTXVsdGlwbGllcl0gOiBwcmVmaXhVcFtiYXNlTXVsdGlwbGllcl1cbiAgcmV0dXJuIHtcbiAgICBuOiBtYXRoLnJvdW5kKChtdWx0ID4gMCA/IG4gLyBtYXRoLmV4cDEwKG11bHQgKiAzKSA6IG4gKiBtYXRoLmV4cDEwKG11bHQgKiAtMykpICogMWUxMikgLyAxZTEyLFxuICAgIHByZWZpeFxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/metric.js\n')},"./node_modules/lib0/mutex.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createMutex": () => (/* binding */ createMutex)\n/* harmony export */ });\n/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nconst createMutex = () => {\n  let token = true\n  return (f, g) => {\n    if (token) {\n      token = false\n      try {\n        f()\n      } finally {\n        token = true\n      }\n    } else if (g !== undefined) {\n      g()\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL211dGV4LmpzPzNlZGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsZ0JBQWdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL211dGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNdXR1YWwgZXhjbHVkZSBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11dGV4XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgbXV0ZXhcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBjYiBPbmx5IGV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBub3QgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBbZWxzZUNiXSBFeGVjdXRlZCB3aGVuIHRoaXMgbXV0ZXggaXMgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtdXR1YWwgZXhjbHVkZSBmdW5jdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG11dGV4ID0gY3JlYXRlTXV0ZXgoKVxuICogbXV0ZXgoKCkgPT4ge1xuICogICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGltbWVkaWF0ZWx5IGV4ZWN1dGVkXG4gKiAgIG11dGV4KCgpID0+IHtcbiAqICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYXMgdGhlIG11dGV4IGlzIGFscmVhZHkgYWN0aXZlLlxuICogICB9KVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEByZXR1cm4ge211dGV4fSBBIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNdXRleCA9ICgpID0+IHtcbiAgbGV0IHRva2VuID0gdHJ1ZVxuICByZXR1cm4gKGYsIGcpID0+IHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHRva2VuID0gZmFsc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGYoKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdG9rZW4gPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGcoKVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/mutex.js\n')},"./node_modules/lib0/number.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "MAX_SAFE_INTEGER": () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   "MIN_SAFE_INTEGER": () => (/* binding */ MIN_SAFE_INTEGER),\n/* harmony export */   "LOWEST_INT32": () => (/* binding */ LOWEST_INT32),\n/* harmony export */   "HIGHEST_INT32": () => (/* binding */ HIGHEST_INT32),\n/* harmony export */   "isInteger": () => (/* binding */ isInteger),\n/* harmony export */   "isNaN": () => (/* binding */ isNaN)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary.js */ "./node_modules/lib0/binary.js");\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nconst MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nconst LOWEST_INT32 = 1 << 31\n/**\n * @type {number}\n */\nconst HIGHEST_INT32 = _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS31\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nconst isInteger = Number.isInteger || (num => typeof num === \'number\' && isFinite(num) && _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num) === num)\nconst isNaN = Number.isNaN\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL251bWJlci5qcz9lMTc1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7QUFDSTs7QUFFOUI7QUFDQTs7QUFFQTtBQUNQO0FBQ0EsVUFBVTtBQUNWO0FBQ08sc0JBQXNCLDhDQUFhOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDTywwRkFBMEYsMkNBQVU7QUFDcEciLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9udW1iZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIG51bWJlcnMuXG4gKlxuICogQG1vZHVsZSBudW1iZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcblxuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuZXhwb3J0IGNvbnN0IE1JTl9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuXG5leHBvcnQgY29uc3QgTE9XRVNUX0lOVDMyID0gMSA8PCAzMVxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgSElHSEVTVF9JTlQzMiA9IGJpbmFyeS5CSVRTMzFcblxuLyoqXG4gKiBAbW9kdWxlIG51bWJlclxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAobnVtID0+IHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIGlzRmluaXRlKG51bSkgJiYgbWF0aC5mbG9vcihudW0pID09PSBudW0pXG5leHBvcnQgY29uc3QgaXNOYU4gPSBOdW1iZXIuaXNOYU5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/number.js\n')},"./node_modules/lib0/object.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "assign": () => (/* binding */ assign),\n/* harmony export */   "keys": () => (/* binding */ keys),\n/* harmony export */   "forEach": () => (/* binding */ forEach),\n/* harmony export */   "map": () => (/* binding */ map),\n/* harmony export */   "length": () => (/* binding */ length),\n/* harmony export */   "some": () => (/* binding */ some),\n/* harmony export */   "every": () => (/* binding */ every),\n/* harmony export */   "hasProperty": () => (/* binding */ hasProperty),\n/* harmony export */   "equalFlat": () => (/* binding */ equalFlat)\n/* harmony export */ });\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nconst create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nconst assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nconst forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL29iamVjdC5qcz8xZDJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ087O0FBRVA7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLHlCQUF5QjtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLDZCQUE2QjtBQUN4QyxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyw2QkFBNkI7QUFDeEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1o7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL29iamVjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFY21hU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbi8qKlxuICogT2JqZWN0LmFzc2lnblxuICovXG5leHBvcnQgY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGtleXMgPSBPYmplY3Qua2V5c1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LHN0cmluZyk6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gKG9iaiwgZikgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBmKG9ialtrZXldLCBrZXkpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgUlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChvYmosIGYpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc3VsdHMucHVzaChmKG9ialtrZXldLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXN1bHRzXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gb2JqID0+IGtleXMob2JqKS5sZW5ndGhcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gKG9iaiwgZikgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXZlcnkgPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmICghZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQ2FsbHMgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaGFzUHJvcGVydHkgPSAob2JqLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYVxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAobGVuZ3RoKGEpID09PSBsZW5ndGgoYikgJiYgZXZlcnkoYSwgKHZhbCwga2V5KSA9PiAodmFsICE9PSB1bmRlZmluZWQgfHwgaGFzUHJvcGVydHkoYiwga2V5KSkgJiYgYltrZXldID09PSB2YWwpKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/object.js\n')},"./node_modules/lib0/observable.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Observable": () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ "./node_modules/lib0/map.js");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set.js */ "./node_modules/lib0/set.js");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/lib0/array.js");\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n\n\n\n/**\n * Handles named events.\n *\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, name, _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL29ic2VydmFibGUuanM/ZTZjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDQTtBQUNJOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxzQkFBc0IsMkNBQVU7QUFDaEM7O0FBRUE7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLElBQUksbURBQWtCLHdCQUF3QiwyQ0FBVTtBQUN4RDs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBVSwrQkFBK0IsMkNBQVU7QUFDOUQ7O0FBRUE7QUFDQSxzQkFBc0IsMkNBQVU7QUFDaEM7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL29ic2VydmFibGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9ic2VydmFibGUgY2xhc3MgcHJvdG90eXBlLlxuICpcbiAqIEBtb2R1bGUgb2JzZXJ2YWJsZVxuICovXG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcbmltcG9ydCAqIGFzIHNldCBmcm9tICcuL3NldC5qcydcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vYXJyYXkuanMnXG5cbi8qKlxuICogSGFuZGxlcyBuYW1lZCBldmVudHMuXG4gKlxuICogQHRlbXBsYXRlIE5cbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogU29tZSBkZXNjLlxuICAgICAqIEB0eXBlIHtNYXA8TiwgYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBtYXAuY3JlYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBzZXQuY3JlYXRlKS5hZGQoZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIF9mKVxuICAgICAgZiguLi5hcmdzKVxuICAgIH1cbiAgICB0aGlzLm9uKG5hbWUsIF9mKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYgKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpXG4gICAgaWYgKG9ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGYpXG4gICAgICBpZiAob2JzZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmRlbGV0ZShuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBzaG91bGQgY2F0Y2ggZXhjZXB0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge059IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gYXJyYXkuZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBtYXAuY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/observable.js\n')},"./node_modules/lib0/pair.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Pair": () => (/* binding */ Pair),\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "createReversed": () => (/* binding */ createReversed),\n/* harmony export */   "forEach": () => (/* binding */ forEach),\n/* harmony export */   "map": () => (/* binding */ map)\n/* harmony export */ });\n/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nclass Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nconst create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nconst createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nconst forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nconst map = (arr, f) => arr.map(p => f(p.left, p.right))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3BhaXIuanM/Nzc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLG1CQUFtQjtBQUM5QjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL3BhaXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdvcmtpbmcgd2l0aCB2YWx1ZSBwYWlycy5cbiAqXG4gKiBAbW9kdWxlIHBhaXJcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqL1xuZXhwb3J0IGNsYXNzIFBhaXIge1xuICAvKipcbiAgICogQHBhcmFtIHtMfSBsZWZ0XG4gICAqIEBwYXJhbSB7Un0gcmlnaHRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCkge1xuICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7TH0gbGVmdFxuICogQHBhcmFtIHtSfSByaWdodFxuICogQHJldHVybiB7UGFpcjxMLFI+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodClcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge1J9IHJpZ2h0XG4gKiBAcGFyYW0ge0x9IGxlZnRcbiAqIEByZXR1cm4ge1BhaXI8TCxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJldmVyc2VkID0gKHJpZ2h0LCBsZWZ0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodClcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge0FycmF5PFBhaXI8TCxSPj59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihMLCBSKTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoYXJyLCBmKSA9PiBhcnIuZm9yRWFjaChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSLFhcbiAqIEBwYXJhbSB7QXJyYXk8UGFpcjxMLFI+Pn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEwsIFIpOlh9IGZcbiAqIEByZXR1cm4ge0FycmF5PFg+fVxuICovXG5leHBvcnQgY29uc3QgbWFwID0gKGFyciwgZikgPT4gYXJyLm1hcChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/pair.js\n')},"./node_modules/lib0/promise.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "createEmpty": () => (/* binding */ createEmpty),\n/* harmony export */   "all": () => (/* binding */ all),\n/* harmony export */   "reject": () => (/* binding */ reject),\n/* harmony export */   "resolve": () => (/* binding */ resolve),\n/* harmony export */   "until": () => (/* binding */ until),\n/* harmony export */   "wait": () => (/* binding */ wait),\n/* harmony export */   "isPromise": () => (/* binding */ isPromise)\n/* harmony export */ });\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ "./node_modules/lib0/time.js");\n/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\n\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nconst create = f => /** @type {Promise<T>} */ (new Promise(f))\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nconst createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template T\n * @param {Array<Promise<T>>} arrp\n * @return {Promise<Array<T>>}\n */\nconst all = arrp => Promise.all(arrp)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nconst reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nconst resolve = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nconst until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* istanbul ignore else */\n      if (_time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error(\'Timeout\'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nconst wait = timeout => create((resolve, reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nconst isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3Byb21pc2UuanM/OWMyYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLFdBQVcscURBQXFEO0FBQ2hFLFlBQVk7QUFDWjtBQUNPLCtCQUErQixXQUFXOztBQUVqRDtBQUNBLFdBQVcsb0RBQW9EO0FBQy9ELFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQLG9CQUFvQixpREFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsaURBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9wcm9taXNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGhlbHBlcnMgdG8gd29yayB3aXRoIHByb21pc2VzLlxuICpcbiAqIEBtb2R1bGUgcHJvbWlzZVxuICovXG5cbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnLi90aW1lLmpzJ1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAY2FsbGJhY2sgUHJvbWlzZVJlc29sdmVcbiAqIEBwYXJhbSB7VHxQcm9taXNlTGlrZTxUPn0gW3Jlc3VsdF1cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFByb21pc2VSZXNvbHZlPFQ+LGZ1bmN0aW9uKEVycm9yKTp2b2lkKTphbnl9IGZcbiAqIEByZXR1cm4ge1Byb21pc2U8VD59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSBmID0+IC8qKiBAdHlwZSB7UHJvbWlzZTxUPn0gKi8gKG5ldyBQcm9taXNlKGYpKVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZnVuY3Rpb24oKTp2b2lkLGZ1bmN0aW9uKEVycm9yKTp2b2lkKTp2b2lkfSBmXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRW1wdHkgPSBmID0+IG5ldyBQcm9taXNlKGYpXG5cbi8qKlxuICogYFByb21pc2UuYWxsYCB3YWl0IGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIGFycmF5IHRvIHJlc29sdmUgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheTxQcm9taXNlPFQ+Pn0gYXJycFxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxUPj59XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSBhcnJwID0+IFByb21pc2UuYWxsKGFycnApXG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gW3JlYXNvbl1cbiAqIEByZXR1cm4ge1Byb21pc2U8bmV2ZXI+fVxuICovXG5leHBvcnQgY29uc3QgcmVqZWN0ID0gcmVhc29uID0+IFByb21pc2UucmVqZWN0KHJlYXNvbilcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfHZvaWR9IHJlc1xuICogQHJldHVybiB7UHJvbWlzZTxUfHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZSA9IHJlcyA9PiBQcm9taXNlLnJlc29sdmUocmVzKVxuXG4vKipcbiAqIEB0b2RvIE5leHQgdmVyc2lvbiwgcmVvcmRlciBwYXJhbWV0ZXJzOiBjaGVjaywgW3RpbWVvdXQsIFtpbnRlcnZhbFJlc29sdXRpb25dXVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6Ym9vbGVhbn0gY2hlY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZXJ2YWxSZXNvbHV0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHVudGlsID0gKHRpbWVvdXQsIGNoZWNrLCBpbnRlcnZhbFJlc29sdXRpb24gPSAxMCkgPT4gY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IGhhc1RpbWVvdXQgPSB0aW1lb3V0ID4gMFxuICBjb25zdCB1bnRpbEludGVydmFsID0gKCkgPT4ge1xuICAgIGlmIChjaGVjaygpKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChoYXNUaW1lb3V0KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRpbWUuZ2V0VW5peFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSlcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCcpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKHVudGlsSW50ZXJ2YWwsIGludGVydmFsUmVzb2x1dGlvbilcbn0pXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEByZXR1cm4ge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHdhaXQgPSB0aW1lb3V0ID0+IGNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpKVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBvYmplY3QgaXMgYSBwcm9taXNlIHVzaW5nIGR1Y2t0eXBpbmcuXG4gKlxuICogUHJvbWlzZXMgYXJlIG9mdGVuIHBvbHlmaWxsZWQsIHNvIGl0IG1ha2VzIHNlbnNlIHRvIGFkZCBzb21lIGFkZGl0aW9uYWwgZ3VhcmFudGVlcyBpZiB0aGUgdXNlciBvZiB0aGlzXG4gKiBsaWJyYXJ5IGhhcyBzb21lIGluc2FuZSBlbnZpcm9ubWVudCB3aGVyZSBnbG9iYWwgUHJvbWlzZSBvYmplY3RzIGFyZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge2FueX0gcFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzUHJvbWlzZSA9IHAgPT4gcCBpbnN0YW5jZW9mIFByb21pc2UgfHwgKHAgJiYgcC50aGVuICYmIHAuY2F0Y2ggJiYgcC5maW5hbGx5KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/promise.js\n')},"./node_modules/lib0/random.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rand": () => (/* binding */ rand),\n/* harmony export */   "uint32": () => (/* binding */ uint32),\n/* harmony export */   "oneOf": () => (/* binding */ oneOf),\n/* harmony export */   "uuidv4": () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var _isomorphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isomorphic.js */ "./node_modules/isomorphic.js/browser.mjs");\n\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\n\n\n\nconst rand = Math.random\n\n/* istanbul ignore next */\nconst uint32 = () => new Uint32Array((0,_isomorphic_js__WEBPACK_IMPORTED_MODULE_0__.cryptoRandomBuffer)(4))[0]\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nconst oneOf = arr => arr[_math_js__WEBPACK_IMPORTED_MODULE_1__.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3JhbmRvbS5qcz9jODkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7QUFDbUI7O0FBRTdDOztBQUVQO0FBQ08scUNBQXFDLGtFQUFrQjs7QUFFOUQ7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTyx5QkFBeUIsMkNBQVU7O0FBRTFDO0FBQ0E7QUFDTyxrRUFBa0UsT0FBTztBQUNoRjtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvcmFuZG9tLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIElzb21vcnBoaWMgbW9kdWxlIGZvciB0cnVlIHJhbmRvbSBudW1iZXJzIC8gYnVmZmVycyAvIHV1aWRzLlxuICpcbiAqIEF0dGVudGlvbjogZmFsbHMgYmFjayB0byBNYXRoLnJhbmRvbSBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGNyeXB0by5cbiAqXG4gKiBAbW9kdWxlIHJhbmRvbVxuICovXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0IHsgY3J5cHRvUmFuZG9tQnVmZmVyIH0gZnJvbSAnLi9pc29tb3JwaGljLmpzJ1xuXG5leHBvcnQgY29uc3QgcmFuZCA9IE1hdGgucmFuZG9tXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdWludDMyID0gKCkgPT4gbmV3IFVpbnQzMkFycmF5KGNyeXB0b1JhbmRvbUJ1ZmZlcig0KSlbMF1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheTxUPn0gYXJyXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3Qgb25lT2YgPSBhcnIgPT4gYXJyW21hdGguZmxvb3IocmFuZCgpICogYXJyLmxlbmd0aCldXG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IHV1aWR2NFRlbXBsYXRlID0gWzFlN10gKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMVxuZXhwb3J0IGNvbnN0IHV1aWR2NCA9ICgpID0+IHV1aWR2NFRlbXBsYXRlLnJlcGxhY2UoL1swMThdL2csIC8qKiBAcGFyYW0ge251bWJlcn0gYyAqLyBjID0+XG4gIChjIF4gdWludDMyKCkgJiAxNSA+PiBjIC8gNCkudG9TdHJpbmcoMTYpXG4pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/random.js\n')},"./node_modules/lib0/set.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "toArray": () => (/* binding */ toArray)\n/* harmony export */ });\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nconst toArray = set => Array.from(set)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3NldC5qcz80YWE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvc2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc2V0cy5cbiAqXG4gKiBAbW9kdWxlIHNldFxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgU2V0KClcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTZXQ8VD59IHNldFxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gc2V0ID0+IEFycmF5LmZyb20oc2V0KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/set.js\n')},"./node_modules/lib0/storage.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"varStorage\": () => (/* binding */ varStorage),\n/* harmony export */   \"onChange\": () => (/* binding */ onChange)\n/* harmony export */ });\n/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nconst varStorage = _localStorage\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nconst onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3N0b3JhZ2UuanM/YzgyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0EseURBQXlELEdBQUc7QUFDNUQ7QUFDQSxXQUFXLFVBQVUsa0RBQWtELFFBQVE7QUFDL0U7QUFDQTtBQUNPLHVGQUF1RixJQUFJIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvc3RvcmFnZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBsb2NhbFN0b3JhZ2UsIGFkZEV2ZW50TGlzdGVuZXIgKi9cblxuLyoqXG4gKiBJc29tb3JwaGljIHZhcmlhYmxlIHN0b3JhZ2UuXG4gKlxuICogVXNlcyBMb2NhbFN0b3JhZ2UgaW4gdGhlIGJyb3dzZXIgYW5kIGZhbGxzIGJhY2sgdG8gaW4tbWVtb3J5IHN0b3JhZ2UuXG4gKlxuICogQG1vZHVsZSBzdG9yYWdlXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFZhclN0b3JhZ2VQb2x5ZmlsbCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlXG4gICAqL1xuICBzZXRJdGVtIChrZXksIG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5tYXAuc2V0KGtleSwgbmV3VmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgZ2V0SXRlbSAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpXG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHR5cGUge2FueX1cbiAqL1xubGV0IF9sb2NhbFN0b3JhZ2UgPSBuZXcgVmFyU3RvcmFnZVBvbHlmaWxsKClcbmxldCB1c2VQb2x5ZmlsbCA9IHRydWVcblxudHJ5IHtcbiAgLy8gaWYgdGhlIHNhbWUtb3JpZ2luIHJ1bGUgaXMgdmlvbGF0ZWQsIGFjY2Vzc2luZyBsb2NhbFN0b3JhZ2UgbWlnaHQgdGhyb3duIGFuIGVycm9yXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIF9sb2NhbFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2VcbiAgICB1c2VQb2x5ZmlsbCA9IGZhbHNlXG4gIH1cbn0gY2F0Y2ggKGUpIHsgfVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBsb2NhbFN0b3JhZ2UgaW4gYnJvd3Nlciwgb3IgYSBwb2x5ZmlsbCBpbiBub2RlanNcbiAqL1xuZXhwb3J0IGNvbnN0IHZhclN0b3JhZ2UgPSBfbG9jYWxTdG9yYWdlXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIGBhZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgZXZlbnQgPT4gey4ufSlgIHRoYXQgZG9lcyBub3RoaW5nIGlmIHRoZSBwb2x5ZmlsbCBpcyBiZWluZyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oeyBrZXk6IHN0cmluZywgbmV3VmFsdWU6IHN0cmluZywgb2xkVmFsdWU6IHN0cmluZyB9KTogdm9pZH0gZXZlbnRIYW5kbGVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG9uQ2hhbmdlID0gZXZlbnRIYW5kbGVyID0+IHVzZVBvbHlmaWxsIHx8IGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAvKiogQHR5cGUge2FueX0gKi8gKGV2ZW50SGFuZGxlcikpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/storage.js\n")},"./node_modules/lib0/string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromCharCode": () => (/* binding */ fromCharCode),\n/* harmony export */   "fromCodePoint": () => (/* binding */ fromCodePoint),\n/* harmony export */   "trimLeft": () => (/* binding */ trimLeft),\n/* harmony export */   "fromCamelCase": () => (/* binding */ fromCamelCase),\n/* harmony export */   "utf8ByteLength": () => (/* binding */ utf8ByteLength),\n/* harmony export */   "_encodeUtf8Polyfill": () => (/* binding */ _encodeUtf8Polyfill),\n/* harmony export */   "utf8TextEncoder": () => (/* binding */ utf8TextEncoder),\n/* harmony export */   "_encodeUtf8Native": () => (/* binding */ _encodeUtf8Native),\n/* harmony export */   "encodeUtf8": () => (/* binding */ encodeUtf8),\n/* harmony export */   "_decodeUtf8Polyfill": () => (/* binding */ _decodeUtf8Polyfill),\n/* harmony export */   "utf8TextDecoder": () => (/* binding */ utf8TextDecoder),\n/* harmony export */   "_decodeUtf8Native": () => (/* binding */ _decodeUtf8Native),\n/* harmony export */   "decodeUtf8": () => (/* binding */ decodeUtf8)\n/* harmony export */ });\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode\nconst fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, \'\')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nconst utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* istanbul ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== \'undefined\' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = \'\'\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* istanbul ignore next */\nlet utf8TextDecoder = typeof TextDecoder === \'undefined\' ? null : new TextDecoder(\'utf-8\', { fatal: true, ignoreBOM: true })\n\n/* istanbul ignore next */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn\'t handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  utf8TextDecoder = null\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nconst decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3N0cmluZy5qcz81ZGE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ0E7O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPLDJGQUEyRixVQUFVLEVBQUUsbUJBQW1COztBQUVqSTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ08sbUNBQW1DLFlBQVk7O0FBRXREO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLElBQUk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTyw0RkFBNEYsK0JBQStCOztBQUVsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDTyw0Q0FBNEMsWUFBWTs7QUFFL0Q7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL3N0cmluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHN0cmluZ3MuXG4gKlxuICogQG1vZHVsZSBzdHJpbmdcbiAqL1xuXG5leHBvcnQgY29uc3QgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuZXhwb3J0IGNvbnN0IGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRvTG93ZXJDYXNlID0gcyA9PiBzLnRvTG93ZXJDYXNlKClcblxuY29uc3QgdHJpbUxlZnRSZWdleCA9IC9eXFxzKi9nXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHRyaW1MZWZ0ID0gcyA9PiBzLnJlcGxhY2UodHJpbUxlZnRSZWdleCwgJycpXG5cbmNvbnN0IGZyb21DYW1lbENhc2VSZWdleCA9IC8oW0EtWl0pL2dcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHBhcmFtIHtzdHJpbmd9IHNlcGFyYXRvclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZnJvbUNhbWVsQ2FzZSA9IChzLCBzZXBhcmF0b3IpID0+IHRyaW1MZWZ0KHMucmVwbGFjZShmcm9tQ2FtZWxDYXNlUmVnZXgsIG1hdGNoID0+IGAke3NlcGFyYXRvcn0ke3RvTG93ZXJDYXNlKG1hdGNoKX1gKSlcblxuLyoqXG4gKiBDb21wdXRlIHRoZSB1dGY4Qnl0ZUxlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgdXRmOEJ5dGVMZW5ndGggPSBzdHIgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBfZW5jb2RlVXRmOFBvbHlmaWxsID0gc3RyID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKVxuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aFxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHV0ZjhUZXh0RW5jb2RlciA9IC8qKiBAdHlwZSB7VGV4dEVuY29kZXJ9ICovICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCkgOiBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBfZW5jb2RlVXRmOE5hdGl2ZSA9IHN0ciA9PiB1dGY4VGV4dEVuY29kZXIuZW5jb2RlKHN0cilcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVV0ZjggPSB1dGY4VGV4dEVuY29kZXIgPyBfZW5jb2RlVXRmOE5hdGl2ZSA6IF9lbmNvZGVVdGY4UG9seWZpbGxcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgX2RlY29kZVV0ZjhQb2x5ZmlsbCA9IGJ1ZiA9PiB7XG4gIGxldCByZW1haW5pbmdMZW4gPSBidWYubGVuZ3RoXG4gIGxldCBlbmNvZGVkU3RyaW5nID0gJydcbiAgbGV0IGJ1ZlBvcyA9IDBcbiAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICBjb25zdCBuZXh0TGVuID0gcmVtYWluaW5nTGVuIDwgMTAwMDAgPyByZW1haW5pbmdMZW4gOiAxMDAwMFxuICAgIGNvbnN0IGJ5dGVzID0gYnVmLnN1YmFycmF5KGJ1ZlBvcywgYnVmUG9zICsgbmV4dExlbilcbiAgICBidWZQb3MgKz0gbmV4dExlblxuICAgIC8vIFN0YXJ0aW5nIHdpdGggRVM1LjEgd2UgY2FuIHN1cHBseSBhIGdlbmVyaWMgYXJyYXktbGlrZSBvYmplY3QgYXMgYXJndW1lbnRzXG4gICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSlcbiAgICByZW1haW5pbmdMZW4gLT0gbmV4dExlblxuICB9XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGxldCB1dGY4VGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlLCBpZ25vcmVCT006IHRydWUgfSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICh1dGY4VGV4dERlY29kZXIgJiYgdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgLy8gU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIEJPTSBjb3JyZWN0bHkuXG4gIC8vIFRoaXMgZml4ZXMgYSBidWcgaW4gU2FmYXJpIDEzLjAuNSB3aGVyZSBpdCBwcm9kdWNlcyBhIEJPTSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBmaXJzdCBjYWxsIGFuZFxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgc2Vjb25kIGNhbGxcbiAgLy8gQW5vdGhlciBpc3N1ZSBpcyB0aGF0IGZyb20gdGhlbiBvbiBubyBCT00gY2hhcnMgYXJlIHJlY29nbml6ZWQgYW55bW9yZVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB1dGY4VGV4dERlY29kZXIgPSBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IF9kZWNvZGVVdGY4TmF0aXZlID0gYnVmID0+IC8qKiBAdHlwZSB7VGV4dERlY29kZXJ9ICovICh1dGY4VGV4dERlY29kZXIpLmRlY29kZShidWYpXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVVdGY4ID0gdXRmOFRleHREZWNvZGVyID8gX2RlY29kZVV0ZjhOYXRpdmUgOiBfZGVjb2RlVXRmOFBvbHlmaWxsXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/string.js\n')},"./node_modules/lib0/symbol.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "isSymbol": () => (/* binding */ isSymbol)\n/* harmony export */ });\n/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nconst create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nconst isSymbol = s => typeof s === \'symbol\'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3N5bWJvbC5qcz81ZjAzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvc3ltYm9sLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggRWNtYVNjcmlwdCBTeW1ib2xzLlxuICpcbiAqIEBtb2R1bGUgc3ltYm9sXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gZnJlc2ggc3ltYm9sLlxuICpcbiAqIEByZXR1cm4ge1N5bWJvbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IFN5bWJvbFxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNTeW1ib2wgPSBzID0+IHR5cGVvZiBzID09PSAnc3ltYm9sJ1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/symbol.js\n')},"./node_modules/lib0/time.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDate\": () => (/* binding */ getDate),\n/* harmony export */   \"getUnixTime\": () => (/* binding */ getUnixTime),\n/* harmony export */   \"humanizeDuration\": () => (/* binding */ humanizeDuration)\n/* harmony export */ });\n/* harmony import */ var _metric_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metric.js */ \"./node_modules/lib0/metric.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"./node_modules/lib0/math.js\");\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nconst getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10μs.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nconst humanizeDuration = d => {\n  if (d < 60000) {\n    const p = _metric_js__WEBPACK_IMPORTED_MODULE_0__.prefix(d, -1)\n    return _math_js__WEBPACK_IMPORTED_MODULE_1__.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 60) % 60\n  const hours = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 3600) % 24\n  const days = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3RpbWUuanM/NjlhNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0EsY0FBYyw4Q0FBYTtBQUMzQixXQUFXLDJDQUFVO0FBQ3JCO0FBQ0EsTUFBTSwyQ0FBVTtBQUNoQjtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixnQkFBZ0IsMkNBQVU7QUFDMUIsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC90aW1lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdGltZS5cbiAqXG4gKiBAbW9kdWxlIHRpbWVcbiAqL1xuXG5pbXBvcnQgKiBhcyBtZXRyaWMgZnJvbSAnLi9tZXRyaWMuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCB0aW1lLlxuICpcbiAqIEByZXR1cm4ge0RhdGV9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXREYXRlID0gKCkgPT4gbmV3IERhdGUoKVxuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IHVuaXggdGltZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVbml4VGltZSA9IERhdGUubm93XG5cbi8qKlxuICogVHJhbnNmb3JtIHRpbWUgKGluIG1zKSB0byBhIGh1bWFuIHJlYWRhYmxlIGZvcm1hdC4gRS5nLiAxMTAwID0+IDEuMXMuIDYwcyA9PiAxbWluLiAuMDAxID0+IDEwzrxzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICogQHJldHVybiB7c3RyaW5nfSBodW1hbml6ZWQgYXBwcm94aW1hdGlvbiBvZiB0aW1lXG4gKi9cbmV4cG9ydCBjb25zdCBodW1hbml6ZUR1cmF0aW9uID0gZCA9PiB7XG4gIGlmIChkIDwgNjAwMDApIHtcbiAgICBjb25zdCBwID0gbWV0cmljLnByZWZpeChkLCAtMSlcbiAgICByZXR1cm4gbWF0aC5yb3VuZChwLm4gKiAxMDApIC8gMTAwICsgcC5wcmVmaXggKyAncydcbiAgfVxuICBkID0gbWF0aC5mbG9vcihkIC8gMTAwMClcbiAgY29uc3Qgc2Vjb25kcyA9IGQgJSA2MFxuICBjb25zdCBtaW51dGVzID0gbWF0aC5mbG9vcihkIC8gNjApICUgNjBcbiAgY29uc3QgaG91cnMgPSBtYXRoLmZsb29yKGQgLyAzNjAwKSAlIDI0XG4gIGNvbnN0IGRheXMgPSBtYXRoLmZsb29yKGQgLyA4NjQwMClcbiAgaWYgKGRheXMgPiAwKSB7XG4gICAgcmV0dXJuIGRheXMgKyAnZCcgKyAoKGhvdXJzID4gMCB8fCBtaW51dGVzID4gMzApID8gJyAnICsgKG1pbnV0ZXMgPiAzMCA/IGhvdXJzICsgMSA6IGhvdXJzKSArICdoJyA6ICcnKVxuICB9XG4gIGlmIChob3VycyA+IDApIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBob3VycyArICdoJyArICgobWludXRlcyA+IDAgfHwgc2Vjb25kcyA+IDMwKSA/ICcgJyArIChzZWNvbmRzID4gMzAgPyBtaW51dGVzICsgMSA6IG1pbnV0ZXMpICsgJ21pbicgOiAnJylcbiAgfVxuICByZXR1cm4gbWludXRlcyArICdtaW4nICsgKHNlY29uZHMgPiAwID8gJyAnICsgc2Vjb25kcyArICdzJyA6ICcnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/time.js\n")},"./node_modules/lib0/url.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decodeQueryParams\": () => (/* binding */ decodeQueryParams),\n/* harmony export */   \"encodeQueryParams\": () => (/* binding */ encodeQueryParams)\n/* harmony export */ });\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object.js */ \"./node_modules/lib0/object.js\");\n/**\n * Utility module to work with urls.\n *\n * @module url\n */\n\n\n\n/**\n * Parse query parameters from an url.\n *\n * @param {string} url\n * @return {Object<string,string>}\n */\nconst decodeQueryParams = url => {\n  /**\n   * @type {Object<string,string>}\n   */\n  const query = {}\n  const urlQuerySplit = url.split('?')\n  const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&')\n  for (var i = 0; i < pairs.length; i++) {\n    const item = pairs[i]\n    if (item.length > 0) {\n      const pair = item.split('=')\n      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')\n    }\n  }\n  return query\n}\n\n/**\n * @param {Object<string,string>} params\n * @return {string}\n */\nconst encodeQueryParams = params =>\n  _object_js__WEBPACK_IMPORTED_MODULE_0__.map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9saWIwL3VybC5qcz9jNzU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVk7QUFDWjtBQUNPO0FBQ1AsRUFBRSwyQ0FBVSwwQkFBMEIsd0JBQXdCLEdBQUcsd0JBQXdCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvdXJsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdXJscy5cbiAqXG4gKiBAbW9kdWxlIHVybFxuICovXG5cbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdC5qcydcblxuLyoqXG4gKiBQYXJzZSBxdWVyeSBwYXJhbWV0ZXJzIGZyb20gYW4gdXJsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsc3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVF1ZXJ5UGFyYW1zID0gdXJsID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59XG4gICAqL1xuICBjb25zdCBxdWVyeSA9IHt9XG4gIGNvbnN0IHVybFF1ZXJ5U3BsaXQgPSB1cmwuc3BsaXQoJz8nKVxuICBjb25zdCBwYWlycyA9IHVybFF1ZXJ5U3BsaXRbdXJsUXVlcnlTcGxpdC5sZW5ndGggLSAxXS5zcGxpdCgnJicpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gcGFpcnNbaV1cbiAgICBpZiAoaXRlbS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYWlyID0gaXRlbS5zcGxpdCgnPScpXG4gICAgICBxdWVyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0gfHwgJycpXG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fSBwYXJhbXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVF1ZXJ5UGFyYW1zID0gcGFyYW1zID0+XG4gIG9iamVjdC5tYXAocGFyYW1zLCAodmFsLCBrZXkpID0+IGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWwpfWApLmpvaW4oJyYnKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/url.js\n")},"./node_modules/@cocreate/cursors/src/CoCreate-cursors.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoLinkTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _file_loader_dist_cjs_js_CoCreate_cursors_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../file-loader/dist/cjs.js!./CoCreate-cursors.css */ "./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/cursors/src/CoCreate-cursors.css");\n\n            \n\nvar options = {"injectType":"linkTag"};\n\noptions.insert = "head";\n\nvar update = _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_file_loader_dist_cjs_js_CoCreate_cursors_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3Vyc29ycy9zcmMvQ29DcmVhdGUtY3Vyc29ycy5jc3M/Y2UyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlGO0FBQ2pGLFlBQTRGOztBQUU1RixlQUFlOztBQUVmOztBQUVBLGFBQWEsNEZBQUcsQ0FBQyxrRkFBTzs7OztBQUl4QixpRUFBZSxFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jdXJzb3JzL3NyYy9Db0NyZWF0ZS1jdXJzb3JzLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9MaW5rVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi9maWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuL0NvQ3JlYXRlLWN1cnNvcnMuY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge1wiaW5qZWN0VHlwZVwiOlwibGlua1RhZ1wifTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IHt9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/cursors/src/CoCreate-cursors.css\n')},"./node_modules/@cocreate/floating-label/src/CoCreate-floating-label.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoLinkTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _file_loader_dist_cjs_js_CoCreate_floating_label_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../file-loader/dist/cjs.js!./CoCreate-floating-label.css */ "./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/floating-label/src/CoCreate-floating-label.css");\n\n            \n\nvar options = {"injectType":"linkTag"};\n\noptions.insert = "head";\n\nvar update = _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_file_loader_dist_cjs_js_CoCreate_floating_label_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvZmxvYXRpbmctbGFiZWwvc3JjL0NvQ3JlYXRlLWZsb2F0aW5nLWxhYmVsLmNzcz8xMGUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUY7QUFDakYsWUFBbUc7O0FBRW5HLGVBQWU7O0FBRWY7O0FBRUEsYUFBYSw0RkFBRyxDQUFDLHlGQUFPOzs7O0FBSXhCLGlFQUFlLEUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2Zsb2F0aW5nLWxhYmVsL3NyYy9Db0NyZWF0ZS1mbG9hdGluZy1sYWJlbC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvTGlua1RhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vZmlsZS1sb2FkZXIvZGlzdC9janMuanMhLi9Db0NyZWF0ZS1mbG9hdGluZy1sYWJlbC5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7XCJpbmplY3RUeXBlXCI6XCJsaW5rVGFnXCJ9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQge30iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/floating-label/src/CoCreate-floating-label.css\n')},"./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nmodule.exports = function (url, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {};\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  var link = document.createElement('link');\n  link.rel = 'stylesheet';\n  link.href = url;\n  Object.keys(options.attributes).forEach(function (key) {\n    link.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(link);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(link);\n  }\n\n  return function (newUrl) {\n    if (typeof newUrl === 'string') {\n      link.href = newUrl;\n    } else {\n      link.parentNode.removeChild(link);\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9MaW5rVGFnLmpzPzY3NGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9MaW5rVGFnLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuYXR0cmlidXRlcyA6IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgbGluay5ocmVmID0gdXJsO1xuICBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKGtleSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQobGluayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGxpbmspO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChuZXdVcmwpIHtcbiAgICBpZiAodHlwZW9mIG5ld1VybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxpbmsuaHJlZiA9IG5ld1VybDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgIH1cbiAgfTtcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js\n")},"./node_modules/y-indexeddb/src/y-indexeddb.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PREFERRED_TRIM_SIZE\": () => (/* binding */ PREFERRED_TRIM_SIZE),\n/* harmony export */   \"fetchUpdates\": () => (/* binding */ fetchUpdates),\n/* harmony export */   \"storeState\": () => (/* binding */ storeState),\n/* harmony export */   \"clearDocument\": () => (/* binding */ clearDocument),\n/* harmony export */   \"IndexeddbPersistence\": () => (/* binding */ IndexeddbPersistence)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/indexeddb.js */ \"./node_modules/lib0/indexeddb.js\");\n/* harmony import */ var lib0_mutex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/mutex.js */ \"./node_modules/lib0/mutex.js\");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/observable.js */ \"./node_modules/lib0/observable.js\");\n\n\n\n\n\nconst customStoreName = 'custom'\nconst updatesStoreName = 'updates'\n\nconst PREFERRED_TRIM_SIZE = 500\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n */\nconst fetchUpdates = idbPersistence => {\n  const [updatesStore] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(/** @type {IDBDatabase} */ (idbPersistence.db), [updatesStoreName]) // , 'readonly')\n  return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.getAll(updatesStore, lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(updates =>\n    idbPersistence._mux(() =>\n      idbPersistence.doc.transact(() =>\n        updates.forEach(val => yjs__WEBPACK_IMPORTED_MODULE_1__.applyUpdate(idbPersistence.doc, val))\n      )\n    )\n  )\n    .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.getLastKey(updatesStore).then(lastKey => { idbPersistence._dbref = lastKey + 1 }))\n    .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n    .then(() => updatesStore)\n}\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {boolean} forceStore\n */\nconst storeState = (idbPersistence, forceStore = true) =>\n  fetchUpdates(idbPersistence)\n    .then(updatesStore => {\n      if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n        lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(idbPersistence.doc))\n          .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.del(updatesStore, lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createIDBKeyRangeUpperBound(idbPersistence._dbref, true)))\n          .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n      }\n    })\n\n/**\n * @param {string} name\n */\nconst clearDocument = name => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.deleteDB(name)\n\n/**\n * @extends Observable<string>\n */\nclass IndexeddbPersistence extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable {\n  /**\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor (name, doc) {\n    super()\n    this.doc = doc\n    this.name = name\n    this._mux = lib0_mutex_js__WEBPACK_IMPORTED_MODULE_3__.createMutex()\n    this._dbref = 0\n    this._dbsize = 0\n    /**\n     * @type {IDBDatabase|null}\n     */\n    this.db = null\n    this.synced = false\n    this._db = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.openDB(name, db =>\n      lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createStores(db, [\n        ['updates', { autoIncrement: true }],\n        ['custom']\n      ])\n    )\n    /**\n     * @type {Promise<IndexeddbPersistence>}\n     */\n    this.whenSynced = this._db.then(db => {\n      this.db = db\n      const currState = yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(doc)\n      return fetchUpdates(this).then(updatesStore => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, currState)).then(() => {\n        this.emit('synced', [this])\n        this.synced = true\n        return this\n      })\n    })\n    /**\n     * Timeout in ms untill data is merged and persisted in idb.\n     */\n    this._storeTimeout = 1000\n    /**\n     * @type {any}\n     */\n    this._storeTimeoutId = null\n    /**\n     * @param {Uint8Array} update\n     */\n    this._storeUpdate = update =>\n      this._mux(() => {\n        if (this.db) {\n          const [updatesStore] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(/** @type {IDBDatabase} */ (this.db), [updatesStoreName])\n          lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, update)\n          if (++this._dbsize >= PREFERRED_TRIM_SIZE) {\n            // debounce store call\n            if (this._storeTimeoutId !== null) {\n              clearTimeout(this._storeTimeoutId)\n            }\n            this._storeTimeoutId = setTimeout(() => {\n              storeState(this, false)\n              this._storeTimeoutId = null\n            }, this._storeTimeout)\n          }\n        }\n      })\n    doc.on('update', this._storeUpdate)\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  destroy () {\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId)\n    }\n    this.doc.off('update', this._storeUpdate)\n    this.doc.off('destroy', this.destroy)\n    return this._db.then(db => {\n      db.close()\n    })\n  }\n\n  /**\n   * Destroys this instance and removes all data from indexeddb.\n   *\n   * @return {Promise<void>}\n   */\n  clearData () {\n    return this.destroy().then(() => {\n      lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.deleteDB(this.name)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<String | number | ArrayBuffer | Date | any>}\n   */\n  get (key) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName], 'readonly')\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.get(custom, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @param {String | number | ArrayBuffer | Date} value\n   * @return {Promise<String | number | ArrayBuffer | Date>}\n   */\n  set (key, value) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName])\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.put(custom, value, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<undefined>}\n   */\n  del (key) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName])\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.del(custom, key)\n    })\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy95LWluZGV4ZWRkYi9zcmMveS1pbmRleGVkZGIuanM/ODNjZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0I7QUFDZ0I7QUFDRjtBQUNTOztBQUUvQztBQUNBOztBQUVPOztBQUVQO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDTztBQUNQLHlCQUF5Qix1REFBWSxZQUFZLFlBQVk7QUFDN0QsU0FBUyxxREFBVSxlQUFlLDBFQUErQjtBQUNqRTtBQUNBO0FBQ0EsK0JBQStCLDRDQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBYyxnQ0FBZ0Msc0NBQXNDO0FBQ3BHLGdCQUFnQixvREFBUyw0QkFBNEIsK0JBQStCO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWMsZUFBZSxvREFBcUI7QUFDMUQsc0JBQXNCLGtEQUFPLGVBQWUsMEVBQStCO0FBQzNFLHNCQUFzQixvREFBUyw0QkFBNEIsK0JBQStCO0FBQzFGO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNPLDhCQUE4Qix1REFBWTs7QUFFakQ7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLDBEQUFVO0FBQ3BEO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBVTtBQUN6QixNQUFNLDJEQUFnQjtBQUN0QixxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBcUI7QUFDN0MscURBQXFELHlEQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdURBQVksWUFBWSxZQUFZO0FBQ3JFLFVBQVUseURBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQVk7QUFDbEIsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBWTtBQUNuQyxhQUFhLGtEQUFPO0FBQ3BCLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xELGFBQWEscUNBQXFDO0FBQ2xELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVk7QUFDbkMsYUFBYSxrREFBTztBQUNwQixLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLHFDQUFxQztBQUNsRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFZO0FBQ25DLGFBQWEsa0RBQU87QUFDcEIsS0FBSztBQUNMO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveS1pbmRleGVkZGIvc3JjL3ktaW5kZXhlZGRiLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgKiBhcyBpZGIgZnJvbSAnbGliMC9pbmRleGVkZGIuanMnXG5pbXBvcnQgKiBhcyBtdXRleCBmcm9tICdsaWIwL211dGV4LmpzJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZS5qcydcblxuY29uc3QgY3VzdG9tU3RvcmVOYW1lID0gJ2N1c3RvbSdcbmNvbnN0IHVwZGF0ZXNTdG9yZU5hbWUgPSAndXBkYXRlcydcblxuZXhwb3J0IGNvbnN0IFBSRUZFUlJFRF9UUklNX1NJWkUgPSA1MDBcblxuLyoqXG4gKiBAcGFyYW0ge0luZGV4ZWRkYlBlcnNpc3RlbmNlfSBpZGJQZXJzaXN0ZW5jZVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hVcGRhdGVzID0gaWRiUGVyc2lzdGVuY2UgPT4ge1xuICBjb25zdCBbdXBkYXRlc1N0b3JlXSA9IGlkYi50cmFuc2FjdCgvKiogQHR5cGUge0lEQkRhdGFiYXNlfSAqLyAoaWRiUGVyc2lzdGVuY2UuZGIpLCBbdXBkYXRlc1N0b3JlTmFtZV0pIC8vICwgJ3JlYWRvbmx5JylcbiAgcmV0dXJuIGlkYi5nZXRBbGwodXBkYXRlc1N0b3JlLCBpZGIuY3JlYXRlSURCS2V5UmFuZ2VMb3dlckJvdW5kKGlkYlBlcnNpc3RlbmNlLl9kYnJlZiwgZmFsc2UpKS50aGVuKHVwZGF0ZXMgPT5cbiAgICBpZGJQZXJzaXN0ZW5jZS5fbXV4KCgpID0+XG4gICAgICBpZGJQZXJzaXN0ZW5jZS5kb2MudHJhbnNhY3QoKCkgPT5cbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKHZhbCA9PiBZLmFwcGx5VXBkYXRlKGlkYlBlcnNpc3RlbmNlLmRvYywgdmFsKSlcbiAgICAgIClcbiAgICApXG4gIClcbiAgICAudGhlbigoKSA9PiBpZGIuZ2V0TGFzdEtleSh1cGRhdGVzU3RvcmUpLnRoZW4obGFzdEtleSA9PiB7IGlkYlBlcnNpc3RlbmNlLl9kYnJlZiA9IGxhc3RLZXkgKyAxIH0pKVxuICAgIC50aGVuKCgpID0+IGlkYi5jb3VudCh1cGRhdGVzU3RvcmUpLnRoZW4oY250ID0+IHsgaWRiUGVyc2lzdGVuY2UuX2Ric2l6ZSA9IGNudCB9KSlcbiAgICAudGhlbigoKSA9PiB1cGRhdGVzU3RvcmUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJbmRleGVkZGJQZXJzaXN0ZW5jZX0gaWRiUGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VTdG9yZVxuICovXG5leHBvcnQgY29uc3Qgc3RvcmVTdGF0ZSA9IChpZGJQZXJzaXN0ZW5jZSwgZm9yY2VTdG9yZSA9IHRydWUpID0+XG4gIGZldGNoVXBkYXRlcyhpZGJQZXJzaXN0ZW5jZSlcbiAgICAudGhlbih1cGRhdGVzU3RvcmUgPT4ge1xuICAgICAgaWYgKGZvcmNlU3RvcmUgfHwgaWRiUGVyc2lzdGVuY2UuX2Ric2l6ZSA+PSBQUkVGRVJSRURfVFJJTV9TSVpFKSB7XG4gICAgICAgIGlkYi5hZGRBdXRvS2V5KHVwZGF0ZXNTdG9yZSwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGlkYlBlcnNpc3RlbmNlLmRvYykpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gaWRiLmRlbCh1cGRhdGVzU3RvcmUsIGlkYi5jcmVhdGVJREJLZXlSYW5nZVVwcGVyQm91bmQoaWRiUGVyc2lzdGVuY2UuX2RicmVmLCB0cnVlKSkpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gaWRiLmNvdW50KHVwZGF0ZXNTdG9yZSkudGhlbihjbnQgPT4geyBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID0gY250IH0pKVxuICAgICAgfVxuICAgIH0pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFyRG9jdW1lbnQgPSBuYW1lID0+IGlkYi5kZWxldGVEQihuYW1lKVxuXG4vKipcbiAqIEBleHRlbmRzIE9ic2VydmFibGU8c3RyaW5nPlxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZGRiUGVyc2lzdGVuY2UgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIGRvYykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLl9tdXggPSBtdXRleC5jcmVhdGVNdXRleCgpXG4gICAgdGhpcy5fZGJyZWYgPSAwXG4gICAgdGhpcy5fZGJzaXplID0gMFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJREJEYXRhYmFzZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZGIgPSBudWxsXG4gICAgdGhpcy5zeW5jZWQgPSBmYWxzZVxuICAgIHRoaXMuX2RiID0gaWRiLm9wZW5EQihuYW1lLCBkYiA9PlxuICAgICAgaWRiLmNyZWF0ZVN0b3JlcyhkYiwgW1xuICAgICAgICBbJ3VwZGF0ZXMnLCB7IGF1dG9JbmNyZW1lbnQ6IHRydWUgfV0sXG4gICAgICAgIFsnY3VzdG9tJ11cbiAgICAgIF0pXG4gICAgKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPEluZGV4ZWRkYlBlcnNpc3RlbmNlPn1cbiAgICAgKi9cbiAgICB0aGlzLndoZW5TeW5jZWQgPSB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIHRoaXMuZGIgPSBkYlxuICAgICAgY29uc3QgY3VyclN0YXRlID0gWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYylcbiAgICAgIHJldHVybiBmZXRjaFVwZGF0ZXModGhpcykudGhlbih1cGRhdGVzU3RvcmUgPT4gaWRiLmFkZEF1dG9LZXkodXBkYXRlc1N0b3JlLCBjdXJyU3RhdGUpKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdzeW5jZWQnLCBbdGhpc10pXG4gICAgICAgIHRoaXMuc3luY2VkID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSlcbiAgICB9KVxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgaW4gbXMgdW50aWxsIGRhdGEgaXMgbWVyZ2VkIGFuZCBwZXJzaXN0ZWQgaW4gaWRiLlxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlVGltZW91dCA9IDEwMDBcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVVcGRhdGUgPSB1cGRhdGUgPT5cbiAgICAgIHRoaXMuX211eCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRiKSB7XG4gICAgICAgICAgY29uc3QgW3VwZGF0ZXNTdG9yZV0gPSBpZGIudHJhbnNhY3QoLyoqIEB0eXBlIHtJREJEYXRhYmFzZX0gKi8gKHRoaXMuZGIpLCBbdXBkYXRlc1N0b3JlTmFtZV0pXG4gICAgICAgICAgaWRiLmFkZEF1dG9LZXkodXBkYXRlc1N0b3JlLCB1cGRhdGUpXG4gICAgICAgICAgaWYgKCsrdGhpcy5fZGJzaXplID49IFBSRUZFUlJFRF9UUklNX1NJWkUpIHtcbiAgICAgICAgICAgIC8vIGRlYm91bmNlIHN0b3JlIGNhbGxcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9yZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcmVUaW1lb3V0SWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdG9yZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBzdG9yZVN0YXRlKHRoaXMsIGZhbHNlKVxuICAgICAgICAgICAgICB0aGlzLl9zdG9yZVRpbWVvdXRJZCA9IG51bGxcbiAgICAgICAgICAgIH0sIHRoaXMuX3N0b3JlVGltZW91dClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgZG9jLm9uKCd1cGRhdGUnLCB0aGlzLl9zdG9yZVVwZGF0ZSlcbiAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKVxuICAgIGRvYy5vbignZGVzdHJveScsIHRoaXMuZGVzdHJveSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZVRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0b3JlVGltZW91dElkKVxuICAgIH1cbiAgICB0aGlzLmRvYy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3N0b3JlVXBkYXRlKVxuICAgIHRoaXMuZG9jLm9mZignZGVzdHJveScsIHRoaXMuZGVzdHJveSlcbiAgICByZXR1cm4gdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICBkYi5jbG9zZSgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIGluc3RhbmNlIGFuZCByZW1vdmVzIGFsbCBkYXRhIGZyb20gaW5kZXhlZGRiLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgY2xlYXJEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCkudGhlbigoKSA9PiB7XG4gICAgICBpZGIuZGVsZXRlREIodGhpcy5uYW1lKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9IGtleVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFN0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IGFueT59XG4gICAqL1xuICBnZXQgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGNvbnN0IFtjdXN0b21dID0gaWRiLnRyYW5zYWN0KGRiLCBbY3VzdG9tU3RvcmVOYW1lXSwgJ3JlYWRvbmx5JylcbiAgICAgIHJldHVybiBpZGIuZ2V0KGN1c3RvbSwga2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9IGtleVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0gdmFsdWVcbiAgICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGU+fVxuICAgKi9cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdKVxuICAgICAgcmV0dXJuIGlkYi5wdXQoY3VzdG9tLCB2YWx1ZSwga2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9IGtleVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gICAqL1xuICBkZWwgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGNvbnN0IFtjdXN0b21dID0gaWRiLnRyYW5zYWN0KGRiLCBbY3VzdG9tU3RvcmVOYW1lXSlcbiAgICAgIHJldHVybiBpZGIuZGVsKGN1c3RvbSwga2V5KVxuICAgIH0pXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/y-indexeddb/src/y-indexeddb.js\n")},"./node_modules/y-protocols/auth.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "messagePermissionDenied": () => (/* binding */ messagePermissionDenied),\n/* harmony export */   "writePermissionDenied": () => (/* binding */ writePermissionDenied),\n/* harmony export */   "readAuthMessage": () => (/* binding */ readAuthMessage)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/decoding.js */ "./node_modules/lib0/decoding.js");\n\n // eslint-disable-line\n\n\n\nconst messagePermissionDenied = 0\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {string} reason\n */\nconst writePermissionDenied = (encoder, reason) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messagePermissionDenied)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarString(encoder, reason)\n}\n\n/**\n * @callback PermissionDeniedHandler\n * @param {any} y\n * @param {string} reason\n */\n\n/**\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} y\n * @param {PermissionDeniedHandler} permissionDeniedHandler\n */\nconst readAuthMessage = (decoder, y, permissionDeniedHandler) => {\n  switch (lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)) {\n    case messagePermissionDenied: permissionDeniedHandler(y, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__.readVarString(decoder))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9hdXRoLmpzPzZkZGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ3dCO0FBQ29CO0FBQ0E7O0FBRXJDOztBQUVQO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxPQUFPO0FBQ2xCO0FBQ087QUFDUCxFQUFFLDBEQUFxQjtBQUN2QixFQUFFLDREQUF1QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE1BQU07QUFDakIsV0FBVyx3QkFBd0I7QUFDbkM7QUFDTztBQUNQLFVBQVUseURBQW9CO0FBQzlCLDZEQUE2RCwyREFBc0I7QUFDbkY7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9hdXRoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcuanMnXG5cbmV4cG9ydCBjb25zdCBtZXNzYWdlUGVybWlzc2lvbkRlbmllZCA9IDBcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlUGVybWlzc2lvbkRlbmllZCA9IChlbmNvZGVyLCByZWFzb24pID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkKVxuICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCByZWFzb24pXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIFBlcm1pc3Npb25EZW5pZWRIYW5kbGVyXG4gKiBAcGFyYW0ge2FueX0geVxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICovXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30geVxuICogQHBhcmFtIHtQZXJtaXNzaW9uRGVuaWVkSGFuZGxlcn0gcGVybWlzc2lvbkRlbmllZEhhbmRsZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBdXRoTWVzc2FnZSA9IChkZWNvZGVyLCB5LCBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcikgPT4ge1xuICBzd2l0Y2ggKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKSB7XG4gICAgY2FzZSBtZXNzYWdlUGVybWlzc2lvbkRlbmllZDogcGVybWlzc2lvbkRlbmllZEhhbmRsZXIoeSwgZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/y-protocols/auth.js\n')},"./node_modules/y-protocols/awareness.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "outdatedTimeout": () => (/* binding */ outdatedTimeout),\n/* harmony export */   "Awareness": () => (/* binding */ Awareness),\n/* harmony export */   "removeAwarenessStates": () => (/* binding */ removeAwarenessStates),\n/* harmony export */   "encodeAwarenessUpdate": () => (/* binding */ encodeAwarenessUpdate),\n/* harmony export */   "modifyAwarenessUpdate": () => (/* binding */ modifyAwarenessUpdate),\n/* harmony export */   "applyAwarenessUpdate": () => (/* binding */ applyAwarenessUpdate)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding.js */ "./node_modules/lib0/decoding.js");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/time.js */ "./node_modules/lib0/time.js");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable.js */ "./node_modules/lib0/observable.js");\n/* harmony import */ var lib0_function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/function.js */ "./node_modules/lib0/function.js");\n/**\n * @module awareness-protocol\n */\n\n\n\n\n\n\n\n // eslint-disable-line\n\nconst outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, \'timeout\')\n      }\n    }, lib0_math_js__WEBPACK_IMPORTED_MODULE_2__.floor(outdatedTimeout / 10)))\n    doc.on(\'destroy\', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit(\'destroy\', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!lib0_function_js__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit(\'change\', [{ added, updated: filteredUpdated, removed }, \'local\'])\n    }\n    this.emit(\'update\', [{ added, updated, removed }, \'local\'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      state[field] = value\n      this.setLocalState(state)\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit(\'change\', [{ added: [], updated: [], removed }, origin])\n    awareness.emit(\'update\', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(state))\n  }\n  return lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nconst modifyAwarenessUpdate = (update, modify) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  const len = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const clock = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const modifiedState = modify(state)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const timestamp = lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    let clock = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!lib0_function_js__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit(\'change\', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit(\'update\', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9hd2FyZW5lc3MuanM/ZjI0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRTRDO0FBQ0E7QUFDUjtBQUNBO0FBQ1c7QUFDVjtBQUNiOztBQUVqQjs7QUFFUDtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0RBQStEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPLHdCQUF3QiwwREFBVTtBQUN6QztBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekMsa0JBQWtCLHFEQUFnQjtBQUNsQyxxRkFBcUYsb0JBQW9CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsK0NBQVU7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBZ0I7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLDBEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJDQUEyQztBQUN2RTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLGNBQWM7QUFDekIsV0FBVyxJQUFJO0FBQ2Y7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBLHVCQUF1QixxREFBZ0I7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGtCQUFrQiwyREFBc0I7QUFDeEMsRUFBRSwwREFBcUI7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0MsSUFBSSwwREFBcUI7QUFDekIsSUFBSSwwREFBcUI7QUFDekIsSUFBSSw0REFBdUI7QUFDM0I7QUFDQSxTQUFTLDBEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWTtBQUNaO0FBQ087QUFDUCxrQkFBa0IsMkRBQXNCO0FBQ3hDLGtCQUFrQiwyREFBc0I7QUFDeEMsY0FBYyx5REFBb0I7QUFDbEMsRUFBRSwwREFBcUI7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUIscUJBQXFCLHlEQUFvQjtBQUN6QyxrQkFBa0IseURBQW9CO0FBQ3RDLDZCQUE2QiwyREFBc0I7QUFDbkQ7QUFDQSxJQUFJLDBEQUFxQjtBQUN6QixJQUFJLDBEQUFxQjtBQUN6QixJQUFJLDREQUF1QjtBQUMzQjtBQUNBLFNBQVMsMERBQXFCO0FBQzlCOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsV0FBVztBQUN0QixXQUFXLElBQUk7QUFDZjtBQUNPO0FBQ1Asa0JBQWtCLDJEQUFzQjtBQUN4QyxvQkFBb0IscURBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBb0I7QUFDbEMsaUJBQWlCLFNBQVM7QUFDMUIscUJBQXFCLHlEQUFvQjtBQUN6QyxnQkFBZ0IseURBQW9CO0FBQ3BDLDZCQUE2QiwyREFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsYUFBYSwwREFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9hd2FyZW5lc3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgYXdhcmVuZXNzLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcuanMnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZS5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoLmpzJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZS5qcydcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbi5qcydcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmV4cG9ydCBjb25zdCBvdXRkYXRlZFRpbWVvdXQgPSAzMDAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFDbGllbnRTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5jbG9ja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5sYXN0VXBkYXRlZCB1bml4IHRpbWVzdGFtcFxuICovXG5cbi8qKlxuICogVGhlIEF3YXJlbmVzcyBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxlIHNoYXJlZCBzdGF0ZSBwcm90b2NvbCB0aGF0IGNhbiBiZSB1c2VkIGZvciBub24tcGVyc2lzdGVudCBkYXRhIGxpa2UgYXdhcmVuZXNzIGluZm9ybWF0aW9uXG4gKiAoY3Vyc29yLCB1c2VybmFtZSwgc3RhdHVzLCAuLikuIEVhY2ggY2xpZW50IGNhbiB1cGRhdGUgaXRzIG93biBsb2NhbCBzdGF0ZSBhbmQgbGlzdGVuIHRvIHN0YXRlIGNoYW5nZXMgb2ZcbiAqIHJlbW90ZSBjbGllbnRzLiBFdmVyeSBjbGllbnQgbWF5IHNldCBhIHN0YXRlIG9mIGEgcmVtb3RlIHBlZXIgdG8gYG51bGxgIHRvIG1hcmsgdGhlIGNsaWVudCBhcyBvZmZsaW5lLlxuICpcbiAqIEVhY2ggY2xpZW50IGlzIGlkZW50aWZpZWQgYnkgYSB1bmlxdWUgY2xpZW50IGlkIChzb21ldGhpbmcgd2UgYm9ycm93IGZyb20gYGRvYy5jbGllbnRJRGApLiBBIGNsaWVudCBjYW4gb3ZlcnJpZGVcbiAqIGl0cyBvd24gc3RhdGUgYnkgcHJvcGFnYXRpbmcgYSBtZXNzYWdlIHdpdGggYW4gaW5jcmVhc2luZyB0aW1lc3RhbXAgKGBjbG9ja2ApLiBJZiBzdWNoIGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgaXQgaXNcbiAqIGFwcGxpZWQgaWYgdGhlIGtub3duIHN0YXRlIG9mIHRoYXQgY2xpZW50IGlzIG9sZGVyIHRoYW4gdGhlIG5ldyBzdGF0ZSAoYGNsb2NrIDwgbmV3Q2xvY2tgKS4gSWYgYSBjbGllbnQgdGhpbmtzIHRoYXRcbiAqIGEgcmVtb3RlIGNsaWVudCBpcyBvZmZsaW5lLCBpdCBtYXkgcHJvcGFnYXRlIGEgbWVzc2FnZSB3aXRoXG4gKiBgeyBjbG9jazogY3VycmVudENsaWVudENsb2NrLCBzdGF0ZTogbnVsbCwgY2xpZW50OiByZW1vdGVDbGllbnQgfWAuIElmIHN1Y2ggYVxuICogbWVzc2FnZSBpcyByZWNlaXZlZCwgYW5kIHRoZSBrbm93biBjbG9jayBvZiB0aGF0IGNsaWVudCBlcXVhbHMgdGhlIHJlY2VpdmVkIGNsb2NrLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBzdGF0ZSB3aXRoIGBudWxsYC5cbiAqXG4gKiBCZWZvcmUgYSBjbGllbnQgZGlzY29ubmVjdHMsIGl0IHNob3VsZCBwcm9wYWdhdGUgYSBgbnVsbGAgc3RhdGUgd2l0aCBhbiB1cGRhdGVkIGNsb2NrLlxuICpcbiAqIEF3YXJlbmVzcyBzdGF0ZXMgbXVzdCBiZSB1cGRhdGVkIGV2ZXJ5IDMwIHNlY29uZHMuIE90aGVyd2lzZSB0aGUgQXdhcmVuZXNzIGluc3RhbmNlIHdpbGwgZGVsZXRlIHRoZSBjbGllbnQgc3RhdGUuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNsYXNzIEF3YXJlbmVzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudElEID0gZG9jLmNsaWVudElEXG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudCBpZCB0byBjbGllbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgT2JqZWN0PHN0cmluZywgYW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgTWV0YUNsaWVudFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGlmICh0aGlzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCAmJiAob3V0ZGF0ZWRUaW1lb3V0IC8gMiA8PSBub3cgLSAvKiogQHR5cGUge3tsYXN0VXBkYXRlZDpudW1iZXJ9fSAqLyAodGhpcy5tZXRhLmdldCh0aGlzLmNsaWVudElEKSkubGFzdFVwZGF0ZWQpKSB7XG4gICAgICAgIC8vIHJlbmV3IGxvY2FsIGNsb2NrXG4gICAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh0aGlzLmdldExvY2FsU3RhdGUoKSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlbW92ZSA9IFtdXG4gICAgICB0aGlzLm1ldGEuZm9yRWFjaCgobWV0YSwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudGlkICE9PSB0aGlzLmNsaWVudElEICYmIG91dGRhdGVkVGltZW91dCA8PSBub3cgLSBtZXRhLmxhc3RVcGRhdGVkICYmIHRoaXMuc3RhdGVzLmhhcyhjbGllbnRpZCkpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChjbGllbnRpZClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmIChyZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcywgcmVtb3ZlLCAndGltZW91dCcpXG4gICAgICB9XG4gICAgfSwgbWF0aC5mbG9vcihvdXRkYXRlZFRpbWVvdXQgLyAxMCkpKVxuICAgIGRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfSlcbiAgICB0aGlzLnNldExvY2FsU3RhdGUoe30pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfVxuICAgKi9cbiAgZ2V0TG9jYWxTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldCh0aGlzLmNsaWVudElEKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH0gc3RhdGVcbiAgICovXG4gIHNldExvY2FsU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSB0aGlzLmNsaWVudElEXG4gICAgY29uc3QgY3VyckxvY2FsTWV0YSA9IHRoaXMubWV0YS5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgY2xvY2sgPSBjdXJyTG9jYWxNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY3VyckxvY2FsTWV0YS5jbG9jayArIDFcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoY2xpZW50SUQpXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgfVxuICAgIHRoaXMubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgIH0pXG4gICAgY29uc3QgYWRkZWQgPSBbXVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfSBlbHNlIGlmIChwcmV2U3RhdGUgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgaWYgKCFmLmVxdWFsaXR5RGVlcChwcmV2U3RhdGUsIHN0YXRlKSkge1xuICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gICAgfVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZUZpZWxkIChmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0TG9jYWxTdGF0ZSgpXG4gICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICBzdGF0ZVtmaWVsZF0gPSB2YWx1ZVxuICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtNYXA8bnVtYmVyLE9iamVjdDxzdHJpbmcsYW55Pj59XG4gICAqL1xuICBnZXRTdGF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1xuICB9XG59XG5cbi8qKlxuICogTWFyayAocmVtb3RlKSBjbGllbnRzIGFzIGluYWN0aXZlIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBwZWVycy5cbiAqIFRoaXMgY2hhbmdlIHdpbGwgYmUgcHJvcGFnYXRlZCB0byByZW1vdGUgY2xpZW50cy5cbiAqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUF3YXJlbmVzc1N0YXRlcyA9IChhd2FyZW5lc3MsIGNsaWVudHMsIG9yaWdpbikgPT4ge1xuICBjb25zdCByZW1vdmVkID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldXG4gICAgaWYgKGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkge1xuICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCkge1xuICAgICAgICBjb25zdCBjdXJNZXRhID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKVxuICAgICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgICBjbG9jazogY3VyTWV0YS5jbG9jayArIDEsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSlcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlQXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgY2xpZW50cywgc3RhdGVzID0gYXdhcmVuZXNzLnN0YXRlcykgPT4ge1xuICBjb25zdCBsZW4gPSBjbGllbnRzLmxlbmd0aFxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoY2xpZW50SUQpIHx8IG51bGxcbiAgICBjb25zdCBjbG9jayA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSkuY2xvY2tcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KHN0YXRlKSlcbiAgfVxuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59XG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb250ZW50IG9mIGFuIGF3YXJlbmVzcyB1cGRhdGUgYmVmb3JlIHJlLWVuY29kaW5nIGl0IHRvIGFuIGF3YXJlbmVzcyB1cGRhdGUuXG4gKlxuICogVGhpcyBtaWdodCBiZSB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhIGNlbnRyYWwgc2VydmVyIHRoYXQgd2FudHMgdG8gZW5zdXJlIHRoYXQgY2xpZW50c1xuICogY2FudCBoaWphY2sgc29tZWJvZHkgZWxzZXMgaWRlbnRpdHkuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IG1vZGlmeVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IG1vZGlmeUF3YXJlbmVzc1VwZGF0ZSA9ICh1cGRhdGUsIG1vZGlmeSkgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgbW9kaWZpZWRTdGF0ZSA9IG1vZGlmeShzdGF0ZSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KG1vZGlmaWVkU3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IG9yaWdpbiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVtaXR0ZWQgY2hhbmdlIGV2ZW50XG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgdGltZXN0YW1wID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IGFkZGVkID0gW11cbiAgY29uc3QgdXBkYXRlZCA9IFtdXG4gIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGxldCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgY2xpZW50TWV0YSA9IGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRClcbiAgICBjb25zdCBwcmV2U3RhdGUgPSBhd2FyZW5lc3Muc3RhdGVzLmdldChjbGllbnRJRClcbiAgICBjb25zdCBjdXJyQ2xvY2sgPSBjbGllbnRNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY2xpZW50TWV0YS5jbG9ja1xuICAgIGlmIChjdXJyQ2xvY2sgPCBjbG9jayB8fCAoY3VyckNsb2NrID09PSBjbG9jayAmJiBzdGF0ZSA9PT0gbnVsbCAmJiBhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbmV2ZXIgbGV0IGEgcmVtb3RlIGNsaWVudCByZW1vdmUgdGhpcyBsb2NhbCBzdGF0ZVxuICAgICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCAmJiBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpICE9IG51bGwpIHtcbiAgICAgICAgICAvLyByZW1vdGUgY2xpZW50IHJlbW92ZWQgdGhlIGxvY2FsIHN0YXRlLiBEbyBub3QgcmVtb3RlIHN0YXRlLiBCcm9hZGNhc3QgYSBtZXNzYWdlIGluZGljYXRpbmdcbiAgICAgICAgICAvLyB0aGF0IHRoaXMgY2xpZW50IHN0aWxsIGV4aXN0cyBieSBpbmNyZWFzaW5nIHRoZSBjbG9ja1xuICAgICAgICAgIGNsb2NrKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgICAgfVxuICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgIGNsb2NrLFxuICAgICAgICBsYXN0VXBkYXRlZDogdGltZXN0YW1wXG4gICAgICB9KVxuICAgICAgaWYgKGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRNZXRhICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWYuZXF1YWxpdHlEZWVwKHN0YXRlLCBwcmV2U3RhdGUpKSB7XG4gICAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IHVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSlcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/y-protocols/awareness.js\n')},"./node_modules/y-protocols/sync.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "messageYjsSyncStep1": () => (/* binding */ messageYjsSyncStep1),\n/* harmony export */   "messageYjsSyncStep2": () => (/* binding */ messageYjsSyncStep2),\n/* harmony export */   "messageYjsUpdate": () => (/* binding */ messageYjsUpdate),\n/* harmony export */   "writeSyncStep1": () => (/* binding */ writeSyncStep1),\n/* harmony export */   "writeSyncStep2": () => (/* binding */ writeSyncStep2),\n/* harmony export */   "readSyncStep1": () => (/* binding */ readSyncStep1),\n/* harmony export */   "readSyncStep2": () => (/* binding */ readSyncStep2),\n/* harmony export */   "writeUpdate": () => (/* binding */ writeUpdate),\n/* harmony export */   "readUpdate": () => (/* binding */ readUpdate),\n/* harmony export */   "readSyncMessage": () => (/* binding */ readSyncMessage)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding.js */ "./node_modules/lib0/decoding.js");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ "./node_modules/yjs/dist/yjs.mjs");\n/**\n * @module sync-protocol\n */\n\n\n\n\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nconst messageYjsSyncStep1 = 0\nconst messageYjsSyncStep2 = 1\nconst messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nconst writeSyncStep1 = (encoder, doc) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateVector(doc)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nconst writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsSyncStep2)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nconst readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    yjs__WEBPACK_IMPORTED_MODULE_1__.applyUpdate(doc, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error(\'Caught error while handling a Yjs update\', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nconst writeUpdate = (encoder, update) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsUpdate)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error(\'Unknown message type\')\n  }\n  return messageType\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9zeW5jLmpzPzU1YTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFNEM7QUFDQTtBQUNwQjs7QUFFeEI7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQjtBQUNPO0FBQ1AsRUFBRSwwREFBcUI7QUFDdkIsYUFBYSxrREFBbUI7QUFDaEMsRUFBRSxnRUFBMkI7QUFDN0I7O0FBRUE7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE1BQU07QUFDakIsV0FBVyxXQUFXO0FBQ3RCO0FBQ087QUFDUCxFQUFFLDBEQUFxQjtBQUN2QixFQUFFLGdFQUEyQixVQUFVLG9EQUFxQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE1BQU07QUFDakI7QUFDTztBQUNQLCtCQUErQiwrREFBMEI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixXQUFXLElBQUk7QUFDZjtBQUNPO0FBQ1A7QUFDQSxJQUFJLDRDQUFhLE1BQU0sK0RBQTBCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsV0FBVztBQUN0QjtBQUNPO0FBQ1AsRUFBRSwwREFBcUI7QUFDdkIsRUFBRSxnRUFBMkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsSUFBSTtBQUNmO0FBQ087O0FBRVA7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE1BQU07QUFDakIsV0FBVyxJQUFJO0FBQ2Y7QUFDTztBQUNQLHNCQUFzQix5REFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL3N5bmMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgc3luYy1wcm90b2NvbFxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5cbi8qKlxuICogQHR5cGVkZWYge01hcDxudW1iZXIsIG51bWJlcj59IFN0YXRlTWFwXG4gKi9cblxuLyoqXG4gKiBDb3JlIFlqcyBkZWZpbmVzIHR3byBtZXNzYWdlIHR5cGVzOlxuICog4oCiIFlqc1N5bmNTdGVwMTogSW5jbHVkZXMgdGhlIFN0YXRlIFNldCBvZiB0aGUgc2VuZGluZyBjbGllbnQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgc2hvdWxkIHJlcGx5IHdpdGggWWpzU3luY1N0ZXAyLlxuICog4oCiIFlqc1N5bmNTdGVwMjogSW5jbHVkZXMgYWxsIG1pc3Npbmcgc3RydWN0cyBhbmQgdGhlIGNvbXBsZXRlIGRlbGV0ZSBzZXQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgaXMgYXNzdXJlZCB0aGF0IGl0XG4gKiAgIHJlY2VpdmVkIGFsbCBpbmZvcm1hdGlvbiBmcm9tIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgcGVlci10by1wZWVyIG5ldHdvcmssIHlvdSBtYXkgd2FudCB0byBpbnRyb2R1Y2UgYSBTeW5jRG9uZSBtZXNzYWdlIHR5cGUuIEJvdGggcGFydGllcyBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb25cbiAqIHdpdGggU3luY1N0ZXAxLiBXaGVuIGEgY2xpZW50IHJlY2VpdmVkIFN5bmNTdGVwMiwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY0RvbmUuIFdoZW4gdGhlIGxvY2FsIGNsaWVudCByZWNlaXZlZCBib3RoXG4gKiBTeW5jU3RlcDIgYW5kIFN5bmNEb25lLCBpdCBpcyBhc3N1cmVkIHRoYXQgaXQgaXMgc3luY2VkIHRvIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgY2xpZW50LXNlcnZlciBtb2RlbCwgeW91IHdhbnQgdG8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHk6IFRoZSBjbGllbnQgc2hvdWxkIGluaXRpYXRlIHRoZSBjb25uZWN0aW9uIHdpdGggU3luY1N0ZXAxLlxuICogV2hlbiB0aGUgc2VydmVyIHJlY2VpdmVzIFN5bmNTdGVwMSwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY1N0ZXAyIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFN5bmNTdGVwMS4gVGhlIGNsaWVudCByZXBsaWVzXG4gKiB3aXRoIFN5bmNTdGVwMiB3aGVuIGl0IHJlY2VpdmVzIFN5bmNTdGVwMS4gT3B0aW9uYWxseSB0aGUgc2VydmVyIG1heSBzZW5kIGEgU3luY0RvbmUgYWZ0ZXIgaXQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBzbyB0aGVcbiAqIGNsaWVudCBrbm93cyB0aGF0IHRoZSBzeW5jIGlzIGZpbmlzaGVkLiAgVGhlcmUgYXJlIHR3byByZWFzb25zIGZvciB0aGlzIG1vcmUgZWxhYm9yYXRlZCBzeW5jIG1vZGVsOiAxLiBUaGlzIHByb3RvY29sIGNhblxuICogZWFzaWx5IGJlIGltcGxlbWVudGVkIG9uIHRvcCBvZiBodHRwIGFuZCB3ZWJzb2NrZXRzLiAyLiBUaGUgc2VydmVyIHNob3VsIG9ubHkgcmVwbHkgdG8gcmVxdWVzdHMsIGFuZCBub3QgaW5pdGlhdGUgdGhlbS5cbiAqIFRoZXJlZm9yZSBpdCBpcyBuZWNlc2FycnkgdGhhdCB0aGUgY2xpZW50IGluaXRpYXRlcyB0aGUgc3luYy5cbiAqXG4gKiBDb25zdHJ1Y3Rpb24gb2YgYSBtZXNzYWdlOlxuICogW21lc3NhZ2VUeXBlIDogdmFyVWludCwgbWVzc2FnZSBkZWZpbml0aW9uLi5dXG4gKlxuICogTm90ZTogQSBtZXNzYWdlIGRvZXMgbm90IGluY2x1ZGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb20gbmFtZS4gVGhpcyBtdXN0IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVwcGVyIGxheWVyIHByb3RvY29sIVxuICpcbiAqIHN0cmluZ2lmeVttZXNzYWdlVHlwZV0gc3RyaW5naWZpZXMgYSBtZXNzYWdlIGRlZmluaXRpb24gKG1lc3NhZ2VUeXBlIGlzIGFscmVhZHkgcmVhZCBmcm9tIHRoZSBidWZmZmVyKVxuICovXG5cbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzU3luY1N0ZXAxID0gMFxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDIgPSAxXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1VwZGF0ZSA9IDJcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW5jIHN0ZXAgMSBtZXNzYWdlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBzaGFyZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3luY1N0ZXAxID0gKGVuY29kZXIsIGRvYykgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMSlcbiAgY29uc3Qgc3YgPSBZLmVuY29kZVN0YXRlVmVjdG9yKGRvYylcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHN2KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkU3RhdGVWZWN0b3JdXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVN5bmNTdGVwMiA9IChlbmNvZGVyLCBkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMilcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikpXG59XG5cbi8qKlxuICogUmVhZCBTeW5jU3RlcDEgbWVzc2FnZSBhbmQgcmVwbHkgd2l0aCBTeW5jU3RlcDIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIFRoZSByZXBseSB0byB0aGUgcmVjZWl2ZWQgbWVzc2FnZVxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyIFRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jU3RlcDEgPSAoZGVjb2RlciwgZW5jb2RlciwgZG9jKSA9PlxuICB3cml0ZVN5bmNTdGVwMihlbmNvZGVyLCBkb2MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jU3RlcDIgPSAoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4ge1xuICB0cnkge1xuICAgIFkuYXBwbHlVcGRhdGUoZG9jLCBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgdHJhbnNhY3Rpb25PcmlnaW4pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyB0aGF0IGFyZSB0aHJvd24gYnkgZXZlbnQgaGFuZGxlcnNcbiAgICBjb25zb2xlLmVycm9yKCdDYXVnaHQgZXJyb3Igd2hpbGUgaGFuZGxpbmcgYSBZanMgdXBkYXRlJywgZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVwZGF0ZSA9IChlbmNvZGVyLCB1cGRhdGUpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNVcGRhdGUpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB1cGRhdGUpXG59XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFVwZGF0ZSA9IHJlYWRTeW5jU3RlcDJcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgQSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gYW5vdGhlciBjbGllbnRcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVwbHkgbWVzc2FnZS4gV2lsbCBub3QgYmUgc2VudCBpZiBlbXB0eS5cbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3luY01lc3NhZ2UgPSAoZGVjb2RlciwgZW5jb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4ge1xuICBjb25zdCBtZXNzYWdlVHlwZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcbiAgICBjYXNlIG1lc3NhZ2VZanNTeW5jU3RlcDE6XG4gICAgICByZWFkU3luY1N0ZXAxKGRlY29kZXIsIGVuY29kZXIsIGRvYylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAyOlxuICAgICAgcmVhZFN5bmNTdGVwMihkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VZanNVcGRhdGU6XG4gICAgICByZWFkVXBkYXRlKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSB0eXBlJylcbiAgfVxuICByZXR1cm4gbWVzc2FnZVR5cGVcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/y-protocols/sync.js\n')},"./node_modules/y-websocket/src/y-websocket.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebsocketProvider\": () => (/* binding */ WebsocketProvider)\n/* harmony export */ });\n/* harmony import */ var lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/broadcastchannel.js */ \"./node_modules/lib0/broadcastchannel.js\");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/time.js */ \"./node_modules/lib0/time.js\");\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/encoding.js */ \"./node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/decoding.js */ \"./node_modules/lib0/decoding.js\");\n/* harmony import */ var y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/sync.js */ \"./node_modules/y-protocols/sync.js\");\n/* harmony import */ var y_protocols_auth_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-protocols/auth.js */ \"./node_modules/y-protocols/auth.js\");\n/* harmony import */ var y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness.js */ \"./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var lib0_mutex_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/mutex.js */ \"./node_modules/lib0/mutex.js\");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/observable.js */ \"./node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/math.js */ \"./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_url_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/url.js */ \"./node_modules/lib0/url.js\");\n/*\nUnlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.\n*/\n\n/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\nconst messageSync = 0\nconst messageQueryAwareness = 3\nconst messageAwareness = 1\nconst messageAuth = 2\n\n/**\n *                       encoder,          decoder,          provider,          emitSynced, messageType\n * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}\n */\nconst messageHandlers = []\n\nmessageHandlers[messageSync] = (encoder, decoder, provider, emitSynced, messageType) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n  const syncMessageType = y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.readSyncMessage(decoder, encoder, provider.doc, provider)\n  if (emitSynced && syncMessageType === y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.messageYjsSyncStep2 && !provider.synced) {\n    provider.synced = true\n  }\n}\n\nmessageHandlers[messageQueryAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageAwareness)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())))\n}\n\nmessageHandlers[messageAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {\n  y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.applyAwarenessUpdate(provider.awareness, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__.readVarUint8Array(decoder), provider)\n}\n\nmessageHandlers[messageAuth] = (encoder, decoder, provider, emitSynced, messageType) => {\n  y_protocols_auth_js__WEBPACK_IMPORTED_MODULE_1__.readAuthMessage(decoder, provider.doc, permissionDeniedHandler)\n}\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\nconst permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\\n${reason}`)\n\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\nconst readMessage = (provider, buf, emitSynced) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__.createDecoder(buf)\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n  const messageType = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__.readVarUint(decoder)\n  const messageHandler = provider.messageHandlers[messageType]\n  if (/** @type {any} */ (messageHandler)) {\n    messageHandler(encoder, decoder, provider, emitSynced, messageType)\n  } else {\n    console.error('Unable to compute message')\n  }\n  return encoder\n}\n\n/**\n * @param {WebsocketProvider} provider\n */\nconst setupWS = provider => {\n  if (provider.shouldConnect && provider.ws === null) {\n    const websocket = new provider._WS(provider.url)\n    websocket.binaryType = 'arraybuffer'\n    provider.ws = websocket\n    provider.wsconnecting = true\n    provider.wsconnected = false\n    provider.synced = false\n\n    websocket.onmessage = event => {\n      provider.wsLastMessageReceived = lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime()\n      const encoder = readMessage(provider, new Uint8Array(event.data), true)\n      if (lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.length(encoder) > 1) {\n        websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n      }\n    }\n    websocket.onclose = () => {\n      provider.ws = null\n      provider.wsconnecting = false\n      if (provider.wsconnected) {\n        provider.wsconnected = false\n        provider.synced = false\n        // update awareness (all users except local left)\n        y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter(client => client !== provider.doc.clientID), provider)\n        provider.emit('status', [{\n          status: 'disconnected'\n        }])\n      } else {\n        provider.wsUnsuccessfulReconnects++\n      }\n      // Start with no reconnect timeout and increase timeout by\n      // log10(wsUnsuccessfulReconnects).\n      // The idea is to increase reconnect timeout slowly and have no reconnect\n      // timeout at the beginning (log(1) = 0)\n      setTimeout(setupWS, lib0_math_js__WEBPACK_IMPORTED_MODULE_6__.min(lib0_math_js__WEBPACK_IMPORTED_MODULE_6__.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider)\n    }\n    websocket.onopen = () => {\n      provider.wsLastMessageReceived = lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime()\n      provider.wsconnecting = false\n      provider.wsconnected = true\n      provider.wsUnsuccessfulReconnects = 0\n      provider.emit('status', [{\n        status: 'connected'\n      }])\n      // always send sync step 1 when connected\n      const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoder, provider.doc)\n      websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n      // broadcast local awareness state\n      if (provider.awareness.getLocalState() !== null) {\n        const encoderAwarenessState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderAwarenessState, messageAwareness)\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]))\n        websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderAwarenessState))\n      }\n    }\n\n    provider.emit('status', [{\n      status: 'connecting'\n    }])\n  }\n}\n\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\nconst broadcastMessage = (provider, buf) => {\n  if (provider.wsconnected) {\n    // @ts-ignore We know that wsconnected = true\n    provider.ws.send(buf)\n  }\n  if (provider.bcconnected) {\n    provider.mux(() => {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(provider.bcChannel, buf)\n    })\n  }\n}\n\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {Observable<string>}\n */\nclass WebsocketProvider extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_8__.Observable {\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} [opts]\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params]\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   */\n  constructor (serverUrl, roomname, doc, { connect = true, awareness = new y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1 } = {}) {\n    super()\n    // ensure that url is always ends with /\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1)\n    }\n    const encodedParams = lib0_url_js__WEBPACK_IMPORTED_MODULE_9__.encodeQueryParams(params)\n    this.bcChannel = serverUrl + '/' + roomname\n    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams)\n    this.roomname = roomname\n    this.doc = doc\n    this._WS = WebSocketPolyfill\n    this.awareness = awareness\n    this.wsconnected = false\n    this.wsconnecting = false\n    this.bcconnected = false\n    this.wsUnsuccessfulReconnects = 0\n    this.messageHandlers = messageHandlers.slice()\n    this.mux = lib0_mutex_js__WEBPACK_IMPORTED_MODULE_10__.createMutex()\n    /**\n     * @type {boolean}\n     */\n    this._synced = false\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.wsLastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = connect\n\n    /**\n     * @type {number}\n     */\n    this._resyncInterval = 0\n    if (resyncInterval > 0) {\n      this._resyncInterval = /** @type {any} */ (setInterval(() => {\n        if (this.ws) {\n          // resend sync step 1\n          const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n          lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n          y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoder, doc)\n          this.ws.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n        }\n      }, resyncInterval))\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data => {\n      this.mux(() => {\n        const encoder = readMessage(this, new Uint8Array(data), false)\n        if (lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.length(encoder) > 1) {\n          lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n        }\n      })\n    }\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._updateHandler = (update, origin) => {\n      if (origin !== this || origin === null) {\n        const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n        y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeUpdate(encoder, update)\n        broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n      }\n    }\n    this.doc.on('update', this._updateHandler)\n    /**\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageAwareness)\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(awareness, changedClients))\n      broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n    }\n    window.addEventListener('beforeunload', () => {\n      y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')\n    })\n    awareness.on('update', this._awarenessUpdateHandler)\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      if (this.wsconnected && messageReconnectTimeout < lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime() - this.wsLastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 10))\n    if (connect) {\n      this.connect()\n    }\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get synced () {\n    return this._synced\n  }\n\n  set synced (state) {\n    if (this._synced !== state) {\n      this._synced = state\n      this.emit('synced', [state])\n      this.emit('sync', [state])\n    }\n  }\n\n  destroy () {\n    if (this._resyncInterval !== 0) {\n      clearInterval(this._resyncInterval)\n    }\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.doc.off('update', this._updateHandler)\n    super.destroy()\n  }\n\n  connectBc () {\n    if (!this.bcconnected) {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.subscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = true\n    }\n    // send sync step1 to bc\n    this.mux(() => {\n      // write sync step 1\n      const encoderSync = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderSync, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoderSync, this.doc)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderSync))\n      // broadcast local state\n      const encoderState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderState, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep2(encoderState, this.doc)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderState))\n      // write queryAwareness\n      const encoderAwarenessQuery = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderAwarenessQuery))\n      // broadcast local awareness state\n      const encoderAwarenessState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderAwarenessState, messageAwareness)\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderAwarenessState))\n    })\n  }\n\n  disconnectBc () {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageAwareness)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()))\n    broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n    if (this.bcconnected) {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.unsubscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = false\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.disconnectBc()\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.wsconnected && this.ws === null) {\n      setupWS(this)\n      this.connectBc()\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy95LXdlYnNvY2tldC9zcmMveS13ZWJzb2NrZXQuanM/MmUzMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUV3QjtBQUNzQjtBQUNWO0FBQ1E7QUFDQTtBQUNPO0FBQ0E7QUFDVTtBQUN2QjtBQUNTO0FBQ1g7QUFDRjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwREFBcUI7QUFDdkIsMEJBQTBCLGdFQUE0QjtBQUN0RCx3Q0FBd0Msb0VBQWdDO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsMERBQXFCO0FBQ3ZCLEVBQUUsZ0VBQTJCLFVBQVUsMkVBQXVDO0FBQzlFOztBQUVBO0FBQ0EsRUFBRSwwRUFBc0MscUJBQXFCLCtEQUEwQjtBQUN2Rjs7QUFFQTtBQUNBLEVBQUUsZ0VBQTRCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxPQUFPO0FBQ2xCO0FBQ0Esa0dBQWtHLGFBQWEsS0FBSyxPQUFPOztBQUUzSDtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQXNCO0FBQ3hDLGtCQUFrQiwyREFBc0I7QUFDeEMsc0JBQXNCLHlEQUFvQjtBQUMxQztBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHFEQUFnQjtBQUN2RDtB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TDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSwrREFBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFzQjtBQUNoRCxNQUFNLDBEQUFxQjtBQUMzQixNQUFNLCtEQUEyQjtBQUNqQyxNQUFNLDZEQUFVLGlCQUFpQiwwREFBcUI7QUFDdEQ7QUFDQSwyQkFBMkIsMkRBQXNCO0FBQ2pELE1BQU0sMERBQXFCO0FBQzNCLE1BQU0sK0RBQTJCO0FBQ2pDLE1BQU0sNkRBQVUsaUJBQWlCLDBEQUFxQjtBQUN0RDtBQUNBLG9DQUFvQywyREFBc0I7QUFDMUQsTUFBTSwwREFBcUI7QUFDM0IsTUFBTSw2REFBVSxpQkFBaUIsMERBQXFCO0FBQ3REO0FBQ0Esb0NBQW9DLDJEQUFzQjtBQUMxRCxNQUFNLDBEQUFxQjtBQUMzQixNQUFNLGdFQUEyQix3QkFBd0IsMkVBQXVDO0FBQ2hHLE1BQU0sNkRBQVUsaUJBQWlCLDBEQUFxQjtBQUN0RCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwyREFBc0I7QUFDMUMsSUFBSSwwREFBcUI7QUFDekIsSUFBSSxnRUFBMkIsVUFBVSwyRUFBdUM7QUFDaEYsMkJBQTJCLDBEQUFxQjtBQUNoRDtBQUNBLE1BQU0saUVBQWM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveS13ZWJzb2NrZXQvc3JjL3ktd2Vic29ja2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblVubGlrZSBzdGF0ZWQgaW4gdGhlIExJQ0VOU0UgZmlsZSwgaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBpbmNsdWRlIHRoZSBjb3B5cmlnaHQgbm90aWNlIGFuZCBwZXJtaXNzaW9uIG5vdGljZSB3aGVuIHlvdSBjb3B5IGNvZGUgZnJvbSB0aGlzIGZpbGUuXG4qL1xuXG4vKipcbiAqIEBtb2R1bGUgcHJvdmlkZXIvd2Vic29ja2V0XG4gKi9cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBiYyBmcm9tICdsaWIwL2Jyb2FkY2FzdGNoYW5uZWwuanMnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZS5qcydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgc3luY1Byb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL3N5bmMuanMnXG5pbXBvcnQgKiBhcyBhdXRoUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvYXV0aC5qcydcbmltcG9ydCAqIGFzIGF3YXJlbmVzc1Byb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcydcbmltcG9ydCAqIGFzIG11dGV4IGZyb20gJ2xpYjAvbXV0ZXguanMnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGguanMnXG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAnbGliMC91cmwuanMnXG5cbmNvbnN0IG1lc3NhZ2VTeW5jID0gMFxuY29uc3QgbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzID0gM1xuY29uc3QgbWVzc2FnZUF3YXJlbmVzcyA9IDFcbmNvbnN0IG1lc3NhZ2VBdXRoID0gMlxuXG4vKipcbiAqICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVyLCAgICAgICAgICBkZWNvZGVyLCAgICAgICAgICBwcm92aWRlciwgICAgICAgICAgZW1pdFN5bmNlZCwgbWVzc2FnZVR5cGVcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihlbmNvZGluZy5FbmNvZGVyLCBkZWNvZGluZy5EZWNvZGVyLCBXZWJzb2NrZXRQcm92aWRlciwgYm9vbGVhbiwgICAgbnVtYmVyKTp2b2lkPn1cbiAqL1xuY29uc3QgbWVzc2FnZUhhbmRsZXJzID0gW11cblxubWVzc2FnZUhhbmRsZXJzW21lc3NhZ2VTeW5jXSA9IChlbmNvZGVyLCBkZWNvZGVyLCBwcm92aWRlciwgZW1pdFN5bmNlZCwgbWVzc2FnZVR5cGUpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICBjb25zdCBzeW5jTWVzc2FnZVR5cGUgPSBzeW5jUHJvdG9jb2wucmVhZFN5bmNNZXNzYWdlKGRlY29kZXIsIGVuY29kZXIsIHByb3ZpZGVyLmRvYywgcHJvdmlkZXIpXG4gIGlmIChlbWl0U3luY2VkICYmIHN5bmNNZXNzYWdlVHlwZSA9PT0gc3luY1Byb3RvY29sLm1lc3NhZ2VZanNTeW5jU3RlcDIgJiYgIXByb3ZpZGVyLnN5bmNlZCkge1xuICAgIHByb3ZpZGVyLnN5bmNlZCA9IHRydWVcbiAgfVxufVxuXG5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzXSA9IChlbmNvZGVyLCBkZWNvZGVyLCBwcm92aWRlciwgZW1pdFN5bmNlZCwgbWVzc2FnZVR5cGUpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUocHJvdmlkZXIuYXdhcmVuZXNzLCBBcnJheS5mcm9tKHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5rZXlzKCkpKSlcbn1cblxubWVzc2FnZUhhbmRsZXJzW21lc3NhZ2VBd2FyZW5lc3NdID0gKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSkgPT4ge1xuICBhd2FyZW5lc3NQcm90b2NvbC5hcHBseUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCBwcm92aWRlcilcbn1cblxubWVzc2FnZUhhbmRsZXJzW21lc3NhZ2VBdXRoXSA9IChlbmNvZGVyLCBkZWNvZGVyLCBwcm92aWRlciwgZW1pdFN5bmNlZCwgbWVzc2FnZVR5cGUpID0+IHtcbiAgYXV0aFByb3RvY29sLnJlYWRBdXRoTWVzc2FnZShkZWNvZGVyLCBwcm92aWRlci5kb2MsIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKVxufVxuXG5jb25zdCByZWNvbm5lY3RUaW1lb3V0QmFzZSA9IDEyMDBcbmNvbnN0IG1heFJlY29ubmVjdFRpbWVvdXQgPSAyNTAwXG4vLyBAdG9kbyAtIHRoaXMgc2hvdWxkIGRlcGVuZCBvbiBhd2FyZW5lc3Mub3V0ZGF0ZWRUaW1lXG5jb25zdCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA9IDMwMDAwXG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAqL1xuY29uc3QgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIgPSAocHJvdmlkZXIsIHJlYXNvbikgPT4gY29uc29sZS53YXJuKGBQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgJHtwcm92aWRlci51cmx9LlxcbiR7cmVhc29ufWApXG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVtaXRTeW5jZWRcbiAqIEByZXR1cm4ge2VuY29kaW5nLkVuY29kZXJ9XG4gKi9cbmNvbnN0IHJlYWRNZXNzYWdlID0gKHByb3ZpZGVyLCBidWYsIGVtaXRTeW5jZWQpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBwcm92aWRlci5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZVR5cGVdXG4gIGlmICgvKiogQHR5cGUge2FueX0gKi8gKG1lc3NhZ2VIYW5kbGVyKSkge1xuICAgIG1lc3NhZ2VIYW5kbGVyKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSlcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gY29tcHV0ZSBtZXNzYWdlJylcbiAgfVxuICByZXR1cm4gZW5jb2RlclxufVxuXG4vKipcbiAqIEBwYXJhbSB7V2Vic29ja2V0UHJvdmlkZXJ9IHByb3ZpZGVyXG4gKi9cbmNvbnN0IHNldHVwV1MgPSBwcm92aWRlciA9PiB7XG4gIGlmIChwcm92aWRlci5zaG91bGRDb25uZWN0ICYmIHByb3ZpZGVyLndzID09PSBudWxsKSB7XG4gICAgY29uc3Qgd2Vic29ja2V0ID0gbmV3IHByb3ZpZGVyLl9XUyhwcm92aWRlci51cmwpXG4gICAgd2Vic29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgcHJvdmlkZXIud3MgPSB3ZWJzb2NrZXRcbiAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSB0cnVlXG4gICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgIHByb3ZpZGVyLnN5bmNlZCA9IGZhbHNlXG5cbiAgICB3ZWJzb2NrZXQub25tZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBjb25zdCBlbmNvZGVyID0gcmVhZE1lc3NhZ2UocHJvdmlkZXIsIG5ldyBVaW50OEFycmF5KGV2ZW50LmRhdGEpLCB0cnVlKVxuICAgICAgaWYgKGVuY29kaW5nLmxlbmd0aChlbmNvZGVyKSA+IDEpIHtcbiAgICAgICAgd2Vic29ja2V0LnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgfVxuICAgIH1cbiAgICB3ZWJzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHByb3ZpZGVyLndzID0gbnVsbFxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIGlmIChwcm92aWRlci53c2Nvbm5lY3RlZCkge1xuICAgICAgICBwcm92aWRlci53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICAgIHByb3ZpZGVyLnN5bmNlZCA9IGZhbHNlXG4gICAgICAgIC8vIHVwZGF0ZSBhd2FyZW5lc3MgKGFsbCB1c2VycyBleGNlcHQgbG9jYWwgbGVmdClcbiAgICAgICAgYXdhcmVuZXNzUHJvdG9jb2wucmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHByb3ZpZGVyLmF3YXJlbmVzcywgQXJyYXkuZnJvbShwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudCAhPT0gcHJvdmlkZXIuZG9jLmNsaWVudElEKSwgcHJvdmlkZXIpXG4gICAgICAgIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICAgICAgc3RhdHVzOiAnZGlzY29ubmVjdGVkJ1xuICAgICAgICB9XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cysrXG4gICAgICB9XG4gICAgICAvLyBTdGFydCB3aXRoIG5vIHJlY29ubmVjdCB0aW1lb3V0IGFuZCBpbmNyZWFzZSB0aW1lb3V0IGJ5XG4gICAgICAvLyBsb2cxMCh3c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMpLlxuICAgICAgLy8gVGhlIGlkZWEgaXMgdG8gaW5jcmVhc2UgcmVjb25uZWN0IHRpbWVvdXQgc2xvd2x5IGFuZCBoYXZlIG5vIHJlY29ubmVjdFxuICAgICAgLy8gdGltZW91dCBhdCB0aGUgYmVnaW5uaW5nIChsb2coMSkgPSAwKVxuICAgICAgc2V0VGltZW91dChzZXR1cFdTLCBtYXRoLm1pbihtYXRoLmxvZzEwKHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyArIDEpICogcmVjb25uZWN0VGltZW91dEJhc2UsIG1heFJlY29ubmVjdFRpbWVvdXQpLCBwcm92aWRlcilcbiAgICB9XG4gICAgd2Vic29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHByb3ZpZGVyLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIHByb3ZpZGVyLndzY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgcHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgc3RhdHVzOiAnY29ubmVjdGVkJ1xuICAgICAgfV0pXG4gICAgICAvLyBhbHdheXMgc2VuZCBzeW5jIHN0ZXAgMSB3aGVuIGNvbm5lY3RlZFxuICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAxKGVuY29kZXIsIHByb3ZpZGVyLmRvYylcbiAgICAgIHdlYnNvY2tldC5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGVcbiAgICAgIGlmIChwcm92aWRlci5hd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NTdGF0ZSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUocHJvdmlkZXIuYXdhcmVuZXNzLCBbcHJvdmlkZXIuZG9jLmNsaWVudElEXSkpXG4gICAgICAgIHdlYnNvY2tldC5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICBzdGF0dXM6ICdjb25uZWN0aW5nJ1xuICAgIH1dKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZlxuICovXG5jb25zdCBicm9hZGNhc3RNZXNzYWdlID0gKHByb3ZpZGVyLCBidWYpID0+IHtcbiAgaWYgKHByb3ZpZGVyLndzY29ubmVjdGVkKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBXZSBrbm93IHRoYXQgd3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgcHJvdmlkZXIud3Muc2VuZChidWYpXG4gIH1cbiAgaWYgKHByb3ZpZGVyLmJjY29ubmVjdGVkKSB7XG4gICAgcHJvdmlkZXIubXV4KCgpID0+IHtcbiAgICAgIGJjLnB1Ymxpc2gocHJvdmlkZXIuYmNDaGFubmVsLCBidWYpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIFdlYnNvY2tldCBQcm92aWRlciBmb3IgWWpzLiBDcmVhdGVzIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gdG8gc3luYyB0aGUgc2hhcmVkIGRvY3VtZW50LlxuICogVGhlIGRvY3VtZW50IG5hbWUgaXMgYXR0YWNoZWQgdG8gdGhlIHByb3ZpZGVkIHVybC4gSS5lLiB0aGUgZm9sbG93aW5nIGV4YW1wbGVcbiAqIGNyZWF0ZXMgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB0byBodHRwOi8vbG9jYWxob3N0OjEyMzQvbXktZG9jdW1lbnQtbmFtZVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuICogICBpbXBvcnQgeyBXZWJzb2NrZXRQcm92aWRlciB9IGZyb20gJ3ktd2Vic29ja2V0J1xuICogICBjb25zdCBkb2MgPSBuZXcgWS5Eb2MoKVxuICogICBjb25zdCBwcm92aWRlciA9IG5ldyBXZWJzb2NrZXRQcm92aWRlcignaHR0cDovL2xvY2FsaG9zdDoxMjM0JywgJ215LWRvY3VtZW50LW5hbWUnLCBkb2MpXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYnNvY2tldFByb3ZpZGVyIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyVXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tbmFtZVxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmNvbm5lY3RdXG4gICAqIEBwYXJhbSB7YXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzfSBbb3B0cy5hd2FyZW5lc3NdXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fSBbb3B0cy5wYXJhbXNdXG4gICAqIEBwYXJhbSB7dHlwZW9mIFdlYlNvY2tldH0gW29wdHMuV2ViU29ja2V0UG9seWZpbGxdIE9wdGlvbmFsbCBwcm92aWRlIGEgV2ViU29ja2V0IHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5yZXN5bmNJbnRlcnZhbF0gUmVxdWVzdCBzZXJ2ZXIgc3RhdGUgZXZlcnkgYHJlc3luY0ludGVydmFsYCBtaWxsaXNlY29uZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzZXJ2ZXJVcmwsIHJvb21uYW1lLCBkb2MsIHsgY29ubmVjdCA9IHRydWUsIGF3YXJlbmVzcyA9IG5ldyBhd2FyZW5lc3NQcm90b2NvbC5Bd2FyZW5lc3MoZG9jKSwgcGFyYW1zID0ge30sIFdlYlNvY2tldFBvbHlmaWxsID0gV2ViU29ja2V0LCByZXN5bmNJbnRlcnZhbCA9IC0xIH0gPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICAvLyBlbnN1cmUgdGhhdCB1cmwgaXMgYWx3YXlzIGVuZHMgd2l0aCAvXG4gICAgd2hpbGUgKHNlcnZlclVybFtzZXJ2ZXJVcmwubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgc2VydmVyVXJsID0gc2VydmVyVXJsLnNsaWNlKDAsIHNlcnZlclVybC5sZW5ndGggLSAxKVxuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gdXJsLmVuY29kZVF1ZXJ5UGFyYW1zKHBhcmFtcylcbiAgICB0aGlzLmJjQ2hhbm5lbCA9IHNlcnZlclVybCArICcvJyArIHJvb21uYW1lXG4gICAgdGhpcy51cmwgPSBzZXJ2ZXJVcmwgKyAnLycgKyByb29tbmFtZSArIChlbmNvZGVkUGFyYW1zLmxlbmd0aCA9PT0gMCA/ICcnIDogJz8nICsgZW5jb2RlZFBhcmFtcylcbiAgICB0aGlzLnJvb21uYW1lID0gcm9vbW5hbWVcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHRoaXMuX1dTID0gV2ViU29ja2V0UG9seWZpbGxcbiAgICB0aGlzLmF3YXJlbmVzcyA9IGF3YXJlbmVzc1xuICAgIHRoaXMud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLmJjY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycyA9IG1lc3NhZ2VIYW5kbGVycy5zbGljZSgpXG4gICAgdGhpcy5tdXggPSBtdXRleC5jcmVhdGVNdXRleCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fc3luY2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2ViU29ja2V0P31cbiAgICAgKi9cbiAgICB0aGlzLndzID0gbnVsbFxuICAgIHRoaXMud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gMFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gY29ubmVjdCB0byBvdGhlciBwZWVycyBvciBub3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBjb25uZWN0XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gMFxuICAgIGlmIChyZXN5bmNJbnRlcnZhbCA+IDApIHtcbiAgICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgLy8gcmVzZW5kIHN5bmMgc3RlcCAxXG4gICAgICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgICAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDEoZW5jb2RlciwgZG9jKVxuICAgICAgICAgIHRoaXMud3Muc2VuZChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgICAgIH1cbiAgICAgIH0sIHJlc3luY0ludGVydmFsKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAgICovXG4gICAgdGhpcy5fYmNTdWJzY3JpYmVyID0gZGF0YSA9PiB7XG4gICAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSByZWFkTWVzc2FnZSh0aGlzLCBuZXcgVWludDhBcnJheShkYXRhKSwgZmFsc2UpXG4gICAgICAgIGlmIChlbmNvZGluZy5sZW5ndGgoZW5jb2RlcikgPiAxKSB7XG4gICAgICAgICAgYmMucHVibGlzaCh0aGlzLmJjQ2hhbm5lbCwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0ZW5zIHRvIFlqcyB1cGRhdGVzIGFuZCBzZW5kcyB0aGVtIHRvIHJlbW90ZSBwZWVycyAod3MgYW5kIGJyb2FkY2FzdGNoYW5uZWwpXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAgICovXG4gICAgdGhpcy5fdXBkYXRlSGFuZGxlciA9ICh1cGRhdGUsIG9yaWdpbikgPT4ge1xuICAgICAgaWYgKG9yaWdpbiAhPT0gdGhpcyB8fCBvcmlnaW4gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICAgIHN5bmNQcm90b2NvbC53cml0ZVVwZGF0ZShlbmNvZGVyLCB1cGRhdGUpXG4gICAgICAgIGJyb2FkY2FzdE1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRvYy5vbigndXBkYXRlJywgdGhpcy5fdXBkYXRlSGFuZGxlcilcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICAgKi9cbiAgICB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyID0gKHsgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgb3JpZ2luKSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VkQ2xpZW50cyA9IGFkZGVkLmNvbmNhdCh1cGRhdGVkKS5jb25jYXQocmVtb3ZlZClcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShhd2FyZW5lc3MsIGNoYW5nZWRDbGllbnRzKSlcbiAgICAgIGJyb2FkY2FzdE1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgKCkgPT4ge1xuICAgICAgYXdhcmVuZXNzUHJvdG9jb2wucmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMuYXdhcmVuZXNzLCBbZG9jLmNsaWVudElEXSwgJ3dpbmRvdyB1bmxvYWQnKVxuICAgIH0pXG4gICAgYXdhcmVuZXNzLm9uKCd1cGRhdGUnLCB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyKVxuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndzY29ubmVjdGVkICYmIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IDwgdGltZS5nZXRVbml4VGltZSgpIC0gdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQpIHtcbiAgICAgICAgLy8gbm8gbWVzc2FnZSByZWNlaXZlZCBpbiBhIGxvbmcgdGltZSAtIG5vdCBldmVuIHlvdXIgb3duIGF3YXJlbmVzc1xuICAgICAgICAvLyB1cGRhdGVzICh3aGljaCBhcmUgdXBkYXRlZCBldmVyeSAxNSBzZWNvbmRzKVxuICAgICAgICAvKiogQHR5cGUge1dlYlNvY2tldH0gKi8gKHRoaXMud3MpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDEwKSlcbiAgICBpZiAoY29ubmVjdCkge1xuICAgICAgdGhpcy5jb25uZWN0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc3luY2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY2VkXG4gIH1cblxuICBzZXQgc3luY2VkIChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zeW5jZWQgIT09IHN0YXRlKSB7XG4gICAgICB0aGlzLl9zeW5jZWQgPSBzdGF0ZVxuICAgICAgdGhpcy5lbWl0KCdzeW5jZWQnLCBbc3RhdGVdKVxuICAgICAgdGhpcy5lbWl0KCdzeW5jJywgW3N0YXRlXSlcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5fcmVzeW5jSW50ZXJ2YWwgIT09IDApIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVzeW5jSW50ZXJ2YWwpXG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIHRoaXMuYXdhcmVuZXNzLm9mZigndXBkYXRlJywgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLmRvYy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZUhhbmRsZXIpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBjb25uZWN0QmMgKCkge1xuICAgIGlmICghdGhpcy5iY2Nvbm5lY3RlZCkge1xuICAgICAgYmMuc3Vic2NyaWJlKHRoaXMuYmNDaGFubmVsLCB0aGlzLl9iY1N1YnNjcmliZXIpXG4gICAgICB0aGlzLmJjY29ubmVjdGVkID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBzZW5kIHN5bmMgc3RlcDEgdG8gYmNcbiAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAvLyB3cml0ZSBzeW5jIHN0ZXAgMVxuICAgICAgY29uc3QgZW5jb2RlclN5bmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyU3luYywgbWVzc2FnZVN5bmMpXG4gICAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDEoZW5jb2RlclN5bmMsIHRoaXMuZG9jKVxuICAgICAgYmMucHVibGlzaCh0aGlzLmJjQ2hhbm5lbCwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTeW5jKSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBzdGF0ZVxuICAgICAgY29uc3QgZW5jb2RlclN0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlclN0YXRlLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMihlbmNvZGVyU3RhdGUsIHRoaXMuZG9jKVxuICAgICAgYmMucHVibGlzaCh0aGlzLmJjQ2hhbm5lbCwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTdGF0ZSkpXG4gICAgICAvLyB3cml0ZSBxdWVyeUF3YXJlbmVzc1xuICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1F1ZXJ5ID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5LCBtZXNzYWdlUXVlcnlBd2FyZW5lc3MpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5KSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGVcbiAgICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NTdGF0ZSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jLmNsaWVudElEXSkpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlKSlcbiAgICB9KVxuICB9XG5cbiAgZGlzY29ubmVjdEJjICgpIHtcbiAgICAvLyBicm9hZGNhc3QgbWVzc2FnZSB3aXRoIGxvY2FsIGF3YXJlbmVzcyBzdGF0ZSBzZXQgdG8gbnVsbCAoaW5kaWNhdGluZyBkaXNjb25uZWN0KVxuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2MuY2xpZW50SURdLCBuZXcgTWFwKCkpKVxuICAgIGJyb2FkY2FzdE1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgIGlmICh0aGlzLmJjY29ubmVjdGVkKSB7XG4gICAgICBiYy51bnN1YnNjcmliZSh0aGlzLmJjQ2hhbm5lbCwgdGhpcy5fYmNTdWJzY3JpYmVyKVxuICAgICAgdGhpcy5iY2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2VcbiAgICB0aGlzLmRpc2Nvbm5lY3RCYygpXG4gICAgaWYgKHRoaXMud3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICBpZiAoIXRoaXMud3Njb25uZWN0ZWQgJiYgdGhpcy53cyA9PT0gbnVsbCkge1xuICAgICAgc2V0dXBXUyh0aGlzKVxuICAgICAgdGhpcy5jb25uZWN0QmMoKVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/y-websocket/src/y-websocket.js\n")},"./node_modules/yjs/dist/yjs.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractConnector\": () => (/* binding */ AbstractConnector),\n/* harmony export */   \"AbstractStruct\": () => (/* binding */ AbstractStruct),\n/* harmony export */   \"AbstractType\": () => (/* binding */ AbstractType),\n/* harmony export */   \"Array\": () => (/* binding */ YArray),\n/* harmony export */   \"ContentAny\": () => (/* binding */ ContentAny),\n/* harmony export */   \"ContentBinary\": () => (/* binding */ ContentBinary),\n/* harmony export */   \"ContentDeleted\": () => (/* binding */ ContentDeleted),\n/* harmony export */   \"ContentEmbed\": () => (/* binding */ ContentEmbed),\n/* harmony export */   \"ContentFormat\": () => (/* binding */ ContentFormat),\n/* harmony export */   \"ContentJSON\": () => (/* binding */ ContentJSON),\n/* harmony export */   \"ContentString\": () => (/* binding */ ContentString),\n/* harmony export */   \"ContentType\": () => (/* binding */ ContentType),\n/* harmony export */   \"Doc\": () => (/* binding */ Doc),\n/* harmony export */   \"GC\": () => (/* binding */ GC),\n/* harmony export */   \"ID\": () => (/* binding */ ID),\n/* harmony export */   \"Item\": () => (/* binding */ Item),\n/* harmony export */   \"Map\": () => (/* binding */ YMap),\n/* harmony export */   \"PermanentUserData\": () => (/* binding */ PermanentUserData),\n/* harmony export */   \"RelativePosition\": () => (/* binding */ RelativePosition),\n/* harmony export */   \"Snapshot\": () => (/* binding */ Snapshot),\n/* harmony export */   \"Text\": () => (/* binding */ YText),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"UndoManager\": () => (/* binding */ UndoManager),\n/* harmony export */   \"XmlElement\": () => (/* binding */ YXmlElement),\n/* harmony export */   \"XmlFragment\": () => (/* binding */ YXmlFragment),\n/* harmony export */   \"XmlHook\": () => (/* binding */ YXmlHook),\n/* harmony export */   \"XmlText\": () => (/* binding */ YXmlText),\n/* harmony export */   \"YArrayEvent\": () => (/* binding */ YArrayEvent),\n/* harmony export */   \"YEvent\": () => (/* binding */ YEvent),\n/* harmony export */   \"YMapEvent\": () => (/* binding */ YMapEvent),\n/* harmony export */   \"YTextEvent\": () => (/* binding */ YTextEvent),\n/* harmony export */   \"YXmlEvent\": () => (/* binding */ YXmlEvent),\n/* harmony export */   \"applyUpdate\": () => (/* binding */ applyUpdate),\n/* harmony export */   \"applyUpdateV2\": () => (/* binding */ applyUpdateV2),\n/* harmony export */   \"compareIDs\": () => (/* binding */ compareIDs),\n/* harmony export */   \"compareRelativePositions\": () => (/* binding */ compareRelativePositions),\n/* harmony export */   \"createAbsolutePositionFromRelativePosition\": () => (/* binding */ createAbsolutePositionFromRelativePosition),\n/* harmony export */   \"createDeleteSet\": () => (/* binding */ createDeleteSet),\n/* harmony export */   \"createDeleteSetFromStructStore\": () => (/* binding */ createDeleteSetFromStructStore),\n/* harmony export */   \"createDocFromSnapshot\": () => (/* binding */ createDocFromSnapshot),\n/* harmony export */   \"createID\": () => (/* binding */ createID),\n/* harmony export */   \"createRelativePositionFromJSON\": () => (/* binding */ createRelativePositionFromJSON),\n/* harmony export */   \"createRelativePositionFromTypeIndex\": () => (/* binding */ createRelativePositionFromTypeIndex),\n/* harmony export */   \"createSnapshot\": () => (/* binding */ createSnapshot),\n/* harmony export */   \"decodeRelativePosition\": () => (/* binding */ decodeRelativePosition),\n/* harmony export */   \"decodeSnapshot\": () => (/* binding */ decodeSnapshot),\n/* harmony export */   \"decodeSnapshotV2\": () => (/* binding */ decodeSnapshotV2),\n/* harmony export */   \"decodeStateVector\": () => (/* binding */ decodeStateVector),\n/* harmony export */   \"diffUpdate\": () => (/* binding */ diffUpdate),\n/* harmony export */   \"diffUpdateV2\": () => (/* binding */ diffUpdateV2),\n/* harmony export */   \"emptySnapshot\": () => (/* binding */ emptySnapshot),\n/* harmony export */   \"encodeRelativePosition\": () => (/* binding */ encodeRelativePosition),\n/* harmony export */   \"encodeSnapshot\": () => (/* binding */ encodeSnapshot),\n/* harmony export */   \"encodeSnapshotV2\": () => (/* binding */ encodeSnapshotV2),\n/* harmony export */   \"encodeStateAsUpdate\": () => (/* binding */ encodeStateAsUpdate),\n/* harmony export */   \"encodeStateAsUpdateV2\": () => (/* binding */ encodeStateAsUpdateV2),\n/* harmony export */   \"encodeStateVector\": () => (/* binding */ encodeStateVector),\n/* harmony export */   \"encodeStateVectorFromUpdate\": () => (/* binding */ encodeStateVectorFromUpdate),\n/* harmony export */   \"encodeStateVectorFromUpdateV2\": () => (/* binding */ encodeStateVectorFromUpdateV2),\n/* harmony export */   \"equalSnapshots\": () => (/* binding */ equalSnapshots),\n/* harmony export */   \"findRootTypeKey\": () => (/* binding */ findRootTypeKey),\n/* harmony export */   \"getItem\": () => (/* binding */ getItem),\n/* harmony export */   \"getState\": () => (/* binding */ getState),\n/* harmony export */   \"getTypeChildren\": () => (/* binding */ getTypeChildren),\n/* harmony export */   \"isDeleted\": () => (/* binding */ isDeleted),\n/* harmony export */   \"isParentOf\": () => (/* binding */ isParentOf),\n/* harmony export */   \"iterateDeletedStructs\": () => (/* binding */ iterateDeletedStructs),\n/* harmony export */   \"logType\": () => (/* binding */ logType),\n/* harmony export */   \"logUpdate\": () => (/* binding */ logUpdate),\n/* harmony export */   \"logUpdateV2\": () => (/* binding */ logUpdateV2),\n/* harmony export */   \"mergeUpdates\": () => (/* binding */ mergeUpdates),\n/* harmony export */   \"mergeUpdatesV2\": () => (/* binding */ mergeUpdatesV2),\n/* harmony export */   \"parseUpdateMeta\": () => (/* binding */ parseUpdateMeta),\n/* harmony export */   \"parseUpdateMetaV2\": () => (/* binding */ parseUpdateMetaV2),\n/* harmony export */   \"readUpdate\": () => (/* binding */ readUpdate),\n/* harmony export */   \"readUpdateV2\": () => (/* binding */ readUpdateV2),\n/* harmony export */   \"relativePositionToJSON\": () => (/* binding */ relativePositionToJSON),\n/* harmony export */   \"snapshot\": () => (/* binding */ snapshot),\n/* harmony export */   \"transact\": () => (/* binding */ transact),\n/* harmony export */   \"tryGc\": () => (/* binding */ tryGc),\n/* harmony export */   \"typeListToArraySnapshot\": () => (/* binding */ typeListToArraySnapshot),\n/* harmony export */   \"typeMapGetSnapshot\": () => (/* binding */ typeMapGetSnapshot)\n/* harmony export */ });\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable.js */ \"./node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/array.js */ \"./node_modules/lib0/array.js\");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/math.js */ \"./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding.js */ \"./node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding.js */ \"./node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_random_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/random.js */ \"./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_buffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/buffer.js */ \"./node_modules/lib0/buffer.js\");\n/* harmony import */ var lib0_error_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/error.js */ \"./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/binary.js */ \"./node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_function_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/function.js */ \"./node_modules/lib0/function.js\");\n/* harmony import */ var lib0_set_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/set.js */ \"./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/logging.js */ \"./node_modules/lib0/logging.js\");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/time.js */ \"./node_modules/lib0/time.js\");\n/* harmony import */ var lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/iterator.js */ \"./node_modules/lib0/iterator.js\");\n/* harmony import */ var lib0_object_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/object.js */ \"./node_modules/lib0/object.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */\nclass AbstractConnector extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n}\n\nclass DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock;\n    /**\n     * @type {number}\n     */\n    this.len = len;\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nclass DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map();\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i];\n      iterateStructs(transaction, structs, del.clock, del.len, f);\n    }\n  });\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nconst findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client);\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n};\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock);\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nconst mergeDeleteSets = dss => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.appendTo)(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nconst addToDeleteSet = (ds, client, clock, length) => {\n  (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(ds.clients, client, () => []).push(new DeleteItem(clock, length));\n};\n\nconst createDeleteSet = () => new DeleteSet();\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nconst createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.id.clock === clock + len && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst writeDeleteSet = (encoder, ds) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, ds.clients.size);\n  ds.clients.forEach((dsitems, client) => {\n    encoder.resetDsCurVal();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, client);\n    const len = dsitems.length;\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, len);\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i];\n      encoder.writeDsClock(item.clock);\n      encoder.writeDsLen(item.len);\n    }\n  });\n};\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nconst readDeleteSet = decoder => {\n  const ds = new DeleteSet();\n  const numClients = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const numberOfDeletes = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(ds.clients, client, () => []);\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds\n};\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nconst readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const numberOfDeletes = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index];\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++; // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(ds.restEncoder, 0); // encode 0 structs\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array()\n  }\n  return null\n};\n\n/**\n * @module Y\n */\n\nconst generateNewClientId = lib0_random_js__WEBPACK_IMPORTED_MODULE_6__.uint32;\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nclass Doc extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {DocOpts} [opts] configuration\n   */\n  constructor ({ guid = (0,lib0_random_js__WEBPACK_IMPORTED_MODULE_6__.uuidv4)(), gc = true, gcFilter = () => true, meta = null, autoLoad = false } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    /**\n     * @type {Map<string, AbstractType<YEvent>>}\n     */\n    this.share = new Map();\n    this.store = new StructStore();\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null;\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = [];\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set();\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null;\n    this.shouldLoad = autoLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this);\n      }, null, true);\n    }\n    this.shouldLoad = true;\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(Array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @param {function(Transaction):void} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    transact(this, f, origin);\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t;\n          }\n        });\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YMap<any>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {};\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON();\n    });\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.from)(this.subdocs).forEach(subdoc => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = /** @type {ContentDoc} */ (item.content);\n      if (item.deleted) {\n        // @ts-ignore\n        content.doc = null;\n      } else {\n        content.doc = new Doc({ guid: this.guid, ...content.opts });\n        content.doc._item = item;\n      }\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(content.doc);\n        }\n        transaction.subdocsRemoved.add(this);\n      }, null, true);\n    }\n    this.emit('destroyed', [true]);\n    this.emit('destroy', [this]);\n    super.destroy();\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f);\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f);\n  }\n}\n\nclass DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n}\n\nclass UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8)(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return (0,lib0_buffer_js__WEBPACK_IMPORTED_MODULE_7__.copyUint8Array)((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder)\n  }\n}\n\nclass DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder);\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff\n  }\n}\n\nclass UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder);\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = [];\n    (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder); // read feature flag - currently unused\n    this.keyClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.clientDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.leftClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.rightClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.infoDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.RleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder), lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.stringDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.StringDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.parentInfoDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.RleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder), lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.typeRefDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.lenDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key\n    }\n  }\n}\n\nclass DSEncoderV1 {\n  constructor () {\n    this.restEncoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n  }\n\n  toUint8Array () {\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, clock);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len);\n  }\n}\n\nclass UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.client);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.client);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.clock);\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(this.restEncoder, info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(this.restEncoder, buf);\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, JSON.stringify(embed));\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, key);\n  }\n}\n\nclass DSEncoderV2 {\n  constructor () {\n    this.restEncoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)(); // encodes all the rest / non-optimized\n    this.dsCurrVal = 0;\n  }\n\n  toUint8Array () {\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, diff);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n    }\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n}\n\nclass UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super();\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map();\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0;\n    this.keyClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.clientEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.leftClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.rightClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.infoEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.stringEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();\n    this.parentInfoEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.typeRefEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.lenEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n  }\n\n  toUint8Array () {\n    const encoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, 0); // this is a feature flag that we might use in the future\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.keyClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.clientEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.leftClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.rightClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.infoEncoder));\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.stringEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.parentInfoEncoder));\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.typeRefEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.lenEncoder.toUint8Array());\n    // @note The rest encoder is appended! (note the missing var)\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder));\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client);\n    this.leftClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client);\n    this.rightClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(this.restEncoder, buf);\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, embed);\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key);\n    if (clock === undefined) {\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(this.keyClock++);\n    }\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(clock, structs[0].id.clock); // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock);\n  // write # encoded structs\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nconst writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map();\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  // write # states that were updated\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, sm.size);\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  Array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock);\n  });\n};\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nconst readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.create)();\n  const numOfStateUpdates = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs });\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      switch (lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen();\n          refs[i] = new GC(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n          refs[i] = new Skip(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 | lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8)) === 0;\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          );\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n};\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = [];\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore();\n  const missingSV = new Map();\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];\n  // caching the state because it is used very often\n  const state = new Map();\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const unapplicableItems = clientsStructRefs.get(client);\n      if (unapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        unapplicableItems.i--;\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n        clientsStructRefs.delete(client);\n        unapplicableItems.i = 0;\n        unapplicableItems.refs = [];\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item]);\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client);\n    }\n    stack.length = 0;\n  };\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing));\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop());\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, new Map());\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nconst writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nconst readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    let retry = false;\n    const doc = transaction.doc;\n    const store = doc.store;\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc);\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss);\n    const pending = store.pendingStructs;\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true;\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client);\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock);\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n      }\n    } else {\n      store.pendingStructs = restStructs;\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(store.pendingDs));\n      (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2;\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest;\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;\n      store.pendingStructs = null;\n      applyUpdateV2(transaction.doc, update);\n    }\n  }, transactionOrigin, false);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nconst applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nconst writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  // also add the pending updates (if there are any)\n  // @todo support diffirent encoders\n  if (encoder.constructor === UpdateEncoderV2) {\n    if (doc.store.pendingDs) {\n      updates.push(doc.store.pendingDs);\n    }\n    if (doc.store.pendingStructs) {\n      updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n    }\n    if (updates.length > 1) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst readStateVector = decoder => {\n  const ss = new Map();\n  const ssLength = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss\n};\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVector = decodedState => readStateVector(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(decodedState)));\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nconst writeStateVector = (encoder, sv) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, sv.size);\n  sv.forEach((clock, client) => {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, clock);\n  });\n  return encoder\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nconst writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc);\n  } else {\n    writeDocumentStateVector(encoder, doc);\n  }\n  return encoder.toUint8Array()\n};\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1());\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nclass EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = [];\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nconst createEventHandler = () => new EventHandler();\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nconst addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f);\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nconst removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter(g => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.');\n  }\n};\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nconst callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  (0,lib0_function_js__WEBPACK_IMPORTED_MODULE_10__.callAll)(eventHandler.l, [arg0, arg1]);\n\nclass ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client;\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock;\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nconst createID = (client, clock) => new ID(client, clock);\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nconst writeID = (encoder, id) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, id.client);\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, id.clock);\n};\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nconst readID = decoder =>\n  createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder));\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nconst findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n};\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nconst isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item;\n  }\n  return false\n};\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nconst logType = type => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log('Children: ', res);\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));\n};\n\nclass PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map();\n    this.yusers = storeType;\n    this.doc = doc;\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map();\n    this.dss = dss;\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds');\n      const ids = user.get('ids');\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(encodedDs)))]));\n            }\n          });\n        });\n      });\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(encodedDs))))));\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    // add intial data\n    storeType.forEach(initUser);\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} [conf]\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set('ids', new YArray());\n      user.set('ds', new YArray());\n      users.set(userDescription, user);\n    }\n    user.get('ids').push([clientid]);\n    users.observe(event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite;\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get('ds').push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds');\n        const ds = transaction.deleteSet;\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1();\n          writeDeleteSet(encoder, ds);\n          yds.push([encoder.toUint8Array()]);\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nclass RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type;\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname;\n    /**\n     * @type {ID | null}\n     */\n    this.item = item;\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nconst relativePositionToJSON = rpos => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json\n};\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\n\nclass AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n    /**\n     * @type {number}\n     */\n    this.index = index;\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nconst createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nconst createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n};\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc)\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nconst writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(encoder, 1);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(encoder, tname);\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n  }\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarInt)(encoder, assoc);\n  return encoder\n};\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nconst encodeRelativePosition = rpos => {\n  const encoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n  writeRelativePosition(encoder, rpos);\n  return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(encoder)\n};\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nconst readRelativePosition = decoder => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch ((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder);\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(decoder);\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder);\n    }\n  }\n  const assoc = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.hasContent)(decoder) ? (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarInt)(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc)\n};\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nconst decodeRelativePosition = uint8Array => readRelativePosition((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(uint8Array));\n\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nconst createAbsolutePositionFromRelativePosition = (rpos, doc) => {\n  const store = doc.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent);\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n};\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n);\n\nclass Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds;\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv;\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nconst equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nconst encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds);\n  writeStateVector(encoder, snapshot.sv);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nconst encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1());\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nconst decodeSnapshotV2 = (buf, decoder = new DSDecoderV2((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n};\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nconst decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(buf)));\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nconst createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nconst snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nconst isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (\n  snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id)\n);\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nconst splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(transaction.meta, splitSnapshotAffectedStructs, lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create);\n  const store = transaction.doc.store;\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot.ds, item => {});\n    meta.add(snapshot);\n  }\n};\n\n/**\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nconst createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('originDoc must not be garbage collected')\n  }\n  const { sv, ds } = snapshot;\n\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact(transaction => {\n    let size = 0;\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, size);\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      // write # encoded structs\n      (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      // first clock written is 0\n      (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');\n  return newDoc\n};\n\nclass StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map();\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null;\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null;\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nconst getStateVector = store => {\n  const sm = new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm\n};\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nconst getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length\n};\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nconst addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === undefined) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n  }\n  structs.push(struct);\n};\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nconst findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((clock / (midclock + mid.length - 1)) * right); // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((left + right) / 2);\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nconst find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  return structs[findIndexSS(structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nconst getItem = /** @type {function(StructStore,ID):Item} */ (find);\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nconst findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1\n  }\n  return index\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  const index = findIndexSS(structs, id.clock);\n  const struct = structs[index];\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n  }\n  return struct\n};\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nconst replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client));\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n};\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nclass Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet();\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store);\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map();\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent>,Set<String|null>>}\n     */\n    this.changed = new Map();\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent>,Array<YEvent>>}\n     */\n    this.changedParentTypes = new Map();\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = [];\n    /**\n     * @type {any}\n     */\n    this.origin = origin;\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map();\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local;\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set();\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nconst writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !(0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.any)(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true\n};\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent>} type\n * @param {string|null} parentSub\n */\nconst addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(transaction.changed, type, lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create).add(parentSub);\n  }\n};\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1];\n  const right = structs[pos];\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1);\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.min)(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si);\n      }\n    }\n  });\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc._transaction = null;\n      doc.emit('beforeObserverCalls', [transaction, doc]);\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = [];\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                );\n              events\n                .forEach(event => {\n                  event.currentTarget = type;\n                });\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length);\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction);\n            }\n          })\n        );\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]));\n      });\n      (0,lib0_function_js__WEBPACK_IMPORTED_MODULE_10__.callAll)(fs, []);\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(findIndexSS(structs, beforeClock), 1);\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i);\n          }\n        }\n      });\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id;\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1);\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        doc.clientID = generateNewClientId();\n        (0,lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.print)(lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.ORANGE, lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.BOLD, '[yjs] ', lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.UNBOLD, lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.RED, 'Changed the client-id because another client seems to be using it.');\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc]);\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      transaction.subdocsAdded.forEach(subdoc => doc.subdocs.add(subdoc));\n      transaction.subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));\n\n      doc.emit('subdocs', [{ loaded: transaction.subdocsLoaded, added: transaction.subdocsAdded, removed: transaction.subdocsRemoved }]);\n      transaction.subdocsRemoved.forEach(subdoc => subdoc.destroy());\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = [];\n        doc.emit('afterAllTransactions', [doc, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @param {Doc} doc\n * @param {function(Transaction):void} f\n * @param {any} [origin=true]\n *\n * @function\n */\nconst transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups;\n  let initialCall = false;\n  if (doc._transaction === null) {\n    initialCall = true;\n    doc._transaction = new Transaction(doc, origin, local);\n    transactionCleanups.push(doc._transaction);\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc]);\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc]);\n  }\n  try {\n    f(doc._transaction);\n  } finally {\n    if (initialCall && transactionCleanups[0] === doc._transaction) {\n      // The first transaction ended, now process observer calls.\n      // Observer call may create new transactions for which we need to call the observers and do cleanup.\n      // We don't want to nest these calls, so we execute these calls one after\n      // another.\n      // Also we need to ensure that all cleanups are called, even if the\n      // observes throw errors.\n      // This file is full of hacky try {} finally {} blocks to ensure that an\n      // event can throw errors and also that the cleanup is called.\n      cleanupTransactions(transactionCleanups, 0);\n    }\n  }\n};\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map();\n  }\n}\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */\n  let result = null;\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null;\n  const doc = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc, transaction => {\n    while (stack.length > 0 && result === null) {\n      const store = doc.store;\n      const stackItem = /** @type {StackItem} */ (stack.pop());\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set();\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some(type => isParentOf(type, /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => isParentOf(type, struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)\n        ) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo) !== null || performedChange;\n      });\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);\n  }\n  return result\n};\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter whan an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'>}\n */\nclass UndoManager extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, { captureTimeout = 500, deleteFilter = () => true, trackedOrigins = new Set([null]) } = {}) {\n    super();\n    this.scope = typeScope instanceof Array ? typeScope : [typeScope];\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = [];\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = [];\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = /** @type {Doc} */ (this.scope[0].doc);\n    this.lastChange = 0;\n    this.doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      // Only track certain transactions\n      if (!this.scope.some(type => transaction.changedParentTypes.has(type)) || (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))) {\n        return\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing(); // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.redoStack = [];\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = (0,lib0_time_js__WEBPACK_IMPORTED_MODULE_13__.getUnixTime)();\n      if (now - this.lastChange < captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n          keepItem(item, true);\n        }\n      });\n      this.emit('stack-item-added', [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this]);\n    });\n  }\n\n  clear () {\n    this.doc.transact(transaction => {\n      /**\n       * @param {StackItem} stackItem\n       */\n      const clearItem = stackItem => {\n        iterateDeletedStructs(transaction, stackItem.deletions, item => {\n          if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n            keepItem(item, false);\n          }\n        });\n      };\n      this.undoStack.forEach(clearItem);\n      this.redoStack.forEach(clearItem);\n    });\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0;\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, 'undo');\n    } finally {\n      this.undoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, 'redo');\n    } finally {\n      this.redoing = false;\n    }\n    return res\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 | lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8)) === 0;\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\n\nclass LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst logUpdate = update => logUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  (0,lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.print)('Structs: ', structs);\n  const ds = readDeleteSet(updateDecoder);\n  (0,lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.print)('DeleteSet: ', ds);\n};\n\nclass LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = [];\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nconst mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update)), true);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 1;\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    let stopCounting = false;\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        size++;\n        // We found a new client\n        // write what we have to the encoder\n        (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClient);\n        (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClock);\n        currClient = curr.id.client;\n        stopCounting = false;\n      }\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n    }\n    // write what we have\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClient);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClock);\n    // prepend the size of the state vector\n    const enc = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(enc, size);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeBinaryEncoder)(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array()\n  } else {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, 0);\n    return encoder.toUint8Array()\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map();\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    // write the beginning to `from`\n    from.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock);\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock);\n        // update currClient\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    // write the end to `to`\n    to.set(currClient, currClock);\n  }\n  return { from, to }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1);\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left);\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n};\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nconst mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const updateDecoders = updates.map(update => new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update)));\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null;\n\n  const updateEncoder = new YEncoder();\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first ⇒ sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : (\n              dec1.curr.constructor === Skip ? 1 : -1\n            )\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0];\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr);\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n      }\n      if (curr === null || curr.id.client !== firstClient) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };\n      currDecoder.next();\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nconst diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next();\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  // write ds\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nconst diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n    lazyWriter.written = 0;\n  }\n};\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client);\n    // write startClock\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder;\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(restEncoder, lazyWriter.clientStructs.length);\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(restEncoder, partStructs.written);\n    // write the rest of the fragment\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array)(restEncoder, partStructs.restEncoder);\n  }\n};\n\n/**\n * YEvent describes the changes on a YType.\n */\nclass YEvent {\n  /**\n   * @param {AbstractType<any>} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {AbstractType<any>}\n     */\n    this.target = target;\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target;\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction;\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null;\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    this._keys = null;\n    /**\n     * @type {null | Array<{ insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null;\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      const keys = new Map();\n      const target = this.target;\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key));\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete';\n                oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(prev.content.getContent());\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update';\n                oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(prev.content.getContent());\n              } else {\n                action = 'add';\n                oldValue = undefined;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete';\n              oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(/** @type {Item} */ item.content.getContent());\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys;\n    }\n    return this._keys\n  }\n\n  /**\n   * @type {Array<{insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes;\n    if (changes === null) {\n      const target = this.target;\n      const added = (0,lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create)();\n      const deleted = (0,lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create)();\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub);\n    } else {\n      // parent is array-ish\n      let i = 0;\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start;\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent);\n  }\n  return path\n};\n\nconst maxSearchMarker = 80;\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0;\n\nclass ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm\n  }\n};\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nconst findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(index - a.index) < (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex);\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n};\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nconst updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p;\n      p.marker = false;\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1);\n        continue\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(index, m.index + len);\n    }\n  }\n};\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nconst getTypeChildren = t => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr\n};\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nconst callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    // @ts-ignore\n    (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent);\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nclass AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null;\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map();\n    /**\n     * @type {Item|null}\n     */\n    this._start = null;\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null;\n    this._length = 0;\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler();\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent>,Transaction>}\n     */\n    this._dEH = createEventHandler();\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null;\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArray = type => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArraySnapshot = (type, snapshot) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nconst typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nconst typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nconst typeListCreateIterator = type => {\n  let n = type._start;\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right; // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++];\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nconst typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length;\n    }\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const store = doc.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  /**\n   * @type {Array<Object|Array<any>|number>}\n   */\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach(c => {\n    switch (c.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        jsonContent.push(c);\n        break\n      default:\n        packJsonContent();\n        switch (c.constructor) {\n          case Uint8Array:\n          case ArrayBuffer:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));\n            left.integrate(transaction, 0);\n            break\n          case Doc:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));\n            left.integrate(transaction, 0);\n            break\n          default:\n            if (c instanceof AbstractType) {\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n              left.integrate(transaction, 0);\n            } else {\n              throw new Error('Unexpected content type in insert operation')\n            }\n        }\n    }\n  });\n  packJsonContent();\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nconst typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index;\n  const startLength = length;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n      }\n      n.delete(transaction);\n      length -= n.length;\n    }\n    n = n.right;\n  }\n  if (length > 0) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.create)('array length exceeded')\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nconst typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== undefined) {\n    c.delete(transaction);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nconst typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value));\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value));\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n};\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nconst createMapIterator = map => (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorFilter)(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted);\n\n/**\n * @module YArray\n */\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n */\nclass YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YArray extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    const a = new YArray();\n    a.push(items);\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    const arr = new YArray();\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? el.clone() : el\n    ));\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template T,M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function on once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYArray = decoder => new YArray();\n\n/**\n * @template T\n * Event that describes the changes on a YMap.\n */\nclass YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n}\n\n/**\n * @template T number|string|Object|Array|Uint8Array\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super();\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null;\n\n    if (entries === undefined) {\n      this._prelimContent = new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<T>}\n   */\n  clone () {\n    const map = new YMap();\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? value.clone() : value);\n    });\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,T>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(T,string,YMap<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n    return map\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {T} value The value of the element to add\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, value);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {T|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYMap = decoder => new YMap();\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && (0,lib0_object_js__WEBPACK_IMPORTED_MODULE_15__.equalFlat)(a, b));\n\nclass ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n    }\n    switch (this.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));\n        }\n        break\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));\n        }\n        break\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index)\n  }\n};\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);\n    }\n    currPos.forward();\n  }\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let nextFormat = currPos.left;\n  const right = currPos.right;\n  negatedAttributes.forEach((val, key) => {\n    nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), nextFormat, nextFormat && nextFormat.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n  });\n};\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {\n      break\n    }\n    currPos.forward();\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const negatedAttributes = new Map();\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null;\n    }\n  });\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : new ContentEmbed(text);\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);\n          const attr = attributes[key];\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key);\n            } else {\n              negatedAttributes.set(key, value);\n            }\n            currPos.right.delete(transaction);\n          }\n          break\n        }\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          break\n      }\n    }\n    currPos.forward();\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = '';\n    for (; length > 0; length--) {\n      newlines += '\\n';\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} end exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} endAttributes This attribute is modified!\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, end, startAttributes, endAttributes) => {\n  while (end && end.content.constructor !== ContentString && end.content.constructor !== ContentEmbed) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      updateCurrentAttributes(endAttributes, /** @type {ContentFormat} */ (end.content));\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  while (start !== end) {\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content);\n          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction);\n            cleanups++;\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right);\n  }\n  return cleanups\n};\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || (item.right.content.constructor !== ContentString && item.right.content.constructor !== ContentEmbed))) {\n    item = item.right;\n  }\n  const attrs = new Set();\n  // iterate back until a content item is found\n  while (item && (item.deleted || (item.content.constructor !== ContentString && item.content.constructor !== ContentEmbed))) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key;\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nconst cleanupYTextFormatting = type => {\n  let res = 0;\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start);\n    let end = type._start;\n    let startAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.create)();\n    const currentAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(startAttributes);\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));\n            break\n          case ContentEmbed:\n          case ContentString:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n            startAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currentAttributes);\n            start = end;\n            break\n        }\n      }\n      end = end.right;\n    }\n  });\n  return res\n};\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length;\n  const startAttrs = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currPos.currentAttributes));\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n  }\n  return currPos\n};\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * Event that describes the changes on a YText type.\n */\nclass YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      };\n      this._changes = changes;\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc);\n      /**\n       * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = [];\n      transact(y, transaction => {\n        const currentAttributes = new Map(); // saves all current attributes for insert\n        const oldAttributes = new Map();\n        let item = this.target._start;\n        /**\n         * @type {string?}\n         */\n        let action = null;\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}; // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = '';\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op;\n            switch (action) {\n              case 'delete':\n                op = { delete: deleteLen };\n                deleteLen = 0;\n                break\n              case 'insert':\n                op = { insert };\n                if (currentAttributes.size > 0) {\n                  op.attributes = {};\n                  currentAttributes.forEach((value, key) => {\n                    if (value !== null) {\n                      op.attributes[key] = value;\n                    }\n                  });\n                }\n                insert = '';\n                break\n              case 'retain':\n                op = { retain };\n                if (Object.keys(attributes).length > 0) {\n                  op.attributes = {};\n                  for (const key in attributes) {\n                    op.attributes[key] = attributes[key];\n                  }\n                }\n                retain = 0;\n                break\n            }\n            delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = 'insert';\n                  insert = /** @type {ContentEmbed} */ (item.content).embed;\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += 1;\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp();\n                    action = 'insert';\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += item.length;\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content);\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (value === null) {\n                      attributes[key] = value;\n                    } else {\n                      delete attributes[key];\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp();\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));\n              }\n              break\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop();\n          } else {\n            break\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nclass YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super();\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    const doc = transaction.doc;\n    callTypeObservers(this, transaction, event);\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false;\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this);\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = '';\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str;\n      }\n      n = n.right;\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  [opts]\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta));\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = [];\n    const currentAttributes = new Map();\n    const doc = /** @type {Doc} */ (this.doc);\n    let str = '';\n    let n = this._start;\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = '';\n      }\n    }\n    // snapshots are merged again after the transaction, so we need to keep the\n    // transalive until we are done\n    transact(doc, transaction => {\n      if (snapshot) {\n        splitSnapshotAffectedStructs(transaction, snapshot);\n      }\n      if (prevSnapshot) {\n        splitSnapshotAffectedStructs(transaction, prevSnapshot);\n      }\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange');\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'removed') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'added') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });\n                }\n              } else if (cur !== undefined) {\n                packStr();\n                currentAttributes.delete('ychange');\n              }\n              str += /** @type {ContentString} */ (n.content).str;\n              break\n            }\n            case ContentEmbed: {\n              packStr();\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: /** @type {ContentEmbed} */ (n.content).embed\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({});\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr();\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));\n              }\n              break\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    }, splitSnapshotAffectedStructs);\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });\n        }\n        insertText(transaction, this, pos, text, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    if (embed.constructor !== Object) {\n      throw new Error('Embed must be an Object')\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nconst readYText = decoder => new YText();\n\n/**\n * @module YXml\n */\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nclass YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start);\n    this._firstCall = true;\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */ (n.content).type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start;\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false;\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n;\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nclass YXmlFragment extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = [];\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment();\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent);\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.create)('Reference item not found')\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length);\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nconst readYXmlFragment = decoder => new YXmlFragment();\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n */\nclass YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super();\n    this.nodeName = nodeName;\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map();\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement}\n   */\n  clone () {\n    const el = new YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      el.setAttribute(key, attrs[key]);\n    }\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys = [];\n    for (const key in attrs) {\n      keys.push(key);\n    }\n    keys.sort();\n    const keysLen = keys.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {String} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {String} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      dom.setAttribute(key, attrs[key]);\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nconst readYXmlElement = decoder => new YXmlElement(decoder.readKey());\n\n/**\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nclass YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n}\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nclass YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super();\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== undefined) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName);\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nconst readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey());\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nclass YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      // now convert to dom string\n      let str = '';\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += '>';\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nconst readYXmlText = decoder => new YXmlText();\n\nclass AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id;\n    this.length = length;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n}\n\nconst structGCRefNumber = 0;\n\n/**\n * @private\n */\nclass GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nclass ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nconst readContentBinary = decoder => new ContentBinary(decoder.readBuf());\n\nclass ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nconst readContentDeleted = decoder => new ContentDeleted(decoder.readLen());\n\n/**\n * @private\n */\nclass ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * @type {any}\n     */\n    const opts = {};\n    this.opts = opts;\n    if (!doc.gc) {\n      opts.gc = false;\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta;\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(this.doc)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nconst readContentDoc = decoder => new ContentDoc(new Doc({ guid: decoder.readString(), ...decoder.readAny() }));\n\n/**\n * @private\n */\nclass ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nconst readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null;\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nconst readContentFormat = decoder => new ContentFormat(decoder.readString(), decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nconst readContentJSON = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === 'undefined') {\n      cs.push(undefined);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs)\n};\n\nclass ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nconst readContentAny = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs)\n};\n\n/**\n * @private\n */\nclass ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character (� / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '�';\n      // replace right as well\n      right.str = '�' + right.str.slice(1);\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nconst readContentString = decoder => new ContentString(decoder.readString());\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nconst typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\n\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n\n/**\n * @private\n */\nclass ContentType {\n  /**\n   * @param {AbstractType<YEvent>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // Whis will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.left;\n      }\n    });\n    this.type._map = new Map();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nconst readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nconst followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n};\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nconst keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */ (item.parent)._item;\n  }\n};\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nconst splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem;\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem);\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem\n};\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n *\n * @return {Item|null}\n *\n * @private\n */\nconst redoItem = (transaction, item, redoitems) => {\n  const doc = transaction.doc;\n  const store = doc.store;\n  const ownClientID = doc.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;\n  /**\n   * @type {Item|null}\n   */\n  let left;\n  /**\n   * @type {Item|null}\n   */\n  let right;\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left;\n    right = item;\n  } else {\n    // Is a map item. Insert as current value\n    left = item;\n    while (left.right !== null) {\n      left = left.right;\n      if (left.id.client !== ownClientID) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    }\n    if (left.right !== null) {\n      left = /** @type {Item} */ (/** @type {AbstractType<any>} */ (item.parent)._map.get(item.parentSub));\n    }\n    right = null;\n  }\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {\n    // try to undo parent if it will be undone anyway\n    if (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems) === null) {\n      return null\n    }\n  }\n  if (parentItem !== null && parentItem.redone !== null) {\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left;\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace;\n        break\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right;\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace;\n        break\n      }\n      right = right.right;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem\n};\n\n/**\n * Abstract class that represents any content.\n */\nclass Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength());\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin;\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left;\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right;\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin;\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent;\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub;\n    /**\n     * If this type's effect is reundone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null;\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content;\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT2 : 0;\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4) > 0) !== isMarked) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4;\n    }\n  }\n\n  get marker () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT1;\n    }\n  }\n\n  get countable () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3;\n    }\n  }\n\n  markDeleted () {\n    this.info |= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3;\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null;\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type;\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left;\n\n        /**\n         * @type {Item|null}\n         */\n        let o;\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start;\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set();\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set();\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction);\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub);\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction);\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = (this.content.getRef() & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5) |\n      (origin === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6); // parentSub is non-null\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      if (parent._item !== undefined) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true); // write parentYKey\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false); // write parent id\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true); // write parentYKey\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false); // write parent id\n        encoder.writeLeftID(parent);\n      } else {\n        (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nconst readItemContent = (decoder, info) => contentRefs[info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5](decoder);\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nconst contentRefs = [\n  () => { (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)(); }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)(); } // 10 - Skip is not ItemContent\n];\n\nconst structSkipRefNumber = 10;\n\n/**\n * @private\n */\nclass Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\n\n//# sourceMappingURL=yjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jYWxjdWxhdGlvbi8uL25vZGVfbW9kdWxlcy95anMvZGlzdC95anMubWpzPzc0MjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDSztBQUNEO0FBQ1k7QUFDNkw7QUFDN0M7QUFDaEs7QUFDQTtBQUN3QztBQUNQO0FBQ3RDO0FBQ007QUFDa0I7QUFDeEI7QUFDb0I7QUFDcEI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQywwREFBVTtBQUMxQztBQUNBLGFBQWEsSUFBSTtBQUNqQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QyxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURB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Q0EsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsOERBQThELGlEQUFLOztBQUVuRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsQ0FBQyw2REFBYyxHQUFHLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxDQUFDLDZEQUFjLEdBQUcsRUFBRTtBQUM3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBYztBQUNsQjs7QUFFQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksOERBQVk7QUFDaEI7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxZQUFZO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4MUM7QUFDOTFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5tanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlLmpzJztcbmltcG9ydCB7IGFwcGVuZFRvLCBmcm9tLCBsYXN0IH0gZnJvbSAnbGliMC9hcnJheS5qcyc7XG5pbXBvcnQgeyBmbG9vciwgbWF4LCBtaW4sIGFicyB9IGZyb20gJ2xpYjAvbWF0aC5qcyc7XG5pbXBvcnQgeyBzZXRJZlVuZGVmaW5lZCwgY3JlYXRlLCBhbnksIGNvcHkgfSBmcm9tICdsaWIwL21hcC5qcyc7XG5pbXBvcnQgeyB3cml0ZVZhclVpbnQsIGNyZWF0ZUVuY29kZXIsIHRvVWludDhBcnJheSwgd3JpdGVVaW50OCwgd3JpdGVWYXJTdHJpbmcsIHdyaXRlQW55LCB3cml0ZVZhclVpbnQ4QXJyYXksIEludERpZmZPcHRSbGVFbmNvZGVyLCBVaW50T3B0UmxlRW5jb2RlciwgUmxlRW5jb2RlciwgU3RyaW5nRW5jb2Rlciwgd3JpdGVVaW50OEFycmF5LCB3cml0ZVZhckludCwgd3JpdGVCaW5hcnlFbmNvZGVyIH0gZnJvbSAnbGliMC9lbmNvZGluZy5qcyc7XG5pbXBvcnQgeyByZWFkVmFyVWludCwgcmVhZFVpbnQ4LCByZWFkVmFyU3RyaW5nLCByZWFkQW55LCByZWFkVmFyVWludDhBcnJheSwgSW50RGlmZk9wdFJsZURlY29kZXIsIFVpbnRPcHRSbGVEZWNvZGVyLCBSbGVEZWNvZGVyLCBTdHJpbmdEZWNvZGVyLCBjcmVhdGVEZWNvZGVyLCBoYXNDb250ZW50LCByZWFkVmFySW50IH0gZnJvbSAnbGliMC9kZWNvZGluZy5qcyc7XG5pbXBvcnQgeyB1dWlkdjQsIHVpbnQzMiB9IGZyb20gJ2xpYjAvcmFuZG9tLmpzJztcbmltcG9ydCB7IGNvcHlVaW50OEFycmF5IH0gZnJvbSAnbGliMC9idWZmZXIuanMnO1xuaW1wb3J0IHsgdW5leHBlY3RlZENhc2UsIG1ldGhvZFVuaW1wbGVtZW50ZWQsIGNyZWF0ZSBhcyBjcmVhdGUkMiB9IGZyb20gJ2xpYjAvZXJyb3IuanMnO1xuaW1wb3J0IHsgQklUUzUsIEJJVDgsIEJJVDcsIEJJVDYsIEJJVDIsIEJJVDQsIEJJVDEsIEJJVDMgfSBmcm9tICdsaWIwL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyBjYWxsQWxsIH0gZnJvbSAnbGliMC9mdW5jdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGUgYXMgY3JlYXRlJDEgfSBmcm9tICdsaWIwL3NldC5qcyc7XG5pbXBvcnQgeyBwcmludCwgT1JBTkdFLCBCT0xELCBVTkJPTEQsIFJFRCB9IGZyb20gJ2xpYjAvbG9nZ2luZy5qcyc7XG5pbXBvcnQgeyBnZXRVbml4VGltZSB9IGZyb20gJ2xpYjAvdGltZS5qcyc7XG5pbXBvcnQgeyBpdGVyYXRvckZpbHRlciwgaXRlcmF0b3JNYXAgfSBmcm9tICdsaWIwL2l0ZXJhdG9yLmpzJztcbmltcG9ydCB7IGVxdWFsRmxhdCB9IGZyb20gJ2xpYjAvb2JqZWN0LmpzJztcblxuLyoqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSB0aGF0IGFsbCBDb25uZWN0b3JzIHNob3VsZCBpbXBsZW1lbnQgdG8ga2VlcCB0aGVtIGludGVyY2hhbmdlYWJsZS5cbiAqXG4gKiBAbm90ZSBUaGlzIGludGVyZmFjZSBpcyBleHBlcmltZW50YWwgYW5kIGl0IGlzIG5vdCBhZHZpc2VkIHRvIGFjdHVhbGx5IGluaGVyaXQgdGhpcyBjbGFzcy5cbiAqICAgICAgIEl0IGp1c3Qgc2VydmVzIGFzIHR5cGluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxhbnk+fVxuICovXG5jbGFzcyBBYnN0cmFjdENvbm5lY3RvciBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IHlkb2NcbiAgICogQHBhcmFtIHthbnl9IGF3YXJlbmVzc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHlkb2MsIGF3YXJlbmVzcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2MgPSB5ZG9jO1xuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzO1xuICB9XG59XG5cbmNsYXNzIERlbGV0ZUl0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbG9jaywgbGVuKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5vIGxvbmdlciBtYWludGFpbiBhIERlbGV0ZVN0b3JlLiBEZWxldGVTZXQgaXMgYSB0ZW1wb3Jhcnkgb2JqZWN0IHRoYXQgaXMgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqIC0gV2hlbiBjcmVhdGVkIGluIGEgdHJhbnNhY3Rpb24sIGl0IG11c3Qgb25seSBiZSBhY2Nlc3NlZCBhZnRlciBzb3J0aW5nLCBhbmQgbWVyZ2luZ1xuICogICAtIFRoaXMgRGVsZXRlU2V0IGlzIHNlbmQgdG8gb3RoZXIgY2xpZW50c1xuICogLSBXZSBkbyBub3QgY3JlYXRlIGEgRGVsZXRlU2V0IHdoZW4gd2Ugc2VuZCBhIHN5bmMgbWVzc2FnZS4gVGhlIERlbGV0ZVNldCBtZXNzYWdlIGlzIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBTdHJ1Y3RTdG9yZVxuICogLSBXZSByZWFkIGEgRGVsZXRlU2V0IGFzIHBhcnQgb2YgYSBzeW5jL3VwZGF0ZSBtZXNzYWdlLiBJbiB0aGlzIGNhc2UgdGhlIERlbGV0ZVNldCBpcyBhbHJlYWR5IHNvcnRlZCBhbmQgbWVyZ2VkLlxuICovXG5jbGFzcyBEZWxldGVTZXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8RGVsZXRlSXRlbT4+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0cyB0aGF0IHRoZSBEZWxldGVTZXQgZ2Mncy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBkcywgZikgPT5cbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkZWxldGVzLCBjbGllbnRpZCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAodHJhbnNhY3Rpb24uZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudGlkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWwgPSBkZWxldGVzW2ldO1xuICAgICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIHN0cnVjdHMsIGRlbC5jbG9jaywgZGVsLmxlbiwgZik7XG4gICAgfVxuICB9KTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PERlbGV0ZUl0ZW0+fSBkaXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kSW5kZXhEUyA9IChkaXMsIGNsb2NrKSA9PiB7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gZGlzLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgY29uc3QgbWlkaW5kZXggPSBmbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICAgIGNvbnN0IG1pZCA9IGRpc1ttaWRpbmRleF07XG4gICAgY29uc3QgbWlkY2xvY2sgPSBtaWQuY2xvY2s7XG4gICAgaWYgKG1pZGNsb2NrIDw9IGNsb2NrKSB7XG4gICAgICBpZiAoY2xvY2sgPCBtaWRjbG9jayArIG1pZC5sZW4pIHtcbiAgICAgICAgcmV0dXJuIG1pZGluZGV4XG4gICAgICB9XG4gICAgICBsZWZ0ID0gbWlkaW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IG1pZGluZGV4IC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzRGVsZXRlZCA9IChkcywgaWQpID0+IHtcbiAgY29uc3QgZGlzID0gZHMuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgcmV0dXJuIGRpcyAhPT0gdW5kZWZpbmVkICYmIGZpbmRJbmRleERTKGRpcywgaWQuY2xvY2spICE9PSBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgc29ydEFuZE1lcmdlRGVsZXRlU2V0ID0gZHMgPT4ge1xuICBkcy5jbGllbnRzLmZvckVhY2goZGVscyA9PiB7XG4gICAgZGVscy5zb3J0KChhLCBiKSA9PiBhLmNsb2NrIC0gYi5jbG9jayk7XG4gICAgLy8gbWVyZ2UgaXRlbXMgd2l0aG91dCBmaWx0ZXJpbmcgb3Igc3BsaWNpbmcgdGhlIGFycmF5XG4gICAgLy8gaSBpcyB0aGUgY3VycmVudCBwb2ludGVyXG4gICAgLy8gaiByZWZlcnMgdG8gdGhlIGN1cnJlbnQgaW5zZXJ0IHBvc2l0aW9uIGZvciB0aGUgcG9pbnRlZCBpdGVtXG4gICAgLy8gdHJ5IHRvIG1lcmdlIGRlbHNbaV0gaW50byBkZWxzW2otMV0gb3Igc2V0IGRlbHNbal09ZGVsc1tpXVxuICAgIGxldCBpLCBqO1xuICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGVmdCA9IGRlbHNbaiAtIDFdO1xuICAgICAgY29uc3QgcmlnaHQgPSBkZWxzW2ldO1xuICAgICAgaWYgKGxlZnQuY2xvY2sgKyBsZWZ0LmxlbiA+PSByaWdodC5jbG9jaykge1xuICAgICAgICBsZWZ0LmxlbiA9IG1heChsZWZ0LmxlbiwgcmlnaHQuY2xvY2sgKyByaWdodC5sZW4gLSBsZWZ0LmNsb2NrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChqIDwgaSkge1xuICAgICAgICAgIGRlbHNbal0gPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbHMubGVuZ3RoID0gajtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RGVsZXRlU2V0Pn0gZHNzXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9IEEgZnJlc2ggRGVsZXRlU2V0XG4gKi9cbmNvbnN0IG1lcmdlRGVsZXRlU2V0cyA9IGRzcyA9PiB7XG4gIGNvbnN0IG1lcmdlZCA9IG5ldyBEZWxldGVTZXQoKTtcbiAgZm9yIChsZXQgZHNzSSA9IDA7IGRzc0kgPCBkc3MubGVuZ3RoOyBkc3NJKyspIHtcbiAgICBkc3NbZHNzSV0uY2xpZW50cy5mb3JFYWNoKChkZWxzTGVmdCwgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoIW1lcmdlZC5jbGllbnRzLmhhcyhjbGllbnQpKSB7XG4gICAgICAgIC8vIFdyaXRlIGFsbCBtaXNzaW5nIGtleXMgZnJvbSBjdXJyZW50IGRzIGFuZCBhbGwgZm9sbG93aW5nLlxuICAgICAgICAvLyBJZiBtZXJnZWQgYWxyZWFkeSBjb250YWlucyBgY2xpZW50YCBjdXJyZW50IGRzIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWxzID0gZGVsc0xlZnQuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGRzc0kgKyAxOyBpIDwgZHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXBwZW5kVG8oZGVscywgZHNzW2ldLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW10pO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlZC5jbGllbnRzLnNldChjbGllbnQsIGRlbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNvcnRBbmRNZXJnZURlbGV0ZVNldChtZXJnZWQpO1xuICByZXR1cm4gbWVyZ2VkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhZGRUb0RlbGV0ZVNldCA9IChkcywgY2xpZW50LCBjbG9jaywgbGVuZ3RoKSA9PiB7XG4gIHNldElmVW5kZWZpbmVkKGRzLmNsaWVudHMsIGNsaWVudCwgKCkgPT4gW10pLnB1c2gobmV3IERlbGV0ZUl0ZW0oY2xvY2ssIGxlbmd0aCkpO1xufTtcblxuY29uc3QgY3JlYXRlRGVsZXRlU2V0ID0gKCkgPT4gbmV3IERlbGV0ZVNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHNzXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9IE1lcmdlZCBhbmQgc29ydGVkIERlbGV0ZVNldFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlID0gc3MgPT4ge1xuICBjb25zdCBkcyA9IGNyZWF0ZURlbGV0ZVNldCgpO1xuICBzcy5jbGllbnRzLmZvckVhY2goKHN0cnVjdHMsIGNsaWVudCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn1cbiAgICAgKi9cbiAgICBjb25zdCBkc2l0ZW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2ldO1xuICAgICAgaWYgKHN0cnVjdC5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gc3RydWN0LmlkLmNsb2NrO1xuICAgICAgICBsZXQgbGVuID0gc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGkgKyAxIDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBuZXh0ID0gc3RydWN0c1tpICsgMV07IGkgKyAxIDwgc3RydWN0cy5sZW5ndGggJiYgbmV4dC5pZC5jbG9jayA9PT0gY2xvY2sgKyBsZW4gJiYgbmV4dC5kZWxldGVkOyBuZXh0ID0gc3RydWN0c1srK2kgKyAxXSkge1xuICAgICAgICAgICAgbGVuICs9IG5leHQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkc2l0ZW1zLnB1c2gobmV3IERlbGV0ZUl0ZW0oY2xvY2ssIGxlbikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZHNpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBkcy5jbGllbnRzLnNldChjbGllbnQsIGRzaXRlbXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVEZWxldGVTZXQgPSAoZW5jb2RlciwgZHMpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGRzLmNsaWVudHMuc2l6ZSk7XG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZHNpdGVtcywgY2xpZW50KSA9PiB7XG4gICAgZW5jb2Rlci5yZXNldERzQ3VyVmFsKCk7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsaWVudCk7XG4gICAgY29uc3QgbGVuID0gZHNpdGVtcy5sZW5ndGg7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRzaXRlbXNbaV07XG4gICAgICBlbmNvZGVyLndyaXRlRHNDbG9jayhpdGVtLmNsb2NrKTtcbiAgICAgIGVuY29kZXIud3JpdGVEc0xlbihpdGVtLmxlbik7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkRGVsZXRlU2V0ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGRzID0gbmV3IERlbGV0ZVNldCgpO1xuICBjb25zdCBudW1DbGllbnRzID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2xpZW50czsgaSsrKSB7XG4gICAgZGVjb2Rlci5yZXNldERzQ3VyVmFsKCk7XG4gICAgY29uc3QgY2xpZW50ID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgbnVtYmVyT2ZEZWxldGVzID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgaWYgKG51bWJlck9mRGVsZXRlcyA+IDApIHtcbiAgICAgIGNvbnN0IGRzRmllbGQgPSBzZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IFtdKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgICAgZHNGaWVsZC5wdXNoKG5ldyBEZWxldGVJdGVtKGRlY29kZXIucmVhZERzQ2xvY2soKSwgZGVjb2Rlci5yZWFkRHNMZW4oKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZHNcbn07XG5cbi8qKlxuICogQHRvZG8gWURlY29kZXIgYWxzbyBjb250YWlucyByZWZlcmVuY2VzIHRvIFN0cmluZyBhbmQgb3RoZXIgRGVjb2RlcnMuIFdvdWxkIG1ha2Ugc2Vuc2UgdG8gZXhjaGFuZ2UgWURlY29kZXIudG9VaW50OEFycmF5IGZvciBZRGVjb2Rlci5Ec1RvVWludDhBcnJheSgpLi5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fG51bGx9IFJldHVybnMgYSB2MiB1cGRhdGUgY29udGFpbmluZyBhbGwgZGVsZXRlcyB0aGF0IGNvdWxkbid0IGJlIGFwcGxpZWQgeWV0OyBvciBudWxsIGlmIGFsbCBkZWxldGVzIHdlcmUgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkQW5kQXBwbHlEZWxldGVTZXQgPSAoZGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKSA9PiB7XG4gIGNvbnN0IHVuYXBwbGllZERTID0gbmV3IERlbGV0ZVNldCgpO1xuICBjb25zdCBudW1DbGllbnRzID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2xpZW50czsgaSsrKSB7XG4gICAgZGVjb2Rlci5yZXNldERzQ3VyVmFsKCk7XG4gICAgY29uc3QgY2xpZW50ID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgbnVtYmVyT2ZEZWxldGVzID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVsZXRlczsgaSsrKSB7XG4gICAgICBjb25zdCBjbG9jayA9IGRlY29kZXIucmVhZERzQ2xvY2soKTtcbiAgICAgIGNvbnN0IGNsb2NrRW5kID0gY2xvY2sgKyBkZWNvZGVyLnJlYWREc0xlbigpO1xuICAgICAgaWYgKGNsb2NrIDwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICBhZGRUb0RlbGV0ZVNldCh1bmFwcGxpZWREUywgY2xpZW50LCBzdGF0ZSwgY2xvY2tFbmQgLSBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgY2FuIGlnbm9yZSB0aGUgY2FzZSBvZiBHQyBhbmQgRGVsZXRlIHN0cnVjdHMsIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIHNraXAgdGhlbVxuICAgICAgICAgKiBAdHlwZSB7SXRlbX1cbiAgICAgICAgICovXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICAgICAgICAvLyBzcGxpdCB0aGUgZmlyc3QgaXRlbSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9jaykge1xuICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgICAgICAgaW5kZXgrKzsgLy8gaW5jcmVhc2Ugd2Ugbm93IHdhbnQgdG8gdXNlIHRoZSBuZXh0IHN0cnVjdFxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHN0cnVjdCA9IHN0cnVjdHNbaW5kZXgrK107XG4gICAgICAgICAgaWYgKHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrRW5kKSB7XG4gICAgICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGlmIChjbG9ja0VuZCA8IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrRW5kIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RydWN0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRUb0RlbGV0ZVNldCh1bmFwcGxpZWREUywgY2xpZW50LCBjbG9jaywgY2xvY2tFbmQgLSBjbG9jayk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh1bmFwcGxpZWREUy5jbGllbnRzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZHMgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gICAgd3JpdGVWYXJVaW50KGRzLnJlc3RFbmNvZGVyLCAwKTsgLy8gZW5jb2RlIDAgc3RydWN0c1xuICAgIHdyaXRlRGVsZXRlU2V0KGRzLCB1bmFwcGxpZWREUyk7XG4gICAgcmV0dXJuIGRzLnRvVWludDhBcnJheSgpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQG1vZHVsZSBZXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVOZXdDbGllbnRJZCA9IHVpbnQzMjtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb2NPcHRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmdjPXRydWVdIERpc2FibGUgZ2FyYmFnZSBjb2xsZWN0aW9uIChkZWZhdWx0OiBnYz10cnVlKVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbRG9jT3B0cy5nY0ZpbHRlcl0gV2lsbCBiZSBjYWxsZWQgYmVmb3JlIGFuIEl0ZW0gaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuIFJldHVybiBmYWxzZSB0byBrZWVwIHRoZSBJdGVtLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtEb2NPcHRzLmd1aWRdIERlZmluZSBhIGdsb2JhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGRvY3VtZW50XG4gKiBAcHJvcGVydHkge2FueX0gW0RvY09wdHMubWV0YV0gQW55IGtpbmQgb2YgbWV0YSBpbmZvcm1hdGlvbiB5b3Ugd2FudCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRvY3VtZW50LiBJZiB0aGlzIGlzIGEgc3ViZG9jdW1lbnQsIHJlbW90ZSBwZWVycyB3aWxsIHN0b3JlIHRoZSBtZXRhIGluZm9ybWF0aW9uIGFzIHdlbGwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmF1dG9Mb2FkXSBJZiBhIHN1YmRvY3VtZW50LCBhdXRvbWF0aWNhbGx5IGxvYWQgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgbG9hZCB0aGUgZG9jdW1lbnQgYXMgd2VsbCBhdXRvbWF0aWNhbGx5LlxuICovXG5cbi8qKlxuICogQSBZanMgaW5zdGFuY2UgaGFuZGxlcyB0aGUgc3RhdGUgb2Ygc2hhcmVkIGRhdGEuXG4gKiBAZXh0ZW5kcyBPYnNlcnZhYmxlPHN0cmluZz5cbiAqL1xuY2xhc3MgRG9jIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY09wdHN9IFtvcHRzXSBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeyBndWlkID0gdXVpZHY0KCksIGdjID0gdHJ1ZSwgZ2NGaWx0ZXIgPSAoKSA9PiB0cnVlLCBtZXRhID0gbnVsbCwgYXV0b0xvYWQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2MgPSBnYztcbiAgICB0aGlzLmdjRmlsdGVyID0gZ2NGaWx0ZXI7XG4gICAgdGhpcy5jbGllbnRJRCA9IGdlbmVyYXRlTmV3Q2xpZW50SWQoKTtcbiAgICB0aGlzLmd1aWQgPSBndWlkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBBYnN0cmFjdFR5cGU8WUV2ZW50Pj59XG4gICAgICovXG4gICAgdGhpcy5zaGFyZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IFN0cnVjdFN0b3JlKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9uIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl90cmFuc2FjdGlvbkNsZWFudXBzID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jcyA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGRvY3VtZW50IGlzIGEgc3ViZG9jdW1lbnQgLSBhIGRvY3VtZW50IGludGVncmF0ZWQgaW50byBhbm90aGVyIGRvY3VtZW50IC0gdGhlbiBfaXRlbSBpcyBkZWZpbmVkLlxuICAgICAqIEB0eXBlIHtJdGVtP31cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICB0aGlzLnNob3VsZExvYWQgPSBhdXRvTG9hZDtcbiAgICB0aGlzLmF1dG9Mb2FkID0gYXV0b0xvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIHBhcmVudCBkb2N1bWVudCB0aGF0IHlvdSByZXF1ZXN0IHRvIGxvYWQgZGF0YSBpbnRvIHRoaXMgc3ViZG9jdW1lbnQgKGlmIGl0IGlzIGEgc3ViZG9jdW1lbnQpLlxuICAgKlxuICAgKiBgbG9hZCgpYCBtaWdodCBiZSB1c2VkIGluIHRoZSBmdXR1cmUgdG8gcmVxdWVzdCBhbnkgcHJvdmlkZXIgdG8gbG9hZCB0aGUgbW9zdCBjdXJyZW50IGRhdGEuXG4gICAqXG4gICAqIEl0IGlzIHNhZmUgdG8gY2FsbCBgbG9hZCgpYCBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtO1xuICAgIGlmIChpdGVtICE9PSBudWxsICYmICF0aGlzLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbS5wYXJlbnQpLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzKTtcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZExvYWQgPSB0cnVlO1xuICB9XG5cbiAgZ2V0U3ViZG9jcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViZG9jc1xuICB9XG5cbiAgZ2V0U3ViZG9jR3VpZHMgKCkge1xuICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5tYXAoZG9jID0+IGRvYy5ndWlkKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoYXQgaGFwcGVuIGluc2lkZSBvZiBhIHRyYW5zYWN0aW9uIGFyZSBidW5kbGVkLiBUaGlzIG1lYW5zIHRoYXRcbiAgICogdGhlIG9ic2VydmVyIGZpcmVzIF9hZnRlcl8gdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkIGFuZCB0aGF0IGFsbCBjaGFuZ2VzXG4gICAqIHRoYXQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSB0cmFuc2FjdGlvbiBhcmUgc2VudCBhcyBvbmUgbWVzc2FnZSB0byB0aGVcbiAgICogb3RoZXIgcGVlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOnZvaWR9IGYgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHthbnl9IFtvcmlnaW5dIE9yaWdpbiBvZiB3aG8gc3RhcnRlZCB0aGUgdHJhbnNhY3Rpb24uIFdpbGwgYmUgc3RvcmVkIG9uIHRyYW5zYWN0aW9uLm9yaWdpblxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0cmFuc2FjdCAoZiwgb3JpZ2luID0gbnVsbCkge1xuICAgIHRyYW5zYWN0KHRoaXMsIGYsIG9yaWdpbik7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgc2hhcmVkIGRhdGEgdHlwZS5cbiAgICpcbiAgICogTXVsdGlwbGUgY2FsbHMgb2YgYHkuZ2V0KG5hbWUsIFR5cGVDb25zdHJ1Y3RvcilgIHlpZWxkIHRoZSBzYW1lIHJlc3VsdFxuICAgKiBhbmQgZG8gbm90IG92ZXJ3cml0ZSBlYWNoIG90aGVyLiBJLmUuXG4gICAqIGB5LmRlZmluZShuYW1lLCBZLkFycmF5KSA9PT0geS5kZWZpbmUobmFtZSwgWS5BcnJheSlgXG4gICAqXG4gICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHR5cGUgaXMgYWxzbyBhdmFpbGFibGUgb24gYHkuc2hhcmUuZ2V0KG5hbWUpYC5cbiAgICpcbiAgICogKkJlc3QgUHJhY3RpY2VzOipcbiAgICogRGVmaW5lIGFsbCB0eXBlcyByaWdodCBhZnRlciB0aGUgWWpzIGluc3RhbmNlIGlzIGNyZWF0ZWQgYW5kIHN0b3JlIHRoZW0gaW4gYSBzZXBhcmF0ZSBvYmplY3QuXG4gICAqIEFsc28gdXNlIHRoZSB0eXBlZCBtZXRob2RzIGBnZXRUZXh0KG5hbWUpYCwgYGdldEFycmF5KG5hbWUpYCwgLi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBjb25zdCB5ID0gbmV3IFkoLi4pXG4gICAqICAgY29uc3QgYXBwU3RhdGUgPSB7XG4gICAqICAgICBkb2N1bWVudDogeS5nZXRUZXh0KCdkb2N1bWVudCcpXG4gICAqICAgICBjb21tZW50czogeS5nZXRBcnJheSgnY29tbWVudHMnKVxuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gVHlwZUNvbnN0cnVjdG9yIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgdHlwZSBkZWZpbml0aW9uLiBFLmcuIFkuVGV4dCwgWS5BcnJheSwgWS5NYXAsIC4uLlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8YW55Pn0gVGhlIGNyZWF0ZWQgdHlwZS4gQ29uc3RydWN0ZWQgd2l0aCBUeXBlQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IChuYW1lLCBUeXBlQ29uc3RydWN0b3IgPSBBYnN0cmFjdFR5cGUpIHtcbiAgICBjb25zdCB0eXBlID0gc2V0SWZVbmRlZmluZWQodGhpcy5zaGFyZSwgbmFtZSwgKCkgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKTtcbiAgICAgIHQuX2ludGVncmF0ZSh0aGlzLCBudWxsKTtcbiAgICAgIHJldHVybiB0XG4gICAgfSk7XG4gICAgY29uc3QgQ29uc3RyID0gdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZUNvbnN0cnVjdG9yICE9PSBBYnN0cmFjdFR5cGUgJiYgQ29uc3RyICE9PSBUeXBlQ29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChDb25zdHIgPT09IEFic3RyYWN0VHlwZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHQgPSBuZXcgVHlwZUNvbnN0cnVjdG9yKCk7XG4gICAgICAgIHQuX21hcCA9IHR5cGUuX21hcDtcbiAgICAgICAgdHlwZS5fbWFwLmZvckVhY2goLyoqIEBwYXJhbSB7SXRlbT99IG4gKi8gbiA9PiB7XG4gICAgICAgICAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLmxlZnQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG4ucGFyZW50ID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0Ll9zdGFydCA9IHR5cGUuX3N0YXJ0O1xuICAgICAgICBmb3IgKGxldCBuID0gdC5fc3RhcnQ7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgICAgICAgbi5wYXJlbnQgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHQuX2xlbmd0aCA9IHR5cGUuX2xlbmd0aDtcbiAgICAgICAgdGhpcy5zaGFyZS5zZXQobmFtZSwgdCk7XG4gICAgICAgIHQuX2ludGVncmF0ZSh0aGlzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSB3aXRoIHRoZSBuYW1lICR7bmFtZX0gaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIHdpdGggYSBkaWZmZXJlbnQgY29uc3RydWN0b3JgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBcnJheSAobmFtZSA9ICcnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBZQXJyYXkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZVGV4dH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0VGV4dCAobmFtZSA9ICcnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBZVGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lNYXA8YW55Pn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0TWFwIChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlNYXApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFhtbEZyYWdtZW50IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlYbWxGcmFnbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZW50aXJlIGRvY3VtZW50IGludG8gYSBqcyBvYmplY3QsIHJlY3Vyc2l2ZWx5IHRyYXZlcnNpbmcgZWFjaCB5anMgdHlwZVxuICAgKiBEb2Vzbid0IGxvZyB0eXBlcyB0aGF0IGhhdmUgbm90IGJlZW4gZGVmaW5lZCAodXNpbmcgeWRvYy5nZXRUeXBlKC4uKSkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgYW5kIHJhdGhlciBjYWxsIHRvSlNPTiBkaXJlY3RseSBvbiB0aGUgc2hhcmVkIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkb2MgPSB7fTtcblxuICAgIHRoaXMuc2hhcmUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgZG9jW2tleV0gPSB2YWx1ZS50b0pTT04oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGBkZXN0cm95YCBldmVudCBhbmQgdW5yZWdpc3RlciBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICBmcm9tKHRoaXMuc3ViZG9jcykuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW07XG4gICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgICAgY29uc3QgY29udGVudCA9IC8qKiBAdHlwZSB7Q29udGVudERvY30gKi8gKGl0ZW0uY29udGVudCk7XG4gICAgICBpZiAoaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29udGVudC5kb2MgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudC5kb2MgPSBuZXcgRG9jKHsgZ3VpZDogdGhpcy5ndWlkLCAuLi5jb250ZW50Lm9wdHMgfSk7XG4gICAgICAgIGNvbnRlbnQuZG9jLl9pdGVtID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbSkucGFyZW50LmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5hZGQoY29udGVudC5kb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzKTtcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3llZCcsIFt0cnVlXSk7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueSk6YW55fSBmXG4gICAqL1xuICBvbiAoZXZlbnROYW1lLCBmKSB7XG4gICAgc3VwZXIub24oZXZlbnROYW1lLCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAoZXZlbnROYW1lLCBmKSB7XG4gICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgZik7XG4gIH1cbn1cblxuY2xhc3MgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyO1xuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHJldHVybiByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRGVjb2RlclYxIGV4dGVuZHMgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQocmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChyZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiByZWFkVWludDgodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlzS2V5XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIHJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGNvcHlVaW50OEFycmF5KHJlYWRWYXJVaW50OEFycmF5KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBpbXBsZW1lbnRhdGlvbiB1c2VzIEpTT04gcGFyc2UuIFdlIHVzZSBhbnktZGVjb2RpbmcgaW4gdjIuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRKU09OICgpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZWFkVmFyU3RyaW5nKHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRLZXkgKCkge1xuICAgIHJldHVybiByZWFkVmFyU3RyaW5nKHRoaXMucmVzdERlY29kZXIpXG4gIH1cbn1cblxuY2xhc3MgRFNEZWNvZGVyVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyO1xuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0Nsb2NrICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCArPSByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKTtcbiAgICByZXR1cm4gdGhpcy5kc0N1cnJWYWxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNMZW4gKCkge1xuICAgIGNvbnN0IGRpZmYgPSByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSArIDE7XG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gZGlmZjtcbiAgICByZXR1cm4gZGlmZlxuICB9XG59XG5cbmNsYXNzIFVwZGF0ZURlY29kZXJWMiBleHRlbmRzIERTRGVjb2RlclYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICBzdXBlcihkZWNvZGVyKTtcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGNhY2hlZCBrZXlzLiBJZiB0aGUga2V5c1tpZF0gZG9lcyBub3QgZXhpc3QsIHdlIHJlYWQgYSBuZXcga2V5XG4gICAgICogZnJvbSBzdHJpbmdFbmNvZGVyIGFuZCBwdXNoIGl0IHRvIGtleXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICByZWFkVmFyVWludChkZWNvZGVyKTsgLy8gcmVhZCBmZWF0dXJlIGZsYWcgLSBjdXJyZW50bHkgdW51c2VkXG4gICAgdGhpcy5rZXlDbG9ja0RlY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMuY2xpZW50RGVjb2RlciA9IG5ldyBVaW50T3B0UmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tEZWNvZGVyID0gbmV3IEludERpZmZPcHRSbGVEZWNvZGVyKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLnJpZ2h0Q2xvY2tEZWNvZGVyID0gbmV3IEludERpZmZPcHRSbGVEZWNvZGVyKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmluZm9EZWNvZGVyID0gbmV3IFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHJlYWRVaW50OCk7XG4gICAgdGhpcy5zdHJpbmdEZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMucGFyZW50SW5mb0RlY29kZXIgPSBuZXcgUmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgcmVhZFVpbnQ4KTtcbiAgICB0aGlzLnR5cGVSZWZEZWNvZGVyID0gbmV3IFVpbnRPcHRSbGVEZWNvZGVyKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmxlbkRlY29kZXIgPSBuZXcgVWludE9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZExlZnRJRCAoKSB7XG4gICAgcmV0dXJuIG5ldyBJRCh0aGlzLmNsaWVudERlY29kZXIucmVhZCgpLCB0aGlzLmxlZnRDbG9ja0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBuZXcgSUQodGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKSwgdGhpcy5yaWdodENsb2NrRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkSW5mbyAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5pbmZvRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZFN0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgcmVhZFBhcmVudEluZm8gKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudEluZm9EZWNvZGVyLnJlYWQoKSA9PT0gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZFR5cGVSZWYgKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVSZWZEZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWRMZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbkRlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIHJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJVaW50OEFycmF5KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBtYWlubHkgaGVyZSBmb3IgbGVnYWN5IHB1cnBvc2VzLlxuICAgKlxuICAgKiBJbml0aWFsIHdlIGluY29kZWQgb2JqZWN0cyB1c2luZyBKU09OLiBOb3cgd2UgdXNlIHRoZSBtdWNoIGZhc3RlciBsaWIwL2FueS1lbmNvZGVyLiBUaGlzIG1ldGhvZCBtYWlubHkgZXhpc3RzIGZvciBsZWdhY3kgcHVycG9zZXMgZm9yIHRoZSB2MSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIHJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICBjb25zdCBrZXlDbG9jayA9IHRoaXMua2V5Q2xvY2tEZWNvZGVyLnJlYWQoKTtcbiAgICBpZiAoa2V5Q2xvY2sgPCB0aGlzLmtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlzW2tleUNsb2NrXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnN0cmluZ0RlY29kZXIucmVhZCgpO1xuICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgIHJldHVybiBrZXlcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRFNFbmNvZGVyVjEge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXN0RW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKVxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZURzTGVuIChsZW4pIHtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuKTtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVFbmNvZGVyVjEgZXh0ZW5kcyBEU0VuY29kZXJWMSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsaWVudCk7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbGllbnQpO1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHdyaXRlQ2xpZW50IGFuZCB3cml0ZUNsb2NrIGluc3RlYWQgb2Ygd3JpdGVJRCBpZiBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKi9cbiAgd3JpdGVDbGllbnQgKGNsaWVudCkge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBjbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlSW5mbyAoaW5mbykge1xuICAgIHdyaXRlVWludDgodGhpcy5yZXN0RW5jb2RlciwgaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICovXG4gIHdyaXRlU3RyaW5nIChzKSB7XG4gICAgd3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2Rlciwgcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1lLZXlcbiAgICovXG4gIHdyaXRlUGFyZW50SW5mbyAoaXNZS2V5KSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlzWUtleSA/IDEgOiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVMZW4gKGxlbikge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhbnlcbiAgICovXG4gIHdyaXRlQW55IChhbnkpIHtcbiAgICB3cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqL1xuICB3cml0ZUJ1ZiAoYnVmKSB7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIsIGJ1Zik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgd3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoZW1iZWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICB3cml0ZUtleSAoa2V5KSB7XG4gICAgd3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2Rlciwga2V5KTtcbiAgfVxufVxuXG5jbGFzcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc3RFbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpOyAvLyBlbmNvZGVzIGFsbCB0aGUgcmVzdCAvIG5vbi1vcHRpbWl6ZWRcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcilcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIHdyaXRlRHNDbG9jayAoY2xvY2spIHtcbiAgICBjb25zdCBkaWZmID0gY2xvY2sgLSB0aGlzLmRzQ3VyclZhbDtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IGNsb2NrO1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBkaWZmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZURzTGVuIChsZW4pIHtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB1bmV4cGVjdGVkQ2FzZSgpO1xuICAgIH1cbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuIC0gMSk7XG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gbGVuO1xuICB9XG59XG5cbmNsYXNzIFVwZGF0ZUVuY29kZXJWMiBleHRlbmRzIERTRW5jb2RlclYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBSZWZlcnMgdG8gdGhlIG5leHQgdW5pcWUga2V5LWlkZW50aWZpZXIgdG8gbWUgdXNlZC5cbiAgICAgKiBTZWUgd3JpdGVLZXkgbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmtleUNsb2NrID0gMDtcbiAgICB0aGlzLmtleUNsb2NrRW5jb2RlciA9IG5ldyBJbnREaWZmT3B0UmxlRW5jb2RlcigpO1xuICAgIHRoaXMuY2xpZW50RW5jb2RlciA9IG5ldyBVaW50T3B0UmxlRW5jb2RlcigpO1xuICAgIHRoaXMubGVmdENsb2NrRW5jb2RlciA9IG5ldyBJbnREaWZmT3B0UmxlRW5jb2RlcigpO1xuICAgIHRoaXMucmlnaHRDbG9ja0VuY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmluZm9FbmNvZGVyID0gbmV3IFJsZUVuY29kZXIod3JpdGVVaW50OCk7XG4gICAgdGhpcy5zdHJpbmdFbmNvZGVyID0gbmV3IFN0cmluZ0VuY29kZXIoKTtcbiAgICB0aGlzLnBhcmVudEluZm9FbmNvZGVyID0gbmV3IFJsZUVuY29kZXIod3JpdGVVaW50OCk7XG4gICAgdGhpcy50eXBlUmVmRW5jb2RlciA9IG5ldyBVaW50T3B0UmxlRW5jb2RlcigpO1xuICAgIHRoaXMubGVuRW5jb2RlciA9IG5ldyBVaW50T3B0UmxlRW5jb2RlcigpO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCAwKTsgLy8gdGhpcyBpcyBhIGZlYXR1cmUgZmxhZyB0aGF0IHdlIG1pZ2h0IHVzZSBpbiB0aGUgZnV0dXJlXG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMua2V5Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5jbGllbnRFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5yaWdodENsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRvVWludDhBcnJheSh0aGlzLmluZm9FbmNvZGVyKSk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMuc3RyaW5nRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRvVWludDhBcnJheSh0aGlzLnBhcmVudEluZm9FbmNvZGVyKSk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMudHlwZVJlZkVuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlbkVuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIC8vIEBub3RlIFRoZSByZXN0IGVuY29kZXIgaXMgYXBwZW5kZWQhIChub3RlIHRoZSBtaXNzaW5nIHZhcilcbiAgICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpKTtcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KGVuY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlTGVmdElEIChpZCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShpZC5jbGllbnQpO1xuICAgIHRoaXMubGVmdENsb2NrRW5jb2Rlci53cml0ZShpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlUmlnaHRJRCAoaWQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoaWQuY2xpZW50KTtcbiAgICB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyLndyaXRlKGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqL1xuICB3cml0ZUNsaWVudCAoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGNsaWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVJbmZvIChpbmZvKSB7XG4gICAgdGhpcy5pbmZvRW5jb2Rlci53cml0ZShpbmZvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgKi9cbiAgd3JpdGVTdHJpbmcgKHMpIHtcbiAgICB0aGlzLnN0cmluZ0VuY29kZXIud3JpdGUocyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1lLZXlcbiAgICovXG4gIHdyaXRlUGFyZW50SW5mbyAoaXNZS2V5KSB7XG4gICAgdGhpcy5wYXJlbnRJbmZvRW5jb2Rlci53cml0ZShpc1lLZXkgPyAxIDogMCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVUeXBlUmVmIChpbmZvKSB7XG4gICAgdGhpcy50eXBlUmVmRW5jb2Rlci53cml0ZShpbmZvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZUxlbiAobGVuKSB7XG4gICAgdGhpcy5sZW5FbmNvZGVyLndyaXRlKGxlbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGFueVxuICAgKi9cbiAgd3JpdGVBbnkgKGFueSkge1xuICAgIHdyaXRlQW55KHRoaXMucmVzdEVuY29kZXIsIGFueSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICovXG4gIHdyaXRlQnVmIChidWYpIHtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlciwgYnVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG1haW5seSBoZXJlIGZvciBsZWdhY3kgcHVycG9zZXMuXG4gICAqXG4gICAqIEluaXRpYWwgd2UgaW5jb2RlZCBvYmplY3RzIHVzaW5nIEpTT04uIE5vdyB3ZSB1c2UgdGhlIG11Y2ggZmFzdGVyIGxpYjAvYW55LWVuY29kZXIuIFRoaXMgbWV0aG9kIG1haW5seSBleGlzdHMgZm9yIGxlZ2FjeSBwdXJwb3NlcyBmb3IgdGhlIHYxIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBlbWJlZFxuICAgKi9cbiAgd3JpdGVKU09OIChlbWJlZCkge1xuICAgIHdyaXRlQW55KHRoaXMucmVzdEVuY29kZXIsIGVtYmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eSBrZXlzIGFyZSBvZnRlbiByZXVzZWQuIEZvciBleGFtcGxlLCBpbiB5LXByb3NlbWlycm9yIHRoZSBrZXkgYGJvbGRgIG1pZ2h0XG4gICAqIG9jY3VyIHZlcnkgb2Z0ZW4uIEZvciBhIDNkIGFwcGxpY2F0aW9uLCB0aGUga2V5IGBwb3NpdGlvbmAgbWlnaHQgb2NjdXIgdmVyeSBvZnRlbi5cbiAgICpcbiAgICogV2UgY2FjaGUgdGhlc2Uga2V5cyBpbiBhIE1hcCBhbmQgcmVmZXIgdG8gdGhlbSB2aWEgYSB1bmlxdWUgbnVtYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICB3cml0ZUtleSAoa2V5KSB7XG4gICAgY29uc3QgY2xvY2sgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICBpZiAoY2xvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5rZXlDbG9ja0VuY29kZXIud3JpdGUodGhpcy5rZXlDbG9jaysrKTtcbiAgICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZSh0aGlzLmtleUNsb2NrKyspO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0FycmF5PEdDfEl0ZW0+fSBzdHJ1Y3RzIEFsbCBzdHJ1Y3RzIGJ5IGBjbGllbnRgXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgd3JpdGUgc3RydWN0cyBzdGFydGluZyB3aXRoIGBJRChjbGllbnQsY2xvY2spYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHMgPSAoZW5jb2Rlciwgc3RydWN0cywgY2xpZW50LCBjbG9jaykgPT4ge1xuICAvLyB3cml0ZSBmaXJzdCBpZFxuICBjbG9jayA9IG1heChjbG9jaywgc3RydWN0c1swXS5pZC5jbG9jayk7IC8vIG1ha2Ugc3VyZSB0aGUgZmlyc3QgaWQgZXhpc3RzXG4gIGNvbnN0IHN0YXJ0TmV3U3RydWN0cyA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN0cnVjdHMubGVuZ3RoIC0gc3RhcnROZXdTdHJ1Y3RzKTtcbiAgZW5jb2Rlci53cml0ZUNsaWVudChjbGllbnQpO1xuICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xvY2spO1xuICBjb25zdCBmaXJzdFN0cnVjdCA9IHN0cnVjdHNbc3RhcnROZXdTdHJ1Y3RzXTtcbiAgLy8gd3JpdGUgZmlyc3Qgc3RydWN0IHdpdGggYW4gb2Zmc2V0XG4gIGZpcnN0U3RydWN0LndyaXRlKGVuY29kZXIsIGNsb2NrIC0gZmlyc3RTdHJ1Y3QuaWQuY2xvY2spO1xuICBmb3IgKGxldCBpID0gc3RhcnROZXdTdHJ1Y3RzICsgMTsgaSA8IHN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJ1Y3RzW2ldLndyaXRlKGVuY29kZXIsIDApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IF9zbVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVDbGllbnRzU3RydWN0cyA9IChlbmNvZGVyLCBzdG9yZSwgX3NtKSA9PiB7XG4gIC8vIHdlIGZpbHRlciBhbGwgdmFsaWQgX3NtIGVudHJpZXMgaW50byBzbVxuICBjb25zdCBzbSA9IG5ldyBNYXAoKTtcbiAgX3NtLmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAvLyBvbmx5IHdyaXRlIGlmIG5ldyBzdHJ1Y3RzIGFyZSBhdmFpbGFibGVcbiAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkgPiBjbG9jaykge1xuICAgICAgc20uc2V0KGNsaWVudCwgY2xvY2spO1xuICAgIH1cbiAgfSk7XG4gIGdldFN0YXRlVmVjdG9yKHN0b3JlKS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgaWYgKCFfc20uaGFzKGNsaWVudCkpIHtcbiAgICAgIHNtLnNldChjbGllbnQsIDApO1xuICAgIH1cbiAgfSk7XG4gIC8vIHdyaXRlICMgc3RhdGVzIHRoYXQgd2VyZSB1cGRhdGVkXG4gIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzbS5zaXplKTtcbiAgLy8gV3JpdGUgaXRlbXMgd2l0aCBoaWdoZXIgY2xpZW50IGlkcyBmaXJzdFxuICAvLyBUaGlzIGhlYXZpbHkgaW1wcm92ZXMgdGhlIGNvbmZsaWN0IGFsZ29yaXRobS5cbiAgQXJyYXkuZnJvbShzbS5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKS5mb3JFYWNoKChbY2xpZW50LCBjbG9ja10pID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JpdGVTdHJ1Y3RzKGVuY29kZXIsIHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCksIGNsaWVudCwgY2xvY2spO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXIgVGhlIGRlY29kZXIgb2JqZWN0IHRvIHJlYWQgZGF0YSBmcm9tLlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHJldHVybiB7TWFwPG51bWJlciwgeyBpOiBudW1iZXIsIHJlZnM6IEFycmF5PEl0ZW0gfCBHQz4gfT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkQ2xpZW50c1N0cnVjdFJlZnMgPSAoZGVjb2RlciwgZG9jKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgeyBpOiBudW1iZXIsIHJlZnM6IEFycmF5PEl0ZW0gfCBHQz4gfT59XG4gICAqL1xuICBjb25zdCBjbGllbnRSZWZzID0gY3JlYXRlKCk7XG4gIGNvbnN0IG51bU9mU3RhdGVVcGRhdGVzID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZTdGF0ZVVwZGF0ZXM7IGkrKykge1xuICAgIGNvbnN0IG51bWJlck9mU3RydWN0cyA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn1cbiAgICAgKi9cbiAgICBjb25zdCByZWZzID0gbmV3IEFycmF5KG51bWJlck9mU3RydWN0cyk7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2Rlci5yZWFkQ2xpZW50KCk7XG4gICAgbGV0IGNsb2NrID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgLy8gY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNsaWVudFJlZnMuc2V0KGNsaWVudCwgeyBpOiAwLCByZWZzIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdHJ1Y3RzOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZm8gPSBkZWNvZGVyLnJlYWRJbmZvKCk7XG4gICAgICBzd2l0Y2ggKEJJVFM1ICYgaW5mbykge1xuICAgICAgICBjYXNlIDA6IHsgLy8gR0NcbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6IHsgLy8gU2tpcCBTdHJ1Y3QgKG5vdGhpbmcgdG8gYXBwbHkpXG4gICAgICAgICAgLy8gQHRvZG8gd2UgY291bGQgcmVkdWNlIHRoZSBhbW91bnQgb2YgY2hlY2tzIGJ5IGFkZGluZyBTa2lwIHN0cnVjdCB0byBjbGllbnRSZWZzIHNvIHdlIGtub3cgdGhhdCBzb21ldGhpbmcgaXMgbWlzc2luZy5cbiAgICAgICAgICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogeyAvLyBJdGVtIHdpdGggY29udGVudFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgYW55IHZhcmlhYmxlcyBiZWNhdXNlIGlubGluaW5nIHZhcmlhYmxlcyBpcyBmYXN0ZXIuXG4gICAgICAgICAgICogQmVsb3cgYSBub24tb3B0aW1pemVkIHZlcnNpb24gaXMgc2hvd24gdGhhdCBpbXBsZW1lbnRzIHRoZSBiYXNpYyBhbGdvcml0aG0gd2l0aFxuICAgICAgICAgICAqIGEgZmV3IGNvbW1lbnRzXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoQklUNyB8IEJJVDgpKSA9PT0gMDtcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgICAgbnVsbCwgLy8gbGVmdGRcbiAgICAgICAgICAgIChpbmZvICYgQklUOCkgPT09IEJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgICAgbnVsbCwgLy8gcmlnaHRcbiAgICAgICAgICAgIChpbmZvICYgQklUNykgPT09IEJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkb2MuZ2V0KGRlY29kZXIucmVhZFN0cmluZygpKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgQklUNikgPT09IEJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICAgICk7XG4gICAgICAgICAgLyogQSBub24tb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBhYm92ZSBhbGdvcml0aG06XG5cbiAgICAgICAgICAvLyBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCBvcmlnaW4gPSAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGxcbiAgICAgICAgICAvLyBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSByaWdodCBvZiB0aGlzIGl0ZW0uXG4gICAgICAgICAgY29uc3QgcmlnaHRPcmlnaW4gPSAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwXG4gICAgICAgICAgY29uc3QgaGFzUGFyZW50WUtleSA9IGNhbnRDb3B5UGFyZW50SW5mbyA/IGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA6IGZhbHNlXG4gICAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgICAgLy8gYW5kIHdlIHJlYWQgdGhlIG5leHQgc3RyaW5nIGFzIHBhcmVudFlLZXkuXG4gICAgICAgICAgLy8gSXQgaW5kaWNhdGVzIGhvdyB3ZSBzdG9yZS9yZXRyaWV2ZSBwYXJlbnQgZnJvbSBgeS5zaGFyZWBcbiAgICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgICAgY29uc3QgcGFyZW50WUtleSA9IGNhbnRDb3B5UGFyZW50SW5mbyAmJiBoYXNQYXJlbnRZS2V5ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsXG5cbiAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgICAgbnVsbCwgLy8gbGVmdGRcbiAgICAgICAgICAgIG9yaWdpbiwgLy8gb3JpZ2luXG4gICAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgICAgcmlnaHRPcmlnaW4sIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmICFoYXNQYXJlbnRZS2V5ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiAocGFyZW50WUtleSAhPT0gbnVsbCA/IGRvYy5nZXQocGFyZW50WUtleSkgOiBudWxsKSwgLy8gcGFyZW50XG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgKGluZm8gJiBiaW5hcnkuQklUNikgPT09IGJpbmFyeS5CSVQ2ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsLCAvLyBwYXJlbnRTdWJcbiAgICAgICAgICAgIHJlYWRJdGVtQ29udGVudChkZWNvZGVyLCBpbmZvKSAvLyBpdGVtIGNvbnRlbnRcbiAgICAgICAgICApXG4gICAgICAgICAgKi9cbiAgICAgICAgICByZWZzW2ldID0gc3RydWN0O1xuICAgICAgICAgIGNsb2NrICs9IHN0cnVjdC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVhZDogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gIH1cbiAgcmV0dXJuIGNsaWVudFJlZnNcbn07XG5cbi8qKlxuICogUmVzdW1lIGNvbXB1dGluZyBzdHJ1Y3RzIGdlbmVyYXRlZCBieSBzdHJ1Y3QgcmVhZGVycy5cbiAqXG4gKiBXaGlsZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8sIHdlIGludGVncmF0ZSBzdHJ1Y3RzIGluIHRoaXMgb3JkZXJcbiAqIDEuIHRvcCBlbGVtZW50IG9uIHN0YWNrLCBpZiBzdGFjayBpcyBub3QgZW1wdHlcbiAqIDIuIG5leHQgZWxlbWVudCBmcm9tIGN1cnJlbnQgc3RydWN0IHJlYWRlciAoaWYgZW1wdHksIHVzZSBuZXh0IHN0cnVjdCByZWFkZXIpXG4gKlxuICogSWYgc3RydWN0IGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciBzdHJ1Y3QgKHJlZi5taXNzaW5nKSwgd2UgcHV0IG5leHQgcmVhZGVyIG9mXG4gKiBgcmVmLmlkLmNsaWVudGAgb24gdG9wIG9mIHN0YWNrLlxuICpcbiAqIEF0IHNvbWUgcG9pbnQgd2UgZmluZCBhIHN0cnVjdCB0aGF0IGhhcyBubyBjYXVzYWwgZGVwZW5kZW5jaWVzLFxuICogdGhlbiB3ZSBzdGFydCBlbXB0eWluZyB0aGUgc3RhY2suXG4gKlxuICogSXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgY2lyY2xlczogaS5lLiBzdHJ1Y3QxIChmcm9tIGNsaWVudDEpIGRlcGVuZHMgb24gc3RydWN0MiAoZnJvbSBjbGllbnQyKVxuICogZGVwZW5kcyBvbiBzdHJ1Y3QzIChmcm9tIGNsaWVudDEpLiBUaGVyZWZvcmUgdGhlIG1heCBzdGFjayBzaXplIGlzIGVxYXVsIHRvIGBzdHJ1Y3RSZWFkZXJzLmxlbmd0aGAuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgaW1wbGVtZW50ZWQgaW4gYSB3YXkgc28gdGhhdCB3ZSBjYW4gcmVzdW1lIGNvbXB1dGF0aW9uIGlmIHRoaXMgdXBkYXRlXG4gKiBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogKEdDIHwgSXRlbSlbXSB9Pn0gY2xpZW50c1N0cnVjdFJlZnNcbiAqIEByZXR1cm4geyBudWxsIHwgeyB1cGRhdGU6IFVpbnQ4QXJyYXksIG1pc3Npbmc6IE1hcDxudW1iZXIsbnVtYmVyPiB9IH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGludGVncmF0ZVN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBjbGllbnRzU3RydWN0UmVmcykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0gfCBHQz59XG4gICAqL1xuICBjb25zdCBzdGFjayA9IFtdO1xuICAvLyBzb3J0IHRoZW0gc28gdGhhdCB3ZSB0YWtlIHRoZSBoaWdoZXIgaWQgZmlyc3QsIGluIGNhc2Ugb2YgY29uZmxpY3RzIHRoZSBsb3dlciBpZCB3aWxsIHByb2JhYmx5IG5vdCBjb25mbGljdCB3aXRoIHRoZSBpZCBmcm9tIHRoZSBoaWdoZXIgdXNlci5cbiAgbGV0IGNsaWVudHNTdHJ1Y3RSZWZzSWRzID0gQXJyYXkuZnJvbShjbGllbnRzU3RydWN0UmVmcy5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgaWYgKGNsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgZ2V0TmV4dFN0cnVjdFRhcmdldCA9ICgpID0+IHtcbiAgICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBsZXQgbmV4dFN0cnVjdHNUYXJnZXQgPSAvKiogQHR5cGUge3tpOm51bWJlcixyZWZzOkFycmF5PEdDfEl0ZW0+fX0gKi8gKGNsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnRzU3RydWN0UmVmc0lkc1tjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggLSAxXSkpO1xuICAgIHdoaWxlIChuZXh0U3RydWN0c1RhcmdldC5yZWZzLmxlbmd0aCA9PT0gbmV4dFN0cnVjdHNUYXJnZXQuaSkge1xuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMucG9wKCk7XG4gICAgICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFN0cnVjdHNUYXJnZXRcbiAgfTtcbiAgbGV0IGN1clN0cnVjdHNUYXJnZXQgPSBnZXROZXh0U3RydWN0VGFyZ2V0KCk7XG4gIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ID09PSBudWxsICYmIHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cnVjdFN0b3JlfVxuICAgKi9cbiAgY29uc3QgcmVzdFN0cnVjdHMgPSBuZXcgU3RydWN0U3RvcmUoKTtcbiAgY29uc3QgbWlzc2luZ1NWID0gbmV3IE1hcCgpO1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIGNvbnN0IHVwZGF0ZU1pc3NpbmdTdiA9IChjbGllbnQsIGNsb2NrKSA9PiB7XG4gICAgY29uc3QgbWNsb2NrID0gbWlzc2luZ1NWLmdldChjbGllbnQpO1xuICAgIGlmIChtY2xvY2sgPT0gbnVsbCB8fCBtY2xvY2sgPiBjbG9jaykge1xuICAgICAgbWlzc2luZ1NWLnNldChjbGllbnQsIGNsb2NrKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAdHlwZSB7R0N8SXRlbX1cbiAgICovXG4gIGxldCBzdGFja0hlYWQgPSAvKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLnJlZnNbLyoqIEB0eXBlIHthbnl9ICovIChjdXJTdHJ1Y3RzVGFyZ2V0KS5pKytdO1xuICAvLyBjYWNoaW5nIHRoZSBzdGF0ZSBiZWNhdXNlIGl0IGlzIHVzZWQgdmVyeSBvZnRlblxuICBjb25zdCBzdGF0ZSA9IG5ldyBNYXAoKTtcblxuICBjb25zdCBhZGRTdGFja1RvUmVzdFNTID0gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBzdGFjaykge1xuICAgICAgY29uc3QgY2xpZW50ID0gaXRlbS5pZC5jbGllbnQ7XG4gICAgICBjb25zdCB1bmFwcGxpY2FibGVJdGVtcyA9IGNsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnQpO1xuICAgICAgaWYgKHVuYXBwbGljYWJsZUl0ZW1zKSB7XG4gICAgICAgIC8vIGRlY3JlbWVudCBiZWNhdXNlIHdlIHdlcmVuJ3QgYWJsZSB0byBhcHBseSBwcmV2aW91cyBvcGVyYXRpb25cbiAgICAgICAgdW5hcHBsaWNhYmxlSXRlbXMuaS0tO1xuICAgICAgICByZXN0U3RydWN0cy5jbGllbnRzLnNldChjbGllbnQsIHVuYXBwbGljYWJsZUl0ZW1zLnJlZnMuc2xpY2UodW5hcHBsaWNhYmxlSXRlbXMuaSkpO1xuICAgICAgICBjbGllbnRzU3RydWN0UmVmcy5kZWxldGUoY2xpZW50KTtcbiAgICAgICAgdW5hcHBsaWNhYmxlSXRlbXMuaSA9IDA7XG4gICAgICAgIHVuYXBwbGljYWJsZUl0ZW1zLnJlZnMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0ZW0gd2FzIHRoZSBsYXN0IGl0ZW0gb24gY2xpZW50c1N0cnVjdFJlZnMgYW5kIHRoZSBmaWVsZCB3YXMgYWxyZWFkeSBjbGVhcmVkLiBBZGQgaXRlbSB0byByZXN0U3RydWN0cyBhbmQgY29udGludWVcbiAgICAgICAgcmVzdFN0cnVjdHMuY2xpZW50cy5zZXQoY2xpZW50LCBbaXRlbV0pO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGNsaWVudCBmcm9tIGNsaWVudHNTdHJ1Y3RSZWZzSWRzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSBhcHBseWluZyB0aGUgc2FtZSB1cGRhdGUgYWdhaW5cbiAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzSWRzID0gY2xpZW50c1N0cnVjdFJlZnNJZHMuZmlsdGVyKGMgPT4gYyAhPT0gY2xpZW50KTtcbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gMDtcbiAgfTtcblxuICAvLyBpdGVyYXRlIG92ZXIgYWxsIHN0cnVjdCByZWFkZXJzIHVudGlsIHdlIGFyZSBkb25lXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHN0YWNrSGVhZC5jb25zdHJ1Y3RvciAhPT0gU2tpcCkge1xuICAgICAgY29uc3QgbG9jYWxDbG9jayA9IHNldElmVW5kZWZpbmVkKHN0YXRlLCBzdGFja0hlYWQuaWQuY2xpZW50LCAoKSA9PiBnZXRTdGF0ZShzdG9yZSwgc3RhY2tIZWFkLmlkLmNsaWVudCkpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbG9jYWxDbG9jayAtIHN0YWNrSGVhZC5pZC5jbG9jaztcbiAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIHRoZSBzYW1lIGNsaWVudCBpcyBtaXNzaW5nXG4gICAgICAgIHN0YWNrLnB1c2goc3RhY2tIZWFkKTtcbiAgICAgICAgdXBkYXRlTWlzc2luZ1N2KHN0YWNrSGVhZC5pZC5jbGllbnQsIHN0YWNrSGVhZC5pZC5jbG9jayAtIDEpO1xuICAgICAgICAvLyBoaWQgYSBkZWFkIHdhbGwsIGFkZCBhbGwgaXRlbXMgZnJvbSBzdGFjayB0byByZXN0U1NcbiAgICAgICAgYWRkU3RhY2tUb1Jlc3RTUygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IHN0YWNrSGVhZC5nZXRNaXNzaW5nKHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gICAgICAgIGlmIChtaXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpO1xuICAgICAgICAgIC8vIGdldCB0aGUgc3RydWN0IHJlYWRlciB0aGF0IGhhcyB0aGUgbWlzc2luZyBzdHJ1Y3RcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7eyByZWZzOiBBcnJheTxHQ3xJdGVtPiwgaTogbnVtYmVyIH19XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3Qgc3RydWN0UmVmcyA9IGNsaWVudHNTdHJ1Y3RSZWZzLmdldCgvKiogQHR5cGUge251bWJlcn0gKi8gKG1pc3NpbmcpKSB8fCB7IHJlZnM6IFtdLCBpOiAwIH07XG4gICAgICAgICAgaWYgKHN0cnVjdFJlZnMucmVmcy5sZW5ndGggPT09IHN0cnVjdFJlZnMuaSkge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgbWVzc2FnZSBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlIG1lc3NhZ2UgdGhhdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgICAgICAgdXBkYXRlTWlzc2luZ1N2KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZyksIGdldFN0YXRlKHN0b3JlLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICBhZGRTdGFja1RvUmVzdFNTKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrSGVhZCA9IHN0cnVjdFJlZnMucmVmc1tzdHJ1Y3RSZWZzLmkrK107XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT09IDAgfHwgb2Zmc2V0IDwgc3RhY2tIZWFkLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGFsbCBmaW5lLCBhcHBseSB0aGUgc3RhY2toZWFkXG4gICAgICAgICAgc3RhY2tIZWFkLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgICBzdGF0ZS5zZXQoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrICsgc3RhY2tIZWFkLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaXRlcmF0ZSB0byBuZXh0IHN0YWNrSGVhZFxuICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChzdGFjay5wb3AoKSk7XG4gICAgfSBlbHNlIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ICE9PSBudWxsICYmIGN1clN0cnVjdHNUYXJnZXQuaSA8IGN1clN0cnVjdHNUYXJnZXQucmVmcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpO1xuICAgICAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgYXJlIGRvbmUhXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnNbY3VyU3RydWN0c1RhcmdldC5pKytdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpO1xuICAgIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgcmVzdFN0cnVjdHMsIG5ldyBNYXAoKSk7XG4gICAgLy8gd3JpdGUgZW1wdHkgZGVsZXRlc2V0XG4gICAgLy8gd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgbmV3IERlbGV0ZVNldCgpKVxuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCAwKTsgLy8gPT4gbm8gbmVlZCBmb3IgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbCwganVzdCB3cml0ZSAwIGRlbGV0ZXNcbiAgICByZXR1cm4geyBtaXNzaW5nOiBtaXNzaW5nU1YsIHVwZGF0ZTogZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24gPSAoZW5jb2RlciwgdHJhbnNhY3Rpb24pID0+IHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBbc3RydWN0RGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZVYyID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBzdHJ1Y3REZWNvZGVyID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGVyKSkgPT5cbiAgdHJhbnNhY3QoeWRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCByZXRyeSA9IGZhbHNlO1xuICAgIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgICAvLyBsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHNzID0gcmVhZENsaWVudHNTdHJ1Y3RSZWZzKHN0cnVjdERlY29kZXIsIGRvYyk7XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVhZCBzdHJ1Y3RzOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gbWVyZ2U6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCByZXN0U3RydWN0cyA9IGludGVncmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIHN0b3JlLCBzcyk7XG4gICAgY29uc3QgcGVuZGluZyA9IHN0b3JlLnBlbmRpbmdTdHJ1Y3RzO1xuICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gYXBwbHkgc29tZXRoaW5nXG4gICAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiBwZW5kaW5nLm1pc3NpbmcpIHtcbiAgICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgICByZXRyeSA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3RTdHJ1Y3RzKSB7XG4gICAgICAgIC8vIG1lcmdlIHJlc3RTdHJ1Y3RzIGludG8gc3RvcmUucGVuZGluZ1xuICAgICAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiByZXN0U3RydWN0cy5taXNzaW5nKSB7XG4gICAgICAgICAgY29uc3QgbWNsb2NrID0gcGVuZGluZy5taXNzaW5nLmdldChjbGllbnQpO1xuICAgICAgICAgIGlmIChtY2xvY2sgPT0gbnVsbCB8fCBtY2xvY2sgPiBjbG9jaykge1xuICAgICAgICAgICAgcGVuZGluZy5taXNzaW5nLnNldChjbGllbnQsIGNsb2NrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZy51cGRhdGUgPSBtZXJnZVVwZGF0ZXNWMihbcGVuZGluZy51cGRhdGUsIHJlc3RTdHJ1Y3RzLnVwZGF0ZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZS5wZW5kaW5nU3RydWN0cyA9IHJlc3RTdHJ1Y3RzO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBpbnRlZ3JhdGU6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCBkc1Jlc3QgPSByZWFkQW5kQXBwbHlEZWxldGVTZXQoc3RydWN0RGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKTtcbiAgICBpZiAoc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgICAvLyBAdG9kbyB3ZSBjb3VsZCBtYWtlIGEgbG93ZXItYm91bmQgc3RhdGUtdmVjdG9yIGNoZWNrIGFzIHdlIGRvIGFib3ZlXG4gICAgICBjb25zdCBwZW5kaW5nRFNVcGRhdGUgPSBuZXcgVXBkYXRlRGVjb2RlclYyKGNyZWF0ZURlY29kZXIoc3RvcmUucGVuZGluZ0RzKSk7XG4gICAgICByZWFkVmFyVWludChwZW5kaW5nRFNVcGRhdGUucmVzdERlY29kZXIpOyAvLyByZWFkIDAgc3RydWN0cywgYmVjYXVzZSB3ZSBvbmx5IGVuY29kZSBkZWxldGVzIGluIHBlbmRpbmdkc3VwZGF0ZVxuICAgICAgY29uc3QgZHNSZXN0MiA9IHJlYWRBbmRBcHBseURlbGV0ZVNldChwZW5kaW5nRFNVcGRhdGUsIHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gICAgICBpZiAoZHNSZXN0ICYmIGRzUmVzdDIpIHtcbiAgICAgICAgLy8gY2FzZSAxOiBkczEgIT0gbnVsbCAmJiBkczIgIT0gbnVsbFxuICAgICAgICBzdG9yZS5wZW5kaW5nRHMgPSBtZXJnZVVwZGF0ZXNWMihbZHNSZXN0LCBkc1Jlc3QyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYXNlIDI6IGRzMSAhPSBudWxsXG4gICAgICAgIC8vIGNhc2UgMzogZHMyICE9IG51bGxcbiAgICAgICAgLy8gY2FzZSA0OiBkczEgPT0gbnVsbCAmJiBkczIgPT0gbnVsbFxuICAgICAgICBzdG9yZS5wZW5kaW5nRHMgPSBkc1Jlc3QgfHwgZHNSZXN0MjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIGRzUmVzdCA9PSBudWxsICYmIHBlbmRpbmdEcyA9PSBudWxsIE9SIGRzUmVzdCAhPSBudWxsXG4gICAgICBzdG9yZS5wZW5kaW5nRHMgPSBkc1Jlc3Q7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGNsZWFudXA6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlc3VtZSBkZWxldGUgcmVhZGVyczogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGlmIChyZXRyeSkge1xuICAgICAgY29uc3QgdXBkYXRlID0gLyoqIEB0eXBlIHt7dXBkYXRlOiBVaW50OEFycmF5fX0gKi8gKHN0b3JlLnBlbmRpbmdTdHJ1Y3RzKS51cGRhdGU7XG4gICAgICBzdG9yZS5wZW5kaW5nU3RydWN0cyA9IG51bGw7XG4gICAgICBhcHBseVVwZGF0ZVYyKHRyYW5zYWN0aW9uLmRvYywgdXBkYXRlKTtcbiAgICB9XG4gIH0sIHRyYW5zYWN0aW9uT3JpZ2luLCBmYWxzZSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZSA9IChkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gcmVhZFVwZGF0ZVYyKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBuZXcgVXBkYXRlRGVjb2RlclYxKGRlY29kZXIpKTtcblxuLyoqXG4gKiBBcHBseSBhIGRvY3VtZW50IHVwZGF0ZSBjcmVhdGVkIGJ5LCBmb3IgZXhhbXBsZSwgYHkub24oJ3VwZGF0ZScsIHVwZGF0ZSA9PiAuLilgIG9yIGB1cGRhdGUgPSBlbmNvZGVTdGF0ZUFzVXBkYXRlKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgcmVhZFVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgRGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gW1lEZWNvZGVyXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhcHBseVVwZGF0ZVYyID0gKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4sIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKHVwZGF0ZSk7XG4gIHJlYWRVcGRhdGVWMihkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbiwgbmV3IFlEZWNvZGVyKGRlY29kZXIpKTtcbn07XG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYXBwbHlVcGRhdGUgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gYXBwbHlVcGRhdGVWMih5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlVmVjdG9yYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gW3RhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RhdGVBc1VwZGF0ZSA9IChlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yID0gbmV3IE1hcCgpKSA9PiB7XG4gIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgZG9jLnN0b3JlLCB0YXJnZXRTdGF0ZVZlY3Rvcik7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZShkb2Muc3RvcmUpKTtcbn07XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVBc1VwZGF0ZVYyID0gKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoWzBdKSwgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKSkgPT4ge1xuICBjb25zdCB0YXJnZXRTdGF0ZVZlY3RvciA9IGRlY29kZVN0YXRlVmVjdG9yKGVuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcik7XG4gIHdyaXRlU3RhdGVBc1VwZGF0ZShlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yKTtcbiAgY29uc3QgdXBkYXRlcyA9IFtlbmNvZGVyLnRvVWludDhBcnJheSgpXTtcbiAgLy8gYWxzbyBhZGQgdGhlIHBlbmRpbmcgdXBkYXRlcyAoaWYgdGhlcmUgYXJlIGFueSlcbiAgLy8gQHRvZG8gc3VwcG9ydCBkaWZmaXJlbnQgZW5jb2RlcnNcbiAgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMikge1xuICAgIGlmIChkb2Muc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgICB1cGRhdGVzLnB1c2goZG9jLnN0b3JlLnBlbmRpbmdEcyk7XG4gICAgfVxuICAgIGlmIChkb2Muc3RvcmUucGVuZGluZ1N0cnVjdHMpIHtcbiAgICAgIHVwZGF0ZXMucHVzaChkaWZmVXBkYXRlVjIoZG9jLnN0b3JlLnBlbmRpbmdTdHJ1Y3RzLnVwZGF0ZSwgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKSk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBtZXJnZVVwZGF0ZXNWMih1cGRhdGVzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXBkYXRlc1swXVxufTtcblxuLyoqXG4gKiBXcml0ZSBhbGwgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlIHRoYXQgY2FuIGJlIGFwcGxpZWQgb24gdGhlIHJlbW90ZSBkb2N1bWVudC4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogVXNlIGB3cml0ZVN0YXRlQXNVcGRhdGVgIGluc3RlYWQgaWYgeW91IGFyZSB3b3JraW5nIHdpdGggbGliMC9lbmNvZGluZy5qcyNFbmNvZGVyXG4gKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZUFzVXBkYXRlID0gKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKSA9PiBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IsIG5ldyBVcGRhdGVFbmNvZGVyVjEoKSk7XG5cbi8qKlxuICogUmVhZCBzdGF0ZSB2ZWN0b3IgZnJvbSBEZWNvZGVyIGFuZCByZXR1cm4gYXMgTWFwXG4gKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFN0YXRlVmVjdG9yID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHNzID0gbmV3IE1hcCgpO1xuICBjb25zdCBzc0xlbmd0aCA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnQgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBjbG9jayA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIHNzLnNldChjbGllbnQsIGNsb2NrKTtcbiAgfVxuICByZXR1cm4gc3Ncbn07XG5cbi8qKlxuICogUmVhZCBkZWNvZGVkU3RhdGUgYW5kIHJldHVybiBTdGF0ZSBhcyBNYXAuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkZWNvZGVkU3RhdGVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG4vLyBleHBvcnQgY29uc3QgZGVjb2RlU3RhdGVWZWN0b3JWMiA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpXG5cbi8qKlxuICogUmVhZCBkZWNvZGVkU3RhdGUgYW5kIHJldHVybiBTdGF0ZSBhcyBNYXAuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkZWNvZGVkU3RhdGVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWNvZGVTdGF0ZVZlY3RvciA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYxKGNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2XG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBzdikgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3Yuc2l6ZSk7XG4gIHN2LmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KTsgLy8gQHRvZG8gdXNlIGEgc3BlY2lhbCBjbGllbnQgZGVjb2RlciB0aGF0IGlzIGJhc2VkIG9uIG1hcHBpbmdcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xvY2spO1xuICB9KTtcbiAgcmV0dXJuIGVuY29kZXJcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlRG9jdW1lbnRTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBkb2MpID0+IHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKSk7XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZVZlY3RvclYyID0gKGRvYywgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIGlmIChkb2MgaW5zdGFuY2VvZiBNYXApIHtcbiAgICB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYyk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yID0gZG9jID0+IGVuY29kZVN0YXRlVmVjdG9yVjIoZG9jLCBuZXcgRFNFbmNvZGVyVjEoKSk7XG5cbi8qKlxuICogR2VuZXJhbCBldmVudCBoYW5kbGVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLCBBUkcxXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihBUkcwLCBBUkcxKTp2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLmwgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEByZXR1cm5zIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUV2ZW50SGFuZGxlciA9ICgpID0+IG5ldyBFdmVudEhhbmRsZXIoKTtcblxuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaXMgY2FsbGVkIHdoZW5cbiAqIHtAbGluayBFdmVudEhhbmRsZXIjY2FsbEV2ZW50TGlzdGVuZXJzfSBpcyBjYWxsZWQuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT5cbiAgZXZlbnRIYW5kbGVyLmwucHVzaChmKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtmdW5jdGlvbihBUkcwLEFSRzEpOnZvaWR9IGYgVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCB3YXMgYWRkZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lciA9IChldmVudEhhbmRsZXIsIGYpID0+IHtcbiAgY29uc3QgbCA9IGV2ZW50SGFuZGxlci5sO1xuICBjb25zdCBsZW4gPSBsLmxlbmd0aDtcbiAgZXZlbnRIYW5kbGVyLmwgPSBsLmZpbHRlcihnID0+IGYgIT09IGcpO1xuICBpZiAobGVuID09PSBldmVudEhhbmRsZXIubC5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbeWpzXSBUcmllZCB0byByZW1vdmUgZXZlbnQgaGFuZGxlciB0aGF0IGRvZXNuXFwndCBleGlzdC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGFsbCBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkIHZpYVxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNhZGRFdmVudExpc3RlbmVyfS5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7QVJHMH0gYXJnMFxuICogQHBhcmFtIHtBUkcxfSBhcmcxXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzID0gKGV2ZW50SGFuZGxlciwgYXJnMCwgYXJnMSkgPT5cbiAgY2FsbEFsbChldmVudEhhbmRsZXIubCwgW2FyZzAsIGFyZzFdKTtcblxuY2xhc3MgSUQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudCBjbGllbnQgaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrIHVuaXF1ZSBwZXIgY2xpZW50IGlkLCBjb250aW51b3VzIG51bWJlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNsaWVudCwgY2xvY2spIHtcbiAgICAvKipcbiAgICAgKiBDbGllbnQgaWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIC8qKlxuICAgICAqIHVuaXF1ZSBwZXIgY2xpZW50IGlkLCBjb250aW51b3VzIG51bWJlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbG9jayA9IGNsb2NrO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtJRCB8IG51bGx9IGFcbiAqIEBwYXJhbSB7SUQgfCBudWxsfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjb21wYXJlSURzID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmNsaWVudCA9PT0gYi5jbGllbnQgJiYgYS5jbG9jayA9PT0gYi5jbG9jayk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVJRCA9IChjbGllbnQsIGNsb2NrKSA9PiBuZXcgSUQoY2xpZW50LCBjbG9jayk7XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0lEfSBpZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVJRCA9IChlbmNvZGVyLCBpZCkgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgaWQuY2xpZW50KTtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGlkLmNsb2NrKTtcbn07XG5cbi8qKlxuICogUmVhZCBJRC5cbiAqICogSWYgZmlyc3QgdmFyVWludCByZWFkIGlzIDB4RkZGRkZGIGEgUm9vdElEIGlzIHJldHVybmVkLlxuICogKiBPdGhlcndpc2UgYW4gSUQgaXMgcmV0dXJuZWRcbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0lEfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZElEID0gZGVjb2RlciA9PlxuICBjcmVhdGVJRChyZWFkVmFyVWludChkZWNvZGVyKSwgcmVhZFZhclVpbnQoZGVjb2RlcikpO1xuXG4vKipcbiAqIFRoZSB0b3AgdHlwZXMgYXJlIG1hcHBlZCBmcm9tIHkuc2hhcmUuZ2V0KGtleW5hbWUpID0+IHR5cGUuXG4gKiBgdHlwZWAgZG9lcyBub3Qgc3RvcmUgYW55IGluZm9ybWF0aW9uIGFib3V0IHRoZSBga2V5bmFtZWAuXG4gKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBjb3JyZWN0IGBrZXluYW1lYCBmb3IgYHR5cGVgIGFuZCB0aHJvd3Mgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRSb290VHlwZUtleSA9IHR5cGUgPT4ge1xuICAvLyBAdHMtaWdub3JlIF95IG11c3QgYmUgZGVmaW5lZCwgb3RoZXJ3aXNlIHVuZXhwZWN0ZWQgY2FzZVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0eXBlLmRvYy5zaGFyZS5lbnRyaWVzKCkpIHtcbiAgICBpZiAodmFsdWUgPT09IHR5cGUpIHtcbiAgICAgIHJldHVybiBrZXlcbiAgICB9XG4gIH1cbiAgdGhyb3cgdW5leHBlY3RlZENhc2UoKVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgcGFyZW50YCBpcyBhIHBhcmVudCBvZiBgY2hpbGRgLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtfG51bGx9IGNoaWxkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpc1BhcmVudE9mID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBjaGlsZCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5wYXJlbnQpLl9pdGVtO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLyoqXG4gKiBDb252ZW5pZW50IGhlbHBlciB0byBsb2cgdHlwZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBEbyBub3QgdXNlIGluIHByb2R1Y3RpdmUgc3lzdGVtcyBhcyB0aGUgb3V0cHV0IGNhbiBiZSBpbW1lbnNlIVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqL1xuY29uc3QgbG9nVHlwZSA9IHR5cGUgPT4ge1xuICBjb25zdCByZXMgPSBbXTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4pIHtcbiAgICByZXMucHVzaChuKTtcbiAgICBuID0gbi5yaWdodDtcbiAgfVxuICBjb25zb2xlLmxvZygnQ2hpbGRyZW46ICcsIHJlcyk7XG4gIGNvbnNvbGUubG9nKCdDaGlsZHJlbiBjb250ZW50OiAnLCByZXMuZmlsdGVyKG0gPT4gIW0uZGVsZXRlZCkubWFwKG0gPT4gbS5jb250ZW50KSk7XG59O1xuXG5jbGFzcyBQZXJtYW5lbnRVc2VyRGF0YSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7WU1hcDxhbnk+fSBbc3RvcmVUeXBlXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYywgc3RvcmVUeXBlID0gZG9jLmdldE1hcCgndXNlcnMnKSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLERlbGV0ZVNldD59XG4gICAgICovXG4gICAgY29uc3QgZHNzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMueXVzZXJzID0gc3RvcmVUeXBlO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBjbGllbnRpZCB0byB1c2VyRGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZHNzID0gZHNzO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WU1hcDxhbnk+fSB1c2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJEZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGNvbnN0IGluaXRVc2VyID0gKHVzZXIsIHVzZXJEZXNjcmlwdGlvbikgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7WUFycmF5PFVpbnQ4QXJyYXk+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkcyA9IHVzZXIuZ2V0KCdkcycpO1xuICAgICAgY29uc3QgaWRzID0gdXNlci5nZXQoJ2lkcycpO1xuICAgICAgY29uc3QgYWRkQ2xpZW50SWQgPSAvKiogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkICovIGNsaWVudGlkID0+IHRoaXMuY2xpZW50cy5zZXQoY2xpZW50aWQsIHVzZXJEZXNjcmlwdGlvbik7XG4gICAgICBkcy5vYnNlcnZlKC8qKiBAcGFyYW0ge1lBcnJheUV2ZW50PGFueT59IGV2ZW50ICovIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQuY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkuZm9yRWFjaChlbmNvZGVkRHMgPT4ge1xuICAgICAgICAgICAgaWYgKGVuY29kZWREcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kc3Muc2V0KHVzZXJEZXNjcmlwdGlvbiwgbWVyZ2VEZWxldGVTZXRzKFt0aGlzLmRzcy5nZXQodXNlckRlc2NyaXB0aW9uKSB8fCBjcmVhdGVEZWxldGVTZXQoKSwgcmVhZERlbGV0ZVNldChuZXcgRFNEZWNvZGVyVjEoY3JlYXRlRGVjb2RlcihlbmNvZGVkRHMpKSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRzcy5zZXQodXNlckRlc2NyaXB0aW9uLCBtZXJnZURlbGV0ZVNldHMoZHMubWFwKGVuY29kZWREcyA9PiByZWFkRGVsZXRlU2V0KG5ldyBEU0RlY29kZXJWMShjcmVhdGVEZWNvZGVyKGVuY29kZWREcykpKSkpKTtcbiAgICAgIGlkcy5vYnNlcnZlKC8qKiBAcGFyYW0ge1lBcnJheUV2ZW50PGFueT59IGV2ZW50ICovIGV2ZW50ID0+XG4gICAgICAgIGV2ZW50LmNoYW5nZXMuYWRkZWQuZm9yRWFjaChpdGVtID0+IGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkuZm9yRWFjaChhZGRDbGllbnRJZCkpXG4gICAgICApO1xuICAgICAgaWRzLmZvckVhY2goYWRkQ2xpZW50SWQpO1xuICAgIH07XG4gICAgLy8gb2JzZXJ2ZSB1c2Vyc1xuICAgIHN0b3JlVHlwZS5vYnNlcnZlKGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LmtleXNDaGFuZ2VkLmZvckVhY2godXNlckRlc2NyaXB0aW9uID0+XG4gICAgICAgIGluaXRVc2VyKHN0b3JlVHlwZS5nZXQodXNlckRlc2NyaXB0aW9uKSwgdXNlckRlc2NyaXB0aW9uKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICAvLyBhZGQgaW50aWFsIGRhdGFcbiAgICBzdG9yZVR5cGUuZm9yRWFjaChpbml0VXNlcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJEZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZdXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24sIERlbGV0ZVNldCk6Ym9vbGVhbn0gW2NvbmYuZmlsdGVyXVxuICAgKi9cbiAgc2V0VXNlck1hcHBpbmcgKGRvYywgY2xpZW50aWQsIHVzZXJEZXNjcmlwdGlvbiwgeyBmaWx0ZXIgPSAoKSA9PiB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IHVzZXJzID0gdGhpcy55dXNlcnM7XG4gICAgbGV0IHVzZXIgPSB1c2Vycy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHVzZXIgPSBuZXcgWU1hcCgpO1xuICAgICAgdXNlci5zZXQoJ2lkcycsIG5ldyBZQXJyYXkoKSk7XG4gICAgICB1c2VyLnNldCgnZHMnLCBuZXcgWUFycmF5KCkpO1xuICAgICAgdXNlcnMuc2V0KHVzZXJEZXNjcmlwdGlvbiwgdXNlcik7XG4gICAgfVxuICAgIHVzZXIuZ2V0KCdpZHMnKS5wdXNoKFtjbGllbnRpZF0pO1xuICAgIHVzZXJzLm9ic2VydmUoZXZlbnQgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJPdmVyd3JpdGUgPSB1c2Vycy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHVzZXJPdmVyd3JpdGUgIT09IHVzZXIpIHtcbiAgICAgICAgICAvLyB1c2VyIHdhcyBvdmVyd3JpdHRlbiwgcG9ydCBhbGwgZGF0YSBvdmVyIHRvIHRoZSBuZXh0IHVzZXIgb2JqZWN0XG4gICAgICAgICAgLy8gQHRvZG8gRXhwZXJpbWVudCB3aXRoIFkuU2V0cyBoZXJlXG4gICAgICAgICAgdXNlciA9IHVzZXJPdmVyd3JpdGU7XG4gICAgICAgICAgLy8gQHRvZG8gaXRlcmF0ZSBvdmVyIG9sZCB0eXBlXG4gICAgICAgICAgdGhpcy5jbGllbnRzLmZvckVhY2goKF91c2VyRGVzY3JpcHRpb24sIGNsaWVudGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAodXNlckRlc2NyaXB0aW9uID09PSBfdXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgIHVzZXIuZ2V0KCdpZHMnKS5wdXNoKFtjbGllbnRpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjEoKTtcbiAgICAgICAgICBjb25zdCBkcyA9IHRoaXMuZHNzLmdldCh1c2VyRGVzY3JpcHRpb24pO1xuICAgICAgICAgIGlmIChkcykge1xuICAgICAgICAgICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICAgICAgICAgICAgdXNlci5nZXQoJ2RzJykucHVzaChbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfSk7XG4gICAgZG9jLm9uKCdhZnRlclRyYW5zYWN0aW9uJywgLyoqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uICovIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB5ZHMgPSB1c2VyLmdldCgnZHMnKTtcbiAgICAgICAgY29uc3QgZHMgPSB0cmFuc2FjdGlvbi5kZWxldGVTZXQ7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5sb2NhbCAmJiBkcy5jbGllbnRzLnNpemUgPiAwICYmIGZpbHRlcih0cmFuc2FjdGlvbiwgZHMpKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMSgpO1xuICAgICAgICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKTtcbiAgICAgICAgICB5ZHMucHVzaChbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWRcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZ2V0VXNlckJ5Q2xpZW50SWQgKGNsaWVudGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50cy5nZXQoY2xpZW50aWQpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgZ2V0VXNlckJ5RGVsZXRlZElkIChpZCkge1xuICAgIGZvciAoY29uc3QgW3VzZXJEZXNjcmlwdGlvbiwgZHNdIG9mIHRoaXMuZHNzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGlzRGVsZXRlZChkcywgaWQpKSB7XG4gICAgICAgIHJldHVybiB1c2VyRGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEEgcmVsYXRpdmUgcG9zaXRpb24gaXMgYmFzZWQgb24gdGhlIFlqcyBtb2RlbCBhbmQgaXMgbm90IGFmZmVjdGVkIGJ5IGRvY3VtZW50IGNoYW5nZXMuXG4gKiBFLmcuIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGJlZm9yZSBhIGNlcnRhaW4gY2hhcmFjdGVyLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGlzIGNoYXJhY3Rlci5cbiAqIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgYSB0eXBlLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGUgZW5kIG9mIHRoZSB0eXBlLlxuICpcbiAqIEEgbnVtZXJpYyBwb3NpdGlvbiBpcyBvZnRlbiB1bnN1aXRlZCBmb3IgdXNlciBzZWxlY3Rpb25zLCBiZWNhdXNlIGl0IGRvZXMgbm90IGNoYW5nZSB3aGVuIGNvbnRlbnQgaXMgaW5zZXJ0ZWRcbiAqIGJlZm9yZSBvciBhZnRlci5cbiAqXG4gKiBgYGBJbnNlcnQoMCwgJ3gnKSgnYXxiYycpID0gJ3hhfGJjJ2BgYCBXaGVyZSB8IGlzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAqXG4gKiBPbmUgb2YgdGhlIHByb3BlcnRpZXMgbXVzdCBiZSBkZWZpbmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGlzIGF0IHBvc2l0aW9uIDEwXG4gKiAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUluZGV4KHlUZXh0LCAxMClcbiAqICAgLy8gbW9kaWZ5IHlUZXh0XG4gKiAgIHlUZXh0Lmluc2VydCgwLCAnYWJjJylcbiAqICAgeVRleHQuZGVsZXRlKDMsIDEwKVxuICogICAvLyBDb21wdXRlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAqICAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbih5LCByZWxhdGl2ZVBvc2l0aW9uKVxuICogICBhYnNvbHV0ZVBvc2l0aW9uLnR5cGUgPT09IHlUZXh0IC8vID0+IHRydWVcbiAqICAgY29uc29sZS5sb2coJ2N1cnNvciBsb2NhdGlvbiBpcyAnICsgYWJzb2x1dGVQb3NpdGlvbi5pbmRleCkgLy8gPT4gY3Vyc29yIGxvY2F0aW9uIGlzIDNcbiAqXG4gKi9cbmNsYXNzIFJlbGF0aXZlUG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJRHxudWxsfSB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRuYW1lXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gaXRlbVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXNzb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCB0bmFtZSwgaXRlbSwgYXNzb2MgPSAwKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEfG51bGx9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy50bmFtZSA9IHRuYW1lO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAvKipcbiAgICAgKiBBIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gYSBzcGVjaWZpYyBjaGFyYWN0ZXIuIEJ5IGRlZmF1bHRcbiAgICAgKiBhc3NvYyA+PSAwLCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byB0aGUgY2hhcmFjdGVyXG4gICAgICogYWZ0ZXIgdGhlIG1lYW50IHBvc2l0aW9uLlxuICAgICAqIEkuZS4gcG9zaXRpb24gMSBpbiAnYWInIGlzIGFzc29jaWF0ZWQgdG8gY2hhcmFjdGVyICdiJy5cbiAgICAgKlxuICAgICAqIElmIGFzc29jIDwgMCwgdGhlbiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byB0aGUgY2FoYXJhY3RlclxuICAgICAqIGJlZm9yZSB0aGUgbWVhbnQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7YW55fVxuICovXG5jb25zdCByZWxhdGl2ZVBvc2l0aW9uVG9KU09OID0gcnBvcyA9PiB7XG4gIGNvbnN0IGpzb24gPSB7fTtcbiAgaWYgKHJwb3MudHlwZSkge1xuICAgIGpzb24udHlwZSA9IHJwb3MudHlwZTtcbiAgfVxuICBpZiAocnBvcy50bmFtZSkge1xuICAgIGpzb24udG5hbWUgPSBycG9zLnRuYW1lO1xuICB9XG4gIGlmIChycG9zLml0ZW0pIHtcbiAgICBqc29uLml0ZW0gPSBycG9zLml0ZW07XG4gIH1cbiAgaWYgKHJwb3MuYXNzb2MgIT0gbnVsbCkge1xuICAgIGpzb24uYXNzb2MgPSBycG9zLmFzc29jO1xuICB9XG4gIHJldHVybiBqc29uXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBqc29uXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04gPSBqc29uID0+IG5ldyBSZWxhdGl2ZVBvc2l0aW9uKGpzb24udHlwZSA9PSBudWxsID8gbnVsbCA6IGNyZWF0ZUlEKGpzb24udHlwZS5jbGllbnQsIGpzb24udHlwZS5jbG9jayksIGpzb24udG5hbWUgfHwgbnVsbCwganNvbi5pdGVtID09IG51bGwgPyBudWxsIDogY3JlYXRlSUQoanNvbi5pdGVtLmNsaWVudCwganNvbi5pdGVtLmNsb2NrKSwganNvbi5hc3NvYyA9PSBudWxsID8gMCA6IGpzb24uYXNzb2MpO1xuXG5jbGFzcyBBYnNvbHV0ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbiA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiBuZXcgQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgYXNzb2MpO1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7SUR8bnVsbH0gaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtLCBhc3NvYykgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbDtcbiAgbGV0IHRuYW1lID0gbnVsbDtcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IGZpbmRSb290VHlwZUtleSh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlaWQgPSBjcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jayk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZVBvc2l0aW9uKHR5cGVpZCwgdG5hbWUsIGl0ZW0sIGFzc29jKVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWxhdGl2ZVBvc2l0aW9uIGJhc2VkIG9uIGEgYWJzb2x1dGUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZSBUaGUgYmFzZSB0eXBlIChlLmcuIFlUZXh0IG9yIFlBcnJheSkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGFic29sdXRlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4ID0gKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApID0+IHtcbiAgbGV0IHQgPSB0eXBlLl9zdGFydDtcbiAgaWYgKGFzc29jIDwgMCkge1xuICAgIC8vIGFzc29jaWF0ZWQgdG8gdGhlIGxlZnQgY2hhcmFjdGVyIG9yIHRoZSBiZWdpbm5pbmcgb2YgYSB0eXBlLCBpbmNyZW1lbnQgaW5kZXggaWYgcG9zc2libGUuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBudWxsLCBhc3NvYylcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxuICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgIGlmICghdC5kZWxldGVkICYmIHQuY291bnRhYmxlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgY3JlYXRlSUQodC5pZC5jbGllbnQsIHQuaWQuY2xvY2sgKyBpbmRleCksIGFzc29jKVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gdC5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0LnJpZ2h0ID09PSBudWxsICYmIGFzc29jIDwgMCkge1xuICAgICAgLy8gbGVmdC1hc3NvY2lhdGVkIHBvc2l0aW9uLCByZXR1cm4gbGFzdCBhdmFpbGFibGUgaWRcbiAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIHQubGFzdElkLCBhc3NvYylcbiAgICB9XG4gICAgdCA9IHQucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlUmVsYXRpdmVQb3NpdGlvbiA9IChlbmNvZGVyLCBycG9zKSA9PiB7XG4gIGNvbnN0IHsgdHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jIH0gPSBycG9zO1xuICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCAwKTtcbiAgICB3cml0ZUlEKGVuY29kZXIsIGl0ZW0pO1xuICB9IGVsc2UgaWYgKHRuYW1lICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgd3JpdGVVaW50OChlbmNvZGVyLCAxKTtcbiAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCB0bmFtZSk7XG4gIH0gZWxzZSBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgIC8vIGNhc2UgMzogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBhdHRhY2hlZCB0byBhbiBpdGVtXG4gICAgd3JpdGVVaW50OChlbmNvZGVyLCAyKTtcbiAgICB3cml0ZUlEKGVuY29kZXIsIHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbiAgfVxuICB3cml0ZVZhckludChlbmNvZGVyLCBhc3NvYyk7XG4gIHJldHVybiBlbmNvZGVyXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlUmVsYXRpdmVQb3NpdGlvbiA9IHJwb3MgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICB3cml0ZVJlbGF0aXZlUG9zaXRpb24oZW5jb2RlciwgcnBvcyk7XG4gIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn07XG5cbi8qKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkUmVsYXRpdmVQb3NpdGlvbiA9IGRlY29kZXIgPT4ge1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCB0bmFtZSA9IG51bGw7XG4gIGxldCBpdGVtSUQgPSBudWxsO1xuICBzd2l0Y2ggKHJlYWRWYXJVaW50KGRlY29kZXIpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgLy8gY2FzZSAxOiBmb3VuZCBwb3NpdGlvbiBzb21ld2hlcmUgaW4gdGhlIGxpbmtlZCBsaXN0XG4gICAgICBpdGVtSUQgPSByZWFkSUQoZGVjb2Rlcik7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTpcbiAgICAgIC8vIGNhc2UgMjogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBzdG9yZWQgaW4geS5zaGFyZVxuICAgICAgdG5hbWUgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6IHtcbiAgICAgIC8vIGNhc2UgMzogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBhdHRhY2hlZCB0byBhbiBpdGVtXG4gICAgICB0eXBlID0gcmVhZElEKGRlY29kZXIpO1xuICAgIH1cbiAgfVxuICBjb25zdCBhc3NvYyA9IGhhc0NvbnRlbnQoZGVjb2RlcikgPyByZWFkVmFySW50KGRlY29kZXIpIDogMDtcbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIHRuYW1lLCBpdGVtSUQsIGFzc29jKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKi9cbmNvbnN0IGRlY29kZVJlbGF0aXZlUG9zaXRpb24gPSB1aW50OEFycmF5ID0+IHJlYWRSZWxhdGl2ZVBvc2l0aW9uKGNyZWF0ZURlY29kZXIodWludDhBcnJheSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHJldHVybiB7QWJzb2x1dGVQb3NpdGlvbnxudWxsfVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24gPSAocnBvcywgZG9jKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCByaWdodElEID0gcnBvcy5pdGVtO1xuICBjb25zdCB0eXBlSUQgPSBycG9zLnR5cGU7XG4gIGNvbnN0IHRuYW1lID0gcnBvcy50bmFtZTtcbiAgY29uc3QgYXNzb2MgPSBycG9zLmFzc29jO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCBpbmRleCA9IDA7XG4gIGlmIChyaWdodElEICE9PSBudWxsKSB7XG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCByaWdodElELmNsaWVudCkgPD0gcmlnaHRJRC5jbG9jaykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgY29uc3QgcmVzID0gZm9sbG93UmVkb25lKHN0b3JlLCByaWdodElEKTtcbiAgICBjb25zdCByaWdodCA9IHJlcy5pdGVtO1xuICAgIGlmICghKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KTtcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgICBpbmRleCA9IChyaWdodC5kZWxldGVkIHx8ICFyaWdodC5jb3VudGFibGUpID8gMCA6IChyZXMuZGlmZiArIChhc3NvYyA+PSAwID8gMCA6IDEpKTsgLy8gYWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9uIGxlZnQgYXNzb2NpYXRpb24gaWYgbmVjZXNzYXJ5XG4gICAgICBsZXQgbiA9IHJpZ2h0LmxlZnQ7XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgICAgIGluZGV4ICs9IG4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuLmxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IGRvYy5nZXQodG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZUlEICE9PSBudWxsKSB7XG4gICAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHR5cGVJRC5jbGllbnQpIDw9IHR5cGVJRC5jbG9jaykge1xuICAgICAgICAvLyB0eXBlIGRvZXMgbm90IGV4aXN0IHlldFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY29uc3QgeyBpdGVtIH0gPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHR5cGVJRCk7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgaXRlbS5jb250ZW50IGluc3RhbmNlb2YgQ29udGVudFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGl0ZW0uY29udGVudC50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RydWN0IGlzIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKGFzc29jID49IDApIHtcbiAgICAgIGluZGV4ID0gdHlwZS5fbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uKHR5cGUsIGluZGV4LCBycG9zLmFzc29jKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYVxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyA9IChhLCBiKSA9PiBhID09PSBiIHx8IChcbiAgYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEudG5hbWUgPT09IGIudG5hbWUgJiYgY29tcGFyZUlEcyhhLml0ZW0sIGIuaXRlbSkgJiYgY29tcGFyZUlEcyhhLnR5cGUsIGIudHlwZSkgJiYgYS5hc3NvYyA9PT0gYi5hc3NvY1xuKTtcblxuY2xhc3MgU25hcHNob3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gICAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzdiBzdGF0ZSBtYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkcywgc3YpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RGVsZXRlU2V0fVxuICAgICAqL1xuICAgIHRoaXMuZHMgPSBkcztcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBNYXBcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuc3YgPSBzdjtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAxXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwMlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxTbmFwc2hvdHMgPSAoc25hcDEsIHNuYXAyKSA9PiB7XG4gIGNvbnN0IGRzMSA9IHNuYXAxLmRzLmNsaWVudHM7XG4gIGNvbnN0IGRzMiA9IHNuYXAyLmRzLmNsaWVudHM7XG4gIGNvbnN0IHN2MSA9IHNuYXAxLnN2O1xuICBjb25zdCBzdjIgPSBzbmFwMi5zdjtcbiAgaWYgKHN2MS5zaXplICE9PSBzdjIuc2l6ZSB8fCBkczEuc2l6ZSAhPT0gZHMyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdjEuZW50cmllcygpKSB7XG4gICAgaWYgKHN2Mi5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRzaXRlbXMxXSBvZiBkczEuZW50cmllcygpKSB7XG4gICAgY29uc3QgZHNpdGVtczIgPSBkczIuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgaWYgKGRzaXRlbXMxLmxlbmd0aCAhPT0gZHNpdGVtczIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkc2l0ZW1zMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZHNpdGVtMSA9IGRzaXRlbXMxW2ldO1xuICAgICAgY29uc3QgZHNpdGVtMiA9IGRzaXRlbXMyW2ldO1xuICAgICAgaWYgKGRzaXRlbTEuY2xvY2sgIT09IGRzaXRlbTIuY2xvY2sgfHwgZHNpdGVtMS5sZW4gIT09IGRzaXRlbTIubGVuKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVNuYXBzaG90VjIgPSAoc25hcHNob3QsIGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjIoKSkgPT4ge1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBzbmFwc2hvdC5kcyk7XG4gIHdyaXRlU3RhdGVWZWN0b3IoZW5jb2Rlciwgc25hcHNob3Quc3YpO1xuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU25hcHNob3QgPSBzbmFwc2hvdCA9PiBlbmNvZGVTbmFwc2hvdFYyKHNuYXBzaG90LCBuZXcgRFNFbmNvZGVyVjEoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gW2RlY29kZXJdXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3QgZGVjb2RlU25hcHNob3RWMiA9IChidWYsIGRlY29kZXIgPSBuZXcgRFNEZWNvZGVyVjIoY3JlYXRlRGVjb2RlcihidWYpKSkgPT4ge1xuICByZXR1cm4gbmV3IFNuYXBzaG90KHJlYWREZWxldGVTZXQoZGVjb2RlciksIHJlYWRTdGF0ZVZlY3RvcihkZWNvZGVyKSlcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBkZWNvZGVTbmFwc2hvdCA9IGJ1ZiA9PiBkZWNvZGVTbmFwc2hvdFYyKGJ1ZiwgbmV3IERTRGVjb2RlclYxKGNyZWF0ZURlY29kZXIoYnVmKSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHNtXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3QgY3JlYXRlU25hcHNob3QgPSAoZHMsIHNtKSA9PiBuZXcgU25hcHNob3QoZHMsIHNtKTtcblxuY29uc3QgZW1wdHlTbmFwc2hvdCA9IGNyZWF0ZVNuYXBzaG90KGNyZWF0ZURlbGV0ZVNldCgpLCBuZXcgTWFwKCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBzbmFwc2hvdCA9IGRvYyA9PiBjcmVhdGVTbmFwc2hvdChjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUoZG9jLnN0b3JlKSwgZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKSk7XG5cbi8qKlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1NuYXBzaG90fHVuZGVmaW5lZH0gc25hcHNob3RcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXNWaXNpYmxlID0gKGl0ZW0sIHNuYXBzaG90KSA9PiBzbmFwc2hvdCA9PT0gdW5kZWZpbmVkID8gIWl0ZW0uZGVsZXRlZCA6IChcbiAgc25hcHNob3Quc3YuaGFzKGl0ZW0uaWQuY2xpZW50KSAmJiAoc25hcHNob3Quc3YuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSA+IGl0ZW0uaWQuY2xvY2sgJiYgIWlzRGVsZXRlZChzbmFwc2hvdC5kcywgaXRlbS5pZClcbik7XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKi9cbmNvbnN0IHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IG1ldGEgPSBzZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5tZXRhLCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzLCBjcmVhdGUkMSk7XG4gIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24uZG9jLnN0b3JlO1xuICAvLyBjaGVjayBpZiB3ZSBhbHJlYWR5IHNwbGl0IGZvciB0aGlzIHNuYXBzaG90XG4gIGlmICghbWV0YS5oYXMoc25hcHNob3QpKSB7XG4gICAgc25hcHNob3Quc3YuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHNuYXBzaG90LmRzLCBpdGVtID0+IHt9KTtcbiAgICBtZXRhLmFkZChzbmFwc2hvdCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb2N9IG9yaWdpbkRvY1xuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7RG9jfSBbbmV3RG9jXSBPcHRpb25hbGx5LCB5b3UgbWF5IGRlZmluZSB0aGUgWWpzIGRvY3VtZW50IHRoYXQgcmVjZWl2ZXMgdGhlIGRhdGEgZnJvbSBvcmlnaW5Eb2NcbiAqIEByZXR1cm4ge0RvY31cbiAqL1xuY29uc3QgY3JlYXRlRG9jRnJvbVNuYXBzaG90ID0gKG9yaWdpbkRvYywgc25hcHNob3QsIG5ld0RvYyA9IG5ldyBEb2MoKSkgPT4ge1xuICBpZiAob3JpZ2luRG9jLmdjKSB7XG4gICAgLy8gd2Ugc2hvdWxkIG5vdCB0cnkgdG8gcmVzdG9yZSBhIEdDLWVkIGRvY3VtZW50LCBiZWNhdXNlIHNvbWUgb2YgdGhlIHJlc3RvcmVkIGl0ZW1zIG1pZ2h0IGhhdmUgdGhlaXIgY29udGVudCBkZWxldGVkXG4gICAgdGhyb3cgbmV3IEVycm9yKCdvcmlnaW5Eb2MgbXVzdCBub3QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQnKVxuICB9XG4gIGNvbnN0IHsgc3YsIGRzIH0gPSBzbmFwc2hvdDtcblxuICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpO1xuICBvcmlnaW5Eb2MudHJhbnNhY3QodHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBzdi5mb3JFYWNoKGNsb2NrID0+IHtcbiAgICAgIGlmIChjbG9jayA+IDApIHtcbiAgICAgICAgc2l6ZSsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzaXplKTtcbiAgICAvLyBzcGxpdHRpbmcgdGhlIHN0cnVjdHMgYmVmb3JlIHdyaXRpbmcgdGhlbSB0byB0aGUgZW5jb2RlclxuICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHN2KSB7XG4gICAgICBpZiAoY2xvY2sgPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjbG9jayA8IGdldFN0YXRlKG9yaWdpbkRvYy5zdG9yZSwgY2xpZW50KSkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBjbG9jaykpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RydWN0cyA9IG9yaWdpbkRvYy5zdG9yZS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdO1xuICAgICAgY29uc3QgbGFzdFN0cnVjdEluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2sgLSAxKTtcbiAgICAgIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgbGFzdFN0cnVjdEluZGV4ICsgMSk7XG4gICAgICBlbmNvZGVyLndyaXRlQ2xpZW50KGNsaWVudCk7XG4gICAgICAvLyBmaXJzdCBjbG9jayB3cml0dGVuIGlzIDBcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RTdHJ1Y3RJbmRleDsgaSsrKSB7XG4gICAgICAgIHN0cnVjdHNbaV0ud3JpdGUoZW5jb2RlciwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKTtcbiAgfSk7XG5cbiAgYXBwbHlVcGRhdGVWMihuZXdEb2MsIGVuY29kZXIudG9VaW50OEFycmF5KCksICdzbmFwc2hvdCcpO1xuICByZXR1cm4gbmV3RG9jXG59O1xuXG5jbGFzcyBTdHJ1Y3RTdG9yZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixBcnJheTxHQ3xJdGVtPj59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgeyBtaXNzaW5nOiBNYXA8bnVtYmVyLCBudW1iZXI+LCB1cGRhdGU6IFVpbnQ4QXJyYXkgfX1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdTdHJ1Y3RzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IFVpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nRHMgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdGF0ZXMgYXMgYSBNYXA8Y2xpZW50LGNsb2NrPi5cbiAqIE5vdGUgdGhhdCBjbG9jayByZWZlcnMgdG8gdGhlIG5leHQgZXhwZWN0ZWQgY2xvY2sgaWQuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn1cbiAqXG4gKiBAcHVibGljXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0U3RhdGVWZWN0b3IgPSBzdG9yZSA9PiB7XG4gIGNvbnN0IHNtID0gbmV3IE1hcCgpO1xuICBzdG9yZS5jbGllbnRzLmZvckVhY2goKHN0cnVjdHMsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXTtcbiAgICBzbS5zZXQoY2xpZW50LCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKTtcbiAgfSk7XG4gIHJldHVybiBzbVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHJldHVybiB7bnVtYmVyfVxuICpcbiAqIEBwdWJsaWNcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRTdGF0ZSA9IChzdG9yZSwgY2xpZW50KSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpO1xuICBpZiAoc3RydWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBjb25zdCBsYXN0U3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbGFzdFN0cnVjdC5pZC5jbG9jayArIGxhc3RTdHJ1Y3QubGVuZ3RoXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0dDfEl0ZW19IHN0cnVjdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYWRkU3RydWN0ID0gKHN0b3JlLCBzdHJ1Y3QpID0+IHtcbiAgbGV0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChzdHJ1Y3QuaWQuY2xpZW50KTtcbiAgaWYgKHN0cnVjdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cnVjdHMgPSBbXTtcbiAgICBzdG9yZS5jbGllbnRzLnNldChzdHJ1Y3QuaWQuY2xpZW50LCBzdHJ1Y3RzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsYXN0U3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGggIT09IHN0cnVjdC5pZC5jbG9jaykge1xuICAgICAgdGhyb3cgdW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgfVxuICBzdHJ1Y3RzLnB1c2goc3RydWN0KTtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHJldHVybiB7bnVtYmVyfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZEluZGV4U1MgPSAoc3RydWN0cywgY2xvY2spID0+IHtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgcmlnaHQgPSBzdHJ1Y3RzLmxlbmd0aCAtIDE7XG4gIGxldCBtaWQgPSBzdHJ1Y3RzW3JpZ2h0XTtcbiAgbGV0IG1pZGNsb2NrID0gbWlkLmlkLmNsb2NrO1xuICBpZiAobWlkY2xvY2sgPT09IGNsb2NrKSB7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cbiAgLy8gQHRvZG8gZG9lcyBpdCBldmVuIG1ha2Ugc2Vuc2UgdG8gcGl2b3QgdGhlIHNlYXJjaD9cbiAgLy8gSWYgYSBnb29kIHNwbGl0IG1pc3NlcywgaXQgbWlnaHQgYWN0dWFsbHkgaW5jcmVhc2UgdGhlIHRpbWUgdG8gZmluZCB0aGUgY29ycmVjdCBpdGVtLlxuICAvLyBDdXJyZW50bHksIHRoZSBvbmx5IGFkdmFudGFnZSBpcyB0aGF0IHNlYXJjaCB3aXRoIHBpdm90aW5nIG1pZ2h0IGZpbmQgdGhlIGl0ZW0gb24gdGhlIGZpcnN0IHRyeS5cbiAgbGV0IG1pZGluZGV4ID0gZmxvb3IoKGNsb2NrIC8gKG1pZGNsb2NrICsgbWlkLmxlbmd0aCAtIDEpKSAqIHJpZ2h0KTsgLy8gcGl2b3RpbmcgdGhlIHNlYXJjaFxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIG1pZCA9IHN0cnVjdHNbbWlkaW5kZXhdO1xuICAgIG1pZGNsb2NrID0gbWlkLmlkLmNsb2NrO1xuICAgIGlmIChtaWRjbG9jayA8PSBjbG9jaykge1xuICAgICAgaWYgKGNsb2NrIDwgbWlkY2xvY2sgKyBtaWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtaWRpbmRleFxuICAgICAgfVxuICAgICAgbGVmdCA9IG1pZGluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWRpbmRleCAtIDE7XG4gICAgfVxuICAgIG1pZGluZGV4ID0gZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuICAvLyBBbHdheXMgY2hlY2sgc3RhdGUgYmVmb3JlIGxvb2tpbmcgZm9yIGEgc3RydWN0IGluIFN0cnVjdFN0b3JlXG4gIC8vIFRoZXJlZm9yZSB0aGUgY2FzZSBvZiBub3QgZmluZGluZyBhIHN0cnVjdCBpcyB1bmV4cGVjdGVkXG4gIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbn07XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0dDfEl0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4U1Moc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtID0gLyoqIEB0eXBlIHtmdW5jdGlvbihTdHJ1Y3RTdG9yZSxJRCk6SXRlbX0gKi8gKGZpbmQpO1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqL1xuY29uc3QgZmluZEluZGV4Q2xlYW5TdGFydCA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2spID0+IHtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2sgJiYgc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgcmV0dXJuIGluZGV4ICsgMVxuICB9XG4gIHJldHVybiBpbmRleFxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW1DbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBpZCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpKTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtQ2xlYW5FbmQgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoaWQuY2xvY2sgIT09IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGggLSAxICYmIHN0cnVjdC5jb25zdHJ1Y3RvciAhPT0gR0MpIHtcbiAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpZC5jbG9jayAtIHN0cnVjdC5pZC5jbG9jayArIDEpKTtcbiAgfVxuICByZXR1cm4gc3RydWN0XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYGl0ZW1gIHdpdGggYG5ld2l0ZW1gIGluIHN0b3JlXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7R0N8SXRlbX0gbmV3U3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZXBsYWNlU3RydWN0ID0gKHN0b3JlLCBzdHJ1Y3QsIG5ld1N0cnVjdCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpKTtcbiAgc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBzdHJ1Y3QuaWQuY2xvY2spXSA9IG5ld1N0cnVjdDtcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2Ygc3RydWN0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tTdGFydCBJbmNsdXNpdmUgc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oR0N8SXRlbSk6dm9pZH0gZlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpdGVyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydCwgbGVuLCBmKSA9PiB7XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrU3RhcnQgKyBsZW47XG4gIGxldCBpbmRleCA9IGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrU3RhcnQpO1xuICBsZXQgc3RydWN0O1xuICBkbyB7XG4gICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICBpZiAoY2xvY2tFbmQgPCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKSB7XG4gICAgICBmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja0VuZCk7XG4gICAgfVxuICAgIGYoc3RydWN0KTtcbiAgfSB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3RzW2luZGV4XS5pZC5jbG9jayA8IGNsb2NrRW5kKVxufTtcblxuLyoqXG4gKiBBIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGNoYW5nZSBvbiB0aGUgWWpzIG1vZGVsLiBJdCBpcyBwb3NzaWJsZVxuICogdG8gYnVuZGxlIGNoYW5nZXMgb24gdGhlIFlqcyBtb2RlbCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiB0b1xuICogbWluaW1pemUgdGhlIG51bWJlciBvbiBtZXNzYWdlcyBzZW50IGFuZCB0aGUgbnVtYmVyIG9mIG9ic2VydmVyIGNhbGxzLlxuICogSWYgcG9zc2libGUgdGhlIHVzZXIgb2YgdGhpcyBsaWJyYXJ5IHNob3VsZCBidW5kbGUgYXMgbWFueSBjaGFuZ2VzIGFzXG4gKiBwb3NzaWJsZS4gSGVyZSBpcyBhbiBleGFtcGxlIHRvIGlsbHVzdHJhdGUgdGhlIGFkdmFudGFnZXMgb2YgYnVuZGxpbmc6XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1hcCA9IHkuZGVmaW5lKCdtYXAnLCBZTWFwKVxuICogLy8gTG9nIGNvbnRlbnQgd2hlbiBjaGFuZ2UgaXMgdHJpZ2dlcmVkXG4gKiBtYXAub2JzZXJ2ZSgoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdjaGFuZ2UgdHJpZ2dlcmVkJylcbiAqIH0pXG4gKiAvLyBFYWNoIGNoYW5nZSBvbiB0aGUgbWFwIHR5cGUgdHJpZ2dlcnMgYSBsb2cgbWVzc2FnZTpcbiAqIG1hcC5zZXQoJ2EnLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogbWFwLnNldCgnYicsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKiAvLyBXaGVuIHB1dCBpbiBhIHRyYW5zYWN0aW9uLCBpdCB3aWxsIHRyaWdnZXIgdGhlIGxvZyBhZnRlciB0aGUgdHJhbnNhY3Rpb246XG4gKiB5LnRyYW5zYWN0KCgpID0+IHtcbiAqICAgbWFwLnNldCgnYScsIDEpXG4gKiAgIG1hcC5zZXQoJ2InLCAxKVxuICogfSkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBvcmlnaW4sIGxvY2FsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFlqcyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB0aGUgc2V0IG9mIGRlbGV0ZWQgaXRlbXMgYnkgaWRzXG4gICAgICogQHR5cGUge0RlbGV0ZVNldH1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVNldCA9IG5ldyBEZWxldGVTZXQoKTtcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgc3RhdGUgYmVmb3JlIHRoZSB0cmFuc2FjdGlvbiBzdGFydGVkLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSk7XG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBBbGwgdHlwZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IG1vZGlmaWVkIChwcm9wZXJ0eSBhZGRlZCBvciBjaGlsZFxuICAgICAqIGluc2VydGVkL2RlbGV0ZWQpLiBOZXcgdHlwZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGlzIFNldC5cbiAgICAgKiBNYXBzIGZyb20gdHlwZSB0byBwYXJlbnRTdWJzIChgaXRlbS5wYXJlbnRTdWIgPSBudWxsYCBmb3IgWUFycmF5KVxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudD4sU2V0PFN0cmluZ3xudWxsPj59XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgZXZlbnRzIGZvciB0aGUgdHlwZXMgdGhhdCBvYnNlcnZlIGFsc28gY2hpbGQgZWxlbWVudHMuXG4gICAgICogSXQgaXMgbWFpbmx5IHVzZWQgYnkgYG9ic2VydmVEZWVwYC5cbiAgICAgKiBAdHlwZSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ+LEFycmF5PFlFdmVudD4+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZFBhcmVudFR5cGVzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59XG4gICAgICovXG4gICAgdGhpcy5fbWVyZ2VTdHJ1Y3RzID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgbWV0YSBpbmZvcm1hdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAdHlwZSB7TWFwPGFueSxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgY2hhbmdlIG9yaWdpbmF0ZXMgZnJvbSB0aGlzIGRvYy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc0FkZGVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NSZW1vdmVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NMb2FkZWQgPSBuZXcgU2V0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgZGF0YSB3YXMgd3JpdHRlbi5cbiAqL1xuY29uc3Qgd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB7XG4gIGlmICh0cmFuc2FjdGlvbi5kZWxldGVTZXQuY2xpZW50cy5zaXplID09PSAwICYmICFhbnkodHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZSwgKGNsb2NrLCBjbGllbnQpID0+IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpICE9PSBjbG9jaykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0KTtcbiAgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKTtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0KTtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogSWYgYHR5cGUucGFyZW50YCB3YXMgYWRkZWQgaW4gY3VycmVudCB0cmFuc2FjdGlvbiwgYHR5cGVgIHRlY2huaWNhbGx5XG4gKiBkaWQgbm90IGNoYW5nZSwgaXQgd2FzIGp1c3QgYWRkZWQgYW5kIHdlIHNob3VsZCBub3QgZmlyZSBldmVudHMgZm9yIGB0eXBlYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8WUV2ZW50Pn0gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gcGFyZW50U3ViXG4gKi9cbmNvbnN0IGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbiwgdHlwZSwgcGFyZW50U3ViKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSB0eXBlLl9pdGVtO1xuICBpZiAoaXRlbSA9PT0gbnVsbCB8fCAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApICYmICFpdGVtLmRlbGV0ZWQpKSB7XG4gICAgc2V0SWZVbmRlZmluZWQodHJhbnNhY3Rpb24uY2hhbmdlZCwgdHlwZSwgY3JlYXRlJDEpLmFkZChwYXJlbnRTdWIpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QWJzdHJhY3RTdHJ1Y3Q+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gKi9cbmNvbnN0IHRyeVRvTWVyZ2VXaXRoTGVmdCA9IChzdHJ1Y3RzLCBwb3MpID0+IHtcbiAgY29uc3QgbGVmdCA9IHN0cnVjdHNbcG9zIC0gMV07XG4gIGNvbnN0IHJpZ2h0ID0gc3RydWN0c1twb3NdO1xuICBpZiAobGVmdC5kZWxldGVkID09PSByaWdodC5kZWxldGVkICYmIGxlZnQuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKGxlZnQubWVyZ2VXaXRoKHJpZ2h0KSkge1xuICAgICAgc3RydWN0cy5zcGxpY2UocG9zLCAxKTtcbiAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEl0ZW0gJiYgcmlnaHQucGFyZW50U3ViICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuZ2V0KHJpZ2h0LnBhcmVudFN1YikgPT09IHJpZ2h0KSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0LnBhcmVudFN1YiwgLyoqIEB0eXBlIHtJdGVtfSAqLyAobGVmdCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjRGVsZXRlU2V0ID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgZm9yIChjb25zdCBbY2xpZW50LCBkZWxldGVJdGVtc10gb2YgZHMuY2xpZW50cy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXTtcbiAgICAgIGNvbnN0IGVuZERlbGV0ZUl0ZW1DbG9jayA9IGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbjtcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGRlbGV0ZUl0ZW0uY2xvY2spLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBlbmREZWxldGVJdGVtQ2xvY2s7XG4gICAgICAgIHN0cnVjdCA9IHN0cnVjdHNbKytzaV1cbiAgICAgICkge1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgaWYgKGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbiA8PSBzdHJ1Y3QuaWQuY2xvY2spIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtICYmIHN0cnVjdC5kZWxldGVkICYmICFzdHJ1Y3Qua2VlcCAmJiBnY0ZpbHRlcihzdHJ1Y3QpKSB7XG4gICAgICAgICAgc3RydWN0LmdjKHN0b3JlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICovXG5jb25zdCB0cnlNZXJnZURlbGV0ZVNldCA9IChkcywgc3RvcmUpID0+IHtcbiAgLy8gdHJ5IHRvIG1lcmdlIGRlbGV0ZWQgLyBnYydkIGl0ZW1zXG4gIC8vIG1lcmdlIGZyb20gcmlnaHQgdG8gbGVmdCBmb3IgYmV0dGVyIGVmZmljaWVjeSBhbmQgc28gd2UgZG9uJ3QgbWlzcyBhbnkgbWVyZ2UgdGFyZ2V0c1xuICBkcy5jbGllbnRzLmZvckVhY2goKGRlbGV0ZUl0ZW1zLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXTtcbiAgICAgIC8vIHN0YXJ0IHdpdGggbWVyZ2luZyB0aGUgaXRlbSBuZXh0IHRvIHRoZSBsYXN0IGRlbGV0ZWQgaXRlbVxuICAgICAgY29uc3QgbW9zdFJpZ2h0SW5kZXhUb0NoZWNrID0gbWluKHN0cnVjdHMubGVuZ3RoIC0gMSwgMSArIGZpbmRJbmRleFNTKHN0cnVjdHMsIGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbiAtIDEpKTtcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IG1vc3RSaWdodEluZGV4VG9DaGVjaywgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIHNpID4gMCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPj0gZGVsZXRlSXRlbS5jbG9jaztcbiAgICAgICAgc3RydWN0ID0gc3RydWN0c1stLXNpXVxuICAgICAgKSB7XG4gICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCBzaSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBnY0ZpbHRlclxuICovXG5jb25zdCB0cnlHYyA9IChkcywgc3RvcmUsIGdjRmlsdGVyKSA9PiB7XG4gIHRyeUdjRGVsZXRlU2V0KGRzLCBzdG9yZSwgZ2NGaWx0ZXIpO1xuICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uPn0gdHJhbnNhY3Rpb25DbGVhbnVwc1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuY29uc3QgY2xlYW51cFRyYW5zYWN0aW9ucyA9ICh0cmFuc2FjdGlvbkNsZWFudXBzLCBpKSA9PiB7XG4gIGlmIChpIDwgdHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGgpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uQ2xlYW51cHNbaV07XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgIGNvbnN0IGRzID0gdHJhbnNhY3Rpb24uZGVsZXRlU2V0O1xuICAgIGNvbnN0IG1lcmdlU3RydWN0cyA9IHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHM7XG4gICAgdHJ5IHtcbiAgICAgIHNvcnRBbmRNZXJnZURlbGV0ZVNldChkcyk7XG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlID0gZ2V0U3RhdGVWZWN0b3IodHJhbnNhY3Rpb24uZG9jLnN0b3JlKTtcbiAgICAgIGRvYy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZU9ic2VydmVyQ2FsbHMnLCBbdHJhbnNhY3Rpb24sIGRvY10pO1xuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgKlxuICAgICAgICogRWFjaCBjYWxsYmFjayBpcyBjYWxsZWQgZXZlbiBpZiB0aGUgb3RoZXIgb25lcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZzID0gW107XG4gICAgICAvLyBvYnNlcnZlIGV2ZW50cyBvbiBjaGFuZ2VkIHR5cGVzXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YnMsIGl0ZW10eXBlKSA9PlxuICAgICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbXR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIWl0ZW10eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGl0ZW10eXBlLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHN1YnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgLy8gZGVlcCBvYnNlcnZlIGV2ZW50c1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRzLCB0eXBlKSA9PlxuICAgICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0aGluayBhYm91dCB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgdXNlciB0cmFuc2Zvcm1zIHRoZVxuICAgICAgICAgICAgLy8gWS5Eb2MgaW4gdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICBldmVudHMgPSBldmVudHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGV2ZW50ID0+XG4gICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuX2l0ZW0gPT09IG51bGwgfHwgIWV2ZW50LnRhcmdldC5faXRlbS5kZWxldGVkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZXZlbnRzXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIHNvcnQgZXZlbnRzIGJ5IHBhdGggbGVuZ3RoIHNvIHRoYXQgdG9wLWxldmVsIGV2ZW50cyBhcmUgZmlyZWQgZmlyc3QuXG4gICAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAgIC5zb3J0KChldmVudDEsIGV2ZW50MikgPT4gZXZlbnQxLnBhdGgubGVuZ3RoIC0gZXZlbnQyLnBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgZXZlbnRzLmxlbmd0aFxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGtub3cgaXQgaGFzIGF0IGxlYXN0IG9uZSBlbGVtZW50XG4gICAgICAgICAgICAgIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnModHlwZS5fZEVILCBldmVudHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmcy5wdXNoKCgpID0+IGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uJywgW3RyYW5zYWN0aW9uLCBkb2NdKSk7XG4gICAgICB9KTtcbiAgICAgIGNhbGxBbGwoZnMsIFtdKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVwbGFjZSBkZWxldGVkIGl0ZW1zIHdpdGggSXRlbURlbGV0ZWQgLyBHQy5cbiAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29udGVudCBpcyBhY3R1YWxseSByZW1vdmUgZnJvbSB0aGUgWWpzIERvYy5cbiAgICAgIGlmIChkb2MuZ2MpIHtcbiAgICAgICAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBkb2MuZ2NGaWx0ZXIpO1xuICAgICAgfVxuICAgICAgdHJ5TWVyZ2VEZWxldGVTZXQoZHMsIHN0b3JlKTtcblxuICAgICAgLy8gb24gYWxsIGFmZmVjdGVkIHN0b3JlLmNsaWVudHMgcHJvcHMsIHRyeSB0byBtZXJnZVxuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGJlZm9yZUNsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMDtcbiAgICAgICAgaWYgKGJlZm9yZUNsb2NrICE9PSBjbG9jaykge1xuICAgICAgICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgICAgICAgLy8gd2UgaXRlcmF0ZSBmcm9tIHJpZ2h0IHRvIGxlZnQgc28gd2UgY2FuIHNhZmVseSByZW1vdmUgZW50cmllc1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hhbmdlUG9zID0gbWF4KGZpbmRJbmRleFNTKHN0cnVjdHMsIGJlZm9yZUNsb2NrKSwgMSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0cnVjdHMubGVuZ3RoIC0gMTsgaSA+PSBmaXJzdENoYW5nZVBvczsgaS0tKSB7XG4gICAgICAgICAgICB0cnlUb01lcmdlV2l0aExlZnQoc3RydWN0cywgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHRyeSB0byBtZXJnZSBtZXJnZVN0cnVjdHNcbiAgICAgIC8vIEB0b2RvOiBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHRyYW5zZm9ybSBtZXJnZVN0cnVjdHMgdG8gYSBEUywgc29ydCBpdCwgYW5kIG1lcmdlIGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAgLy8gICAgICAgIGJ1dCBhdCB0aGUgbW9tZW50IERTIGRvZXMgbm90IGhhbmRsZSBkdXBsaWNhdGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlU3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IG1lcmdlU3RydWN0c1tpXS5pZDtcbiAgICAgICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICAgICAgY29uc3QgcmVwbGFjZWRTdHJ1Y3RQb3MgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gICAgICAgIGlmIChyZXBsYWNlZFN0cnVjdFBvcyArIDEgPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCByZXBsYWNlZFN0cnVjdFBvcyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBsYWNlZFN0cnVjdFBvcyA+IDApIHtcbiAgICAgICAgICB0cnlUb01lcmdlV2l0aExlZnQoc3RydWN0cywgcmVwbGFjZWRTdHJ1Y3RQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkgIT09IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChkb2MuY2xpZW50SUQpKSB7XG4gICAgICAgIGRvYy5jbGllbnRJRCA9IGdlbmVyYXRlTmV3Q2xpZW50SWQoKTtcbiAgICAgICAgcHJpbnQoT1JBTkdFLCBCT0xELCAnW3lqc10gJywgVU5CT0xELCBSRUQsICdDaGFuZ2VkIHRoZSBjbGllbnQtaWQgYmVjYXVzZSBhbm90aGVyIGNsaWVudCBzZWVtcyB0byBiZSB1c2luZyBpdC4nKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0b2RvIE1lcmdlIGFsbCB0aGUgdHJhbnNhY3Rpb25zIGludG8gb25lIGFuZCBwcm92aWRlIHNlbmQgdGhlIGRhdGEgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2VcbiAgICAgIGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uQ2xlYW51cCcsIFt0cmFuc2FjdGlvbiwgZG9jXSk7XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGUnKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMSgpO1xuICAgICAgICBjb25zdCBoYXNDb250ZW50ID0gd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlJywgW2VuY29kZXIudG9VaW50OEFycmF5KCksIHRyYW5zYWN0aW9uLm9yaWdpbiwgZG9jLCB0cmFuc2FjdGlvbl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGVWMicpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgIGRvYy5lbWl0KCd1cGRhdGVWMicsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmZvckVhY2goc3ViZG9jID0+IGRvYy5zdWJkb2NzLmFkZChzdWJkb2MpKTtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmZvckVhY2goc3ViZG9jID0+IGRvYy5zdWJkb2NzLmRlbGV0ZShzdWJkb2MpKTtcblxuICAgICAgZG9jLmVtaXQoJ3N1YmRvY3MnLCBbeyBsb2FkZWQ6IHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQsIGFkZGVkOiB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQsIHJlbW92ZWQ6IHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkIH1dKTtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmZvckVhY2goc3ViZG9jID0+IHN1YmRvYy5kZXN0cm95KCkpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPD0gaSArIDEpIHtcbiAgICAgICAgZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzID0gW107XG4gICAgICAgIGRvYy5lbWl0KCdhZnRlckFsbFRyYW5zYWN0aW9ucycsIFtkb2MsIHRyYW5zYWN0aW9uQ2xlYW51cHNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25DbGVhbnVwcywgaSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGB5LnRyYW5zYWN0KCgpPT57Li59KWBcbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYW5zYWN0aW9uKTp2b2lkfSBmXG4gKiBAcGFyYW0ge2FueX0gW29yaWdpbj10cnVlXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0cmFuc2FjdCA9IChkb2MsIGYsIG9yaWdpbiA9IG51bGwsIGxvY2FsID0gdHJ1ZSkgPT4ge1xuICBjb25zdCB0cmFuc2FjdGlvbkNsZWFudXBzID0gZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzO1xuICBsZXQgaW5pdGlhbENhbGwgPSBmYWxzZTtcbiAgaWYgKGRvYy5fdHJhbnNhY3Rpb24gPT09IG51bGwpIHtcbiAgICBpbml0aWFsQ2FsbCA9IHRydWU7XG4gICAgZG9jLl90cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbihkb2MsIG9yaWdpbiwgbG9jYWwpO1xuICAgIHRyYW5zYWN0aW9uQ2xlYW51cHMucHVzaChkb2MuX3RyYW5zYWN0aW9uKTtcbiAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRvYy5lbWl0KCdiZWZvcmVBbGxUcmFuc2FjdGlvbnMnLCBbZG9jXSk7XG4gICAgfVxuICAgIGRvYy5lbWl0KCdiZWZvcmVUcmFuc2FjdGlvbicsIFtkb2MuX3RyYW5zYWN0aW9uLCBkb2NdKTtcbiAgfVxuICB0cnkge1xuICAgIGYoZG9jLl90cmFuc2FjdGlvbik7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGluaXRpYWxDYWxsICYmIHRyYW5zYWN0aW9uQ2xlYW51cHNbMF0gPT09IGRvYy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgIC8vIFRoZSBmaXJzdCB0cmFuc2FjdGlvbiBlbmRlZCwgbm93IHByb2Nlc3Mgb2JzZXJ2ZXIgY2FsbHMuXG4gICAgICAvLyBPYnNlcnZlciBjYWxsIG1heSBjcmVhdGUgbmV3IHRyYW5zYWN0aW9ucyBmb3Igd2hpY2ggd2UgbmVlZCB0byBjYWxsIHRoZSBvYnNlcnZlcnMgYW5kIGRvIGNsZWFudXAuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG5lc3QgdGhlc2UgY2FsbHMsIHNvIHdlIGV4ZWN1dGUgdGhlc2UgY2FsbHMgb25lIGFmdGVyXG4gICAgICAvLyBhbm90aGVyLlxuICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFsbCBjbGVhbnVwcyBhcmUgY2FsbGVkLCBldmVuIGlmIHRoZVxuICAgICAgLy8gb2JzZXJ2ZXMgdGhyb3cgZXJyb3JzLlxuICAgICAgLy8gVGhpcyBmaWxlIGlzIGZ1bGwgb2YgaGFja3kgdHJ5IHt9IGZpbmFsbHkge30gYmxvY2tzIHRvIGVuc3VyZSB0aGF0IGFuXG4gICAgICAvLyBldmVudCBjYW4gdGhyb3cgZXJyb3JzIGFuZCBhbHNvIHRoYXQgdGhlIGNsZWFudXAgaXMgY2FsbGVkLlxuICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbkNsZWFudXBzLCAwKTtcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFN0YWNrSXRlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gZGVsZXRpb25zXG4gICAqIEBwYXJhbSB7RGVsZXRlU2V0fSBpbnNlcnRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVsZXRpb25zLCBpbnNlcnRpb25zKSB7XG4gICAgdGhpcy5pbnNlcnRpb25zID0gaW5zZXJ0aW9ucztcbiAgICB0aGlzLmRlbGV0aW9ucyA9IGRlbGV0aW9ucztcbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyB0byBzYXZlIGFuZCByZXN0b3JlIG1ldGFkYXRhIGxpa2Ugc2VsZWN0aW9uIHJhbmdlXG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW5kb01hbmFnZXJcbiAqIEBwYXJhbSB7QXJyYXk8U3RhY2tJdGVtPn0gc3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge1N0YWNrSXRlbT99XG4gKi9cbmNvbnN0IHBvcFN0YWNrSXRlbSA9ICh1bmRvTWFuYWdlciwgc3RhY2ssIGV2ZW50VHlwZSkgPT4ge1xuICAvKipcbiAgICogV2hldGhlciBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKiBAdHlwZSB7U3RhY2tJdGVtP31cbiAgICovXG4gIGxldCByZXN1bHQgPSBudWxsO1xuICAvKipcbiAgICogS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgdHJhbnNhY3Rpb24gc28gd2UgY2FuIGZpcmUgdGhlIGV2ZW50IHdpdGggdGhlIGNoYW5nZWRQYXJlbnRUeXBlc1xuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IF90ciA9IG51bGw7XG4gIGNvbnN0IGRvYyA9IHVuZG9NYW5hZ2VyLmRvYztcbiAgY29uc3Qgc2NvcGUgPSB1bmRvTWFuYWdlci5zY29wZTtcbiAgdHJhbnNhY3QoZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgICAgIGNvbnN0IHN0YWNrSXRlbSA9IC8qKiBAdHlwZSB7U3RhY2tJdGVtfSAqLyAoc3RhY2sucG9wKCkpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBpdGVtc1RvUmVkbyA9IG5ldyBTZXQoKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PEl0ZW0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBpdGVtc1RvRGVsZXRlID0gW107XG4gICAgICBsZXQgcGVyZm9ybWVkQ2hhbmdlID0gZmFsc2U7XG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHN0YWNrSXRlbS5pbnNlcnRpb25zLCBzdHJ1Y3QgPT4ge1xuICAgICAgICBpZiAoc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgICAgICAgIGlmIChzdHJ1Y3QucmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgeyBpdGVtLCBkaWZmIH0gPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHN0cnVjdC5pZCk7XG4gICAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgICAgaXRlbSA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChpdGVtLmlkLmNsaWVudCwgaXRlbS5pZC5jbG9jayArIGRpZmYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cnVjdCA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQgJiYgc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RydWN0KSkpKSB7XG4gICAgICAgICAgICBpdGVtc1RvRGVsZXRlLnB1c2goc3RydWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdGFja0l0ZW0uZGVsZXRpb25zLCBzdHJ1Y3QgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJlxuICAgICAgICAgIHNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIHN0cnVjdCkpICYmXG4gICAgICAgICAgLy8gTmV2ZXIgcmVkbyBzdHJ1Y3RzIGluIHN0YWNrSXRlbS5pbnNlcnRpb25zIGJlY2F1c2UgdGhleSB3ZXJlIGNyZWF0ZWQgYW5kIGRlbGV0ZWQgaW4gdGhlIHNhbWUgY2FwdHVyZSBpbnRlcnZhbC5cbiAgICAgICAgICAhaXNEZWxldGVkKHN0YWNrSXRlbS5pbnNlcnRpb25zLCBzdHJ1Y3QuaWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGl0ZW1zVG9SZWRvLmFkZChzdHJ1Y3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZW1zVG9SZWRvLmZvckVhY2goc3RydWN0ID0+IHtcbiAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gcmVkb0l0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgaXRlbXNUb1JlZG8pICE9PSBudWxsIHx8IHBlcmZvcm1lZENoYW5nZTtcbiAgICAgIH0pO1xuICAgICAgLy8gV2Ugd2FudCB0byBkZWxldGUgaW4gcmV2ZXJzZSBvcmRlciBzbyB0aGF0IGNoaWxkcmVuIGFyZSBkZWxldGVkIGJlZm9yZVxuICAgICAgLy8gcGFyZW50cywgc28gd2UgaGF2ZSBtb3JlIGluZm9ybWF0aW9uIGF2YWlsYWJsZSB3aGVuIGl0ZW1zIGFyZSBmaWx0ZXJlZC5cbiAgICAgIGZvciAobGV0IGkgPSBpdGVtc1RvRGVsZXRlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1RvRGVsZXRlW2ldO1xuICAgICAgICBpZiAodW5kb01hbmFnZXIuZGVsZXRlRmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgIHBlcmZvcm1lZENoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHBlcmZvcm1lZENoYW5nZSA/IHN0YWNrSXRlbSA6IG51bGw7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaCgoc3ViUHJvcHMsIHR5cGUpID0+IHtcbiAgICAgIC8vIGRlc3Ryb3kgc2VhcmNoIG1hcmtlciBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChzdWJQcm9wcy5oYXMobnVsbCkgJiYgdHlwZS5fc2VhcmNoTWFya2VyKSB7XG4gICAgICAgIHR5cGUuX3NlYXJjaE1hcmtlci5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90ciA9IHRyYW5zYWN0aW9uO1xuICB9LCB1bmRvTWFuYWdlcik7XG4gIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGNoYW5nZWRQYXJlbnRUeXBlcyA9IF90ci5jaGFuZ2VkUGFyZW50VHlwZXM7XG4gICAgdW5kb01hbmFnZXIuZW1pdCgnc3RhY2staXRlbS1wb3BwZWQnLCBbeyBzdGFja0l0ZW06IHJlc3VsdCwgdHlwZTogZXZlbnRUeXBlLCBjaGFuZ2VkUGFyZW50VHlwZXMgfSwgdW5kb01hbmFnZXJdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuZG9NYW5hZ2VyT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtVbmRvTWFuYWdlck9wdGlvbnMuY2FwdHVyZVRpbWVvdXQ9NTAwXVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmRlbGV0ZUZpbHRlcj0oKT0+dHJ1ZV0gU29tZXRpbWVzXG4gKiBpdCBpcyBuZWNlc3NhcnkgdG8gZmlsdGVyIHdoYW4gYW4gVW5kby9SZWRvIG9wZXJhdGlvbiBjYW4gZGVsZXRlLiBJZiB0aGlzXG4gKiBmaWx0ZXIgcmV0dXJucyBmYWxzZSwgdGhlIHR5cGUvaXRlbSB3b24ndCBiZSBkZWxldGVkIGV2ZW4gaXQgaXMgaW4gdGhlXG4gKiB1bmRvL3JlZG8gc2NvcGUuXG4gKiBAcHJvcGVydHkge1NldDxhbnk+fSBbVW5kb01hbmFnZXJPcHRpb25zLnRyYWNrZWRPcmlnaW5zPW5ldyBTZXQoW251bGxdKV1cbiAqL1xuXG4vKipcbiAqIEZpcmVzICdzdGFjay1pdGVtLWFkZGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgYWRkZWQgdG8gZWl0aGVyIHRoZSB1bmRvLSBvclxuICogdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgc3RvcmUgYWRkaXRpb25hbCBzdGFjayBpbmZvcm1hdGlvbiB2aWEgdGhlXG4gKiBtZXRhZGF0YSBwcm9wZXJ0eSBvbiBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgIChpdCBpcyBhIGBNYXBgIG9mIG1ldGFkYXRhIHByb3BlcnRpZXMpLlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tcG9wcGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgcG9wcGVkIGZyb20gZWl0aGVyIHRoZVxuICogdW5kby0gb3IgdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgcmVzdG9yZSB0aGUgc2F2ZWQgc3RhY2sgaW5mb3JtYXRpb24gZnJvbSBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPCdzdGFjay1pdGVtLWFkZGVkJ3wnc3RhY2staXRlbS1wb3BwZWQnPn1cbiAqL1xuY2xhc3MgVW5kb01hbmFnZXIgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+fSB0eXBlU2NvcGUgQWNjZXB0cyBlaXRoZXIgYSBzaW5nbGUgdHlwZSwgb3IgYW4gYXJyYXkgb2YgdHlwZXNcbiAgICogQHBhcmFtIHtVbmRvTWFuYWdlck9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlU2NvcGUsIHsgY2FwdHVyZVRpbWVvdXQgPSA1MDAsIGRlbGV0ZUZpbHRlciA9ICgpID0+IHRydWUsIHRyYWNrZWRPcmlnaW5zID0gbmV3IFNldChbbnVsbF0pIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zY29wZSA9IHR5cGVTY29wZSBpbnN0YW5jZW9mIEFycmF5ID8gdHlwZVNjb3BlIDogW3R5cGVTY29wZV07XG4gICAgdGhpcy5kZWxldGVGaWx0ZXIgPSBkZWxldGVGaWx0ZXI7XG4gICAgdHJhY2tlZE9yaWdpbnMuYWRkKHRoaXMpO1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMgPSB0cmFja2VkT3JpZ2lucztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3RhY2tJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSB1bmRvaW5nIChjYWxsaW5nIFVuZG9NYW5hZ2VyLnVuZG8pXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJlZG9pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRvYyA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy5zY29wZVswXS5kb2MpO1xuICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgdGhpcy5kb2Mub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCAvKiogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gKi8gdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLy8gT25seSB0cmFjayBjZXJ0YWluIHRyYW5zYWN0aW9uc1xuICAgICAgaWYgKCF0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuaGFzKHR5cGUpKSB8fCAoIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbikgJiYgKCF0cmFuc2FjdGlvbi5vcmlnaW4gfHwgIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbi5jb25zdHJ1Y3RvcikpKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHVuZG9pbmcgPSB0aGlzLnVuZG9pbmc7XG4gICAgICBjb25zdCByZWRvaW5nID0gdGhpcy5yZWRvaW5nO1xuICAgICAgY29uc3Qgc3RhY2sgPSB1bmRvaW5nID8gdGhpcy5yZWRvU3RhY2sgOiB0aGlzLnVuZG9TdGFjaztcbiAgICAgIGlmICh1bmRvaW5nKSB7XG4gICAgICAgIHRoaXMuc3RvcENhcHR1cmluZygpOyAvLyBuZXh0IHVuZG8gc2hvdWxkIG5vdCBiZSBhcHBlbmRlZCB0byBsYXN0IHN0YWNrIGl0ZW1cbiAgICAgIH0gZWxzZSBpZiAoIXJlZG9pbmcpIHtcbiAgICAgICAgLy8gbmVpdGhlciB1bmRvaW5nIG5vciByZWRvaW5nOiBkZWxldGUgcmVkb1N0YWNrXG4gICAgICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpbnNlcnRpb25zID0gbmV3IERlbGV0ZVNldCgpO1xuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5mb3JFYWNoKChlbmRDbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBjb25zdCBsZW4gPSBlbmRDbG9jayAtIHN0YXJ0Q2xvY2s7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgYWRkVG9EZWxldGVTZXQoaW5zZXJ0aW9ucywgY2xpZW50LCBzdGFydENsb2NrLCBsZW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5vdyA9IGdldFVuaXhUaW1lKCk7XG4gICAgICBpZiAobm93IC0gdGhpcy5sYXN0Q2hhbmdlIDwgY2FwdHVyZVRpbWVvdXQgJiYgc3RhY2subGVuZ3RoID4gMCAmJiAhdW5kb2luZyAmJiAhcmVkb2luZykge1xuICAgICAgICAvLyBhcHBlbmQgY2hhbmdlIHRvIGxhc3Qgc3RhY2sgb3BcbiAgICAgICAgY29uc3QgbGFzdE9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGxhc3RPcC5kZWxldGlvbnMgPSBtZXJnZURlbGV0ZVNldHMoW2xhc3RPcC5kZWxldGlvbnMsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldF0pO1xuICAgICAgICBsYXN0T3AuaW5zZXJ0aW9ucyA9IG1lcmdlRGVsZXRlU2V0cyhbbGFzdE9wLmluc2VydGlvbnMsIGluc2VydGlvbnNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBzdGFjayBvcFxuICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0l0ZW0odHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpbnNlcnRpb25zKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVuZG9pbmcgJiYgIXJlZG9pbmcpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gbm93O1xuICAgICAgfVxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgZGVsZXRlZCBzdHJ1Y3RzIGFyZSBub3QgZ2MnZFxuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIC8qKiBAcGFyYW0ge0l0ZW18R0N9IGl0ZW0gKi8gaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIGl0ZW0pKSkge1xuICAgICAgICAgIGtlZXBJdGVtKGl0ZW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdCgnc3RhY2staXRlbS1hZGRlZCcsIFt7IHN0YWNrSXRlbTogc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0sIG9yaWdpbjogdHJhbnNhY3Rpb24ub3JpZ2luLCB0eXBlOiB1bmRvaW5nID8gJ3JlZG8nIDogJ3VuZG8nLCBjaGFuZ2VkUGFyZW50VHlwZXM6IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcyB9LCB0aGlzXSk7XG4gICAgfSk7XG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5kb2MudHJhbnNhY3QodHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1N0YWNrSXRlbX0gc3RhY2tJdGVtXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNsZWFySXRlbSA9IHN0YWNrSXRlbSA9PiB7XG4gICAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmRlbGV0aW9ucywgaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIHRoaXMuc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgaXRlbSkpKSB7XG4gICAgICAgICAgICBrZWVwSXRlbShpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnVuZG9TdGFjay5mb3JFYWNoKGNsZWFySXRlbSk7XG4gICAgICB0aGlzLnJlZG9TdGFjay5mb3JFYWNoKGNsZWFySXRlbSk7XG4gICAgfSk7XG4gICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcbiAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuZG9NYW5hZ2VyIG1lcmdlcyBVbmRvLVN0YWNrSXRlbSBpZiB0aGV5IGFyZSBjcmVhdGVkIHdpdGhpbiB0aW1lLWdhcFxuICAgKiBzbWFsbGVyIHRoYW4gYG9wdGlvbnMuY2FwdHVyZVRpbWVvdXRgLiBDYWxsIGB1bS5zdG9wQ2FwdHVyaW5nKClgIHNvIHRoYXQgdGhlIG5leHRcbiAgICogU3RhY2tJdGVtIHdvbid0IGJlIG1lcmdlZC5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIC8vIHdpdGhvdXQgc3RvcENhcHR1cmluZ1xuICAgKiAgICAgeXRleHQuaW5zZXJ0KDAsICdhJylcbiAgICogICAgIHl0ZXh0Lmluc2VydCgxLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJycgKG5vdGUgdGhhdCAnYWInIHdhcyByZW1vdmVkKVxuICAgKiAgICAgLy8gd2l0aCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2InKVxuICAgKiAgICAgdW0udW5kbygpXG4gICAqICAgICB5dGV4dC50b1N0cmluZygpIC8vID0+ICdhJyAobm90ZSB0aGF0IG9ubHkgJ2InIHdhcyByZW1vdmVkKVxuICAgKlxuICAgKi9cbiAgc3RvcENhcHR1cmluZyAoKSB7XG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmRvIGxhc3QgY2hhbmdlcyBvbiB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgdW5kbyAoKSB7XG4gICAgdGhpcy51bmRvaW5nID0gdHJ1ZTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBwb3BTdGFja0l0ZW0odGhpcywgdGhpcy51bmRvU3RhY2ssICd1bmRvJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudW5kb2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKipcbiAgICogUmVkbyBsYXN0IHVuZG8gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgcmVkbyAoKSB7XG4gICAgdGhpcy5yZWRvaW5nID0gdHJ1ZTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBwb3BTdGFja0l0ZW0odGhpcywgdGhpcy5yZWRvU3RhY2ssICdyZWRvJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucmVkb2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICovXG5mdW5jdGlvbiAqIGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IgKGRlY29kZXIpIHtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2Rlci5yZWFkQ2xpZW50KCk7XG4gICAgbGV0IGNsb2NrID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKTtcbiAgICAgIC8vIEB0b2RvIHVzZSBzd2l0Y2ggaW5zdGVhZCBvZiBpZnNcbiAgICAgIGlmIChpbmZvID09PSAxMCkge1xuICAgICAgICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAgICAgeWllbGQgbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgIH0gZWxzZSBpZiAoKEJJVFM1ICYgaW5mbykgIT09IDApIHtcbiAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoQklUNyB8IEJJVDgpKSA9PT0gMDtcbiAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgIG51bGwsIC8vIGxlZnRcbiAgICAgICAgICAoaW5mbyAmIEJJVDgpID09PSBCSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgIChpbmZvICYgQklUNykgPT09IEJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAvLyBAdHMtaWdub3JlIEZvcmNlIHdyaXRpbmcgYSBzdHJpbmcgaGVyZS5cbiAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gPyAoZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBkZWNvZGVyLnJlYWRMZWZ0SUQoKSkgOiBudWxsLCAvLyBwYXJlbnRcbiAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgKGluZm8gJiBCSVQ2KSA9PT0gQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICApO1xuICAgICAgICB5aWVsZCBzdHJ1Y3Q7XG4gICAgICAgIGNsb2NrICs9IHN0cnVjdC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgICAgICAgeWllbGQgbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICBjbG9jayArPSBsZW47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIExhenlTdHJ1Y3RSZWFkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTa2lwc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIsIGZpbHRlclNraXBzKSB7XG4gICAgdGhpcy5nZW4gPSBsYXp5U3RydWN0UmVhZGVyR2VuZXJhdG9yKGRlY29kZXIpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgSXRlbSB8IFNraXAgfCBHQ31cbiAgICAgKi9cbiAgICB0aGlzLmN1cnIgPSBudWxsO1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVyU2tpcHMgPSBmaWx0ZXJTa2lwcztcbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVtIHwgR0MgfCBTa2lwIHxudWxsfVxuICAgKi9cbiAgbmV4dCAoKSB7XG4gICAgLy8gaWdub3JlIFwiU2tpcFwiIHN0cnVjdHNcbiAgICBkbyB7XG4gICAgICB0aGlzLmN1cnIgPSB0aGlzLmdlbi5uZXh0KCkudmFsdWUgfHwgbnVsbDtcbiAgICB9IHdoaWxlICh0aGlzLmZpbHRlclNraXBzICYmIHRoaXMuY3VyciAhPT0gbnVsbCAmJiB0aGlzLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXApXG4gICAgcmV0dXJuIHRoaXMuY3VyclxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqXG4gKi9cbmNvbnN0IGxvZ1VwZGF0ZSA9IHVwZGF0ZSA9PiBsb2dVcGRhdGVWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqXG4gKi9cbmNvbnN0IGxvZ1VwZGF0ZVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpO1xuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKTtcbiAgfVxuICBwcmludCgnU3RydWN0czogJywgc3RydWN0cyk7XG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKTtcbiAgcHJpbnQoJ0RlbGV0ZVNldDogJywgZHMpO1xufTtcblxuY2xhc3MgTGF6eVN0cnVjdFdyaXRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVuY29kZXIpIHtcbiAgICB0aGlzLmN1cnJDbGllbnQgPSAwO1xuICAgIHRoaXMuc3RhcnRDbG9jayA9IDA7XG4gICAgdGhpcy53cml0dGVuID0gMDtcbiAgICB0aGlzLmVuY29kZXIgPSBlbmNvZGVyO1xuICAgIC8qKlxuICAgICAqIFdlIHdhbnQgdG8gd3JpdGUgb3BlcmF0aW9ucyBsYXppbHksIGJ1dCBhbHNvIHdlIG5lZWQgdG8ga25vdyBiZWZvcmVoYW5kIGhvdyBtYW55IG9wZXJhdGlvbnMgd2Ugd2FudCB0byB3cml0ZSBmb3IgZWFjaCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIGtpbmQgb2YgbWV0YS1pbmZvcm1hdGlvbiAoI2NsaWVudHMsICNzdHJ1Y3RzLXBlci1jbGllbnQtd3JpdHRlbikgaXMgd3JpdHRlbiB0byB0aGUgcmVzdEVuY29kZXIuXG4gICAgICpcbiAgICAgKiBXZSBmcmFnbWVudCB0aGUgcmVzdEVuY29kZXIgYW5kIHN0b3JlIGEgc2xpY2Ugb2YgaXQgcGVyLWNsaWVudCB1bnRpbCB3ZSBrbm93IGhvdyBtYW55IGNsaWVudHMgdGhlcmUgYXJlLlxuICAgICAqIFdoZW4gd2UgZmx1c2ggKHRvVWludDhBcnJheSkgd2Ugd3JpdGUgdGhlIHJlc3RFbmNvZGVyIHVzaW5nIHRoZSBmcmFnbWVudHMgYW5kIHRoZSBtZXRhLWluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PHsgd3JpdHRlbjogbnVtYmVyLCByZXN0RW5jb2RlcjogVWludDhBcnJheSB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudFN0cnVjdHMgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IG1lcmdlVXBkYXRlcyA9IHVwZGF0ZXMgPT4gbWVyZ2VVcGRhdGVzVjIodXBkYXRlcywgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVFbmNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBEU0VuY29kZXJWMSB8IHR5cGVvZiBEU0VuY29kZXJWMn0gWUVuY29kZXJcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFlEZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMiA9ICh1cGRhdGUsIFlFbmNvZGVyID0gRFNFbmNvZGVyVjIsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgWUVuY29kZXIoKTtcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKG5ldyBZRGVjb2RlcihjcmVhdGVEZWNvZGVyKHVwZGF0ZSkpLCB0cnVlKTtcbiAgbGV0IGN1cnIgPSB1cGRhdGVEZWNvZGVyLmN1cnI7XG4gIGlmIChjdXJyICE9PSBudWxsKSB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGxldCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgbGV0IGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2s7XG4gICAgbGV0IHN0b3BDb3VudGluZyA9IGZhbHNlO1xuICAgIGZvciAoOyBjdXJyICE9PSBudWxsOyBjdXJyID0gdXBkYXRlRGVjb2Rlci5uZXh0KCkpIHtcbiAgICAgIGlmIChjdXJyQ2xpZW50ICE9PSBjdXJyLmlkLmNsaWVudCkge1xuICAgICAgICBzaXplKys7XG4gICAgICAgIC8vIFdlIGZvdW5kIGEgbmV3IGNsaWVudFxuICAgICAgICAvLyB3cml0ZSB3aGF0IHdlIGhhdmUgdG8gdGhlIGVuY29kZXJcbiAgICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbGllbnQpO1xuICAgICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsb2NrKTtcbiAgICAgICAgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgICAgICBzdG9wQ291bnRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgIHN0b3BDb3VudGluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXN0b3BDb3VudGluZykge1xuICAgICAgICBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdyaXRlIHdoYXQgd2UgaGF2ZVxuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xpZW50KTtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsb2NrKTtcbiAgICAvLyBwcmVwZW5kIHRoZSBzaXplIG9mIHRoZSBzdGF0ZSB2ZWN0b3JcbiAgICBjb25zdCBlbmMgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgd3JpdGVWYXJVaW50KGVuYywgc2l6ZSk7XG4gICAgd3JpdGVCaW5hcnlFbmNvZGVyKGVuYywgZW5jb2Rlci5yZXN0RW5jb2Rlcik7XG4gICAgZW5jb2Rlci5yZXN0RW5jb2RlciA9IGVuYztcbiAgICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCAwKTtcbiAgICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUgPSB1cGRhdGUgPT4gZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIodXBkYXRlLCBEU0VuY29kZXJWMSwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gWURlY29kZXJcbiAqIEByZXR1cm4ge3sgZnJvbTogTWFwPG51bWJlcixudW1iZXI+LCB0bzogTWFwPG51bWJlcixudW1iZXI+IH19XG4gKi9cbmNvbnN0IHBhcnNlVXBkYXRlTWV0YVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXI+fVxuICAgKi9cbiAgY29uc3QgZnJvbSA9IG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXI+fVxuICAgKi9cbiAgY29uc3QgdG8gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcihuZXcgWURlY29kZXIoY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSwgZmFsc2UpO1xuICBsZXQgY3VyciA9IHVwZGF0ZURlY29kZXIuY3VycjtcbiAgaWYgKGN1cnIgIT09IG51bGwpIHtcbiAgICBsZXQgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgIGxldCBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrO1xuICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgZnJvbS5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKTtcbiAgICBmb3IgKDsgY3VyciAhPT0gbnVsbDsgY3VyciA9IHVwZGF0ZURlY29kZXIubmV4dCgpKSB7XG4gICAgICBpZiAoY3VyckNsaWVudCAhPT0gY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgLy8gV2UgZm91bmQgYSBuZXcgY2xpZW50XG4gICAgICAgIC8vIHdyaXRlIHRoZSBlbmQgdG8gYHRvYFxuICAgICAgICB0by5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKTtcbiAgICAgICAgLy8gd3JpdGUgdGhlIGJlZ2lubmluZyB0byBgZnJvbWBcbiAgICAgICAgZnJvbS5zZXQoY3Vyci5pZC5jbGllbnQsIGN1cnIuaWQuY2xvY2spO1xuICAgICAgICAvLyB1cGRhdGUgY3VyckNsaWVudFxuICAgICAgICBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgICB9XG4gICAgICBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGg7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRoZSBlbmQgdG8gYHRvYFxuICAgIHRvLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spO1xuICB9XG4gIHJldHVybiB7IGZyb20sIHRvIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEByZXR1cm4ge3sgZnJvbTogTWFwPG51bWJlcixudW1iZXI+LCB0bzogTWFwPG51bWJlcixudW1iZXI+IH19XG4gKi9cbmNvbnN0IHBhcnNlVXBkYXRlTWV0YSA9IHVwZGF0ZSA9PiBwYXJzZVVwZGF0ZU1ldGFWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gc2xpY2UgYW55IGtpbmQgb2Ygc3RydWN0IGFuZCByZXRyaWV2ZSB0aGUgcmlnaHQgcGFydC5cbiAqIEl0IGRvZXMgbm90IGhhbmRsZSBzaWRlLWVmZmVjdHMsIHNvIGl0IHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgdGhlIGxhenktZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0l0ZW0gfCBHQyB8IFNraXB9IGxlZnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gKiBAcmV0dXJuIHtJdGVtIHwgR0N9XG4gKi9cbmNvbnN0IHNsaWNlU3RydWN0ID0gKGxlZnQsIGRpZmYpID0+IHtcbiAgaWYgKGxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0LmlkO1xuICAgIHJldHVybiBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLCBsZWZ0Lmxlbmd0aCAtIGRpZmYpXG4gIH0gZWxzZSBpZiAobGVmdC5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdC5pZDtcbiAgICByZXR1cm4gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLCBsZWZ0Lmxlbmd0aCAtIGRpZmYpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVmdEl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KTtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnRJdGVtLmlkO1xuICAgIHJldHVybiBuZXcgSXRlbShcbiAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSxcbiAgICAgIG51bGwsXG4gICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiAtIDEpLFxuICAgICAgbnVsbCxcbiAgICAgIGxlZnRJdGVtLnJpZ2h0T3JpZ2luLFxuICAgICAgbGVmdEl0ZW0ucGFyZW50LFxuICAgICAgbGVmdEl0ZW0ucGFyZW50U3ViLFxuICAgICAgbGVmdEl0ZW0uY29udGVudC5zcGxpY2UoZGlmZilcbiAgICApXG4gIH1cbn07XG5cbi8qKlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29ya3Mgc2ltaWxhcmx5IHRvIGByZWFkVXBkYXRlVjJgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IG1lcmdlVXBkYXRlc1YyID0gKHVwZGF0ZXMsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyLCBZRW5jb2RlciA9IFVwZGF0ZUVuY29kZXJWMikgPT4ge1xuICBjb25zdCB1cGRhdGVEZWNvZGVycyA9IHVwZGF0ZXMubWFwKHVwZGF0ZSA9PiBuZXcgWURlY29kZXIoY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSk7XG4gIGxldCBsYXp5U3RydWN0RGVjb2RlcnMgPSB1cGRhdGVEZWNvZGVycy5tYXAoZGVjb2RlciA9PiBuZXcgTGF6eVN0cnVjdFJlYWRlcihkZWNvZGVyLCB0cnVlKSk7XG5cbiAgLyoqXG4gICAqIEB0b2RvIHdlIGRvbid0IG5lZWQgb2Zmc2V0IGJlY2F1c2Ugd2UgYWx3YXlzIHNsaWNlIGJlZm9yZVxuICAgKiBAdHlwZSB7bnVsbCB8IHsgc3RydWN0OiBJdGVtIHwgR0MgfCBTa2lwLCBvZmZzZXQ6IG51bWJlciB9fVxuICAgKi9cbiAgbGV0IGN1cnJXcml0ZSA9IG51bGw7XG5cbiAgY29uc3QgdXBkYXRlRW5jb2RlciA9IG5ldyBZRW5jb2RlcigpO1xuICAvLyB3cml0ZSBzdHJ1Y3RzIGxhemlseVxuICBjb25zdCBsYXp5U3RydWN0RW5jb2RlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKHVwZGF0ZUVuY29kZXIpO1xuXG4gIC8vIE5vdGU6IFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGxhenlTdHJ1Y3REZWNvZGVycyBhcmUgZnVsbHkgY29uc3VtZWRcbiAgLy8gTm90ZTogU2hvdWxkIG1lcmdlIGRvY3VtZW50IHVwZGF0ZXMgd2hlbmV2ZXIgcG9zc2libGUgLSBldmVuIGZyb20gZGlmZmVyZW50IHVwZGF0ZXNcbiAgLy8gTm90ZTogU2hvdWxkIGhhbmRsZSB0aGF0IHNvbWUgb3BlcmF0aW9ucyBjYW5ub3QgYmUgYXBwbGllZCB5ZXQgKClcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFdyaXRlIGhpZ2hlciBjbGllbnRzIGZpcnN0IOKHkiBzb3J0IGJ5IGNsaWVudElEICYgY2xvY2sgYW5kIHJlbW92ZSBkZWNvZGVycyB3aXRob3V0IGNvbnRlbnRcbiAgICBsYXp5U3RydWN0RGVjb2RlcnMgPSBsYXp5U3RydWN0RGVjb2RlcnMuZmlsdGVyKGRlYyA9PiBkZWMuY3VyciAhPT0gbnVsbCk7XG4gICAgbGF6eVN0cnVjdERlY29kZXJzLnNvcnQoXG4gICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGFueSxhbnkpOm51bWJlcn0gKi8gKGRlYzEsIGRlYzIpID0+IHtcbiAgICAgICAgaWYgKGRlYzEuY3Vyci5pZC5jbGllbnQgPT09IGRlYzIuY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgICBjb25zdCBjbG9ja0RpZmYgPSBkZWMxLmN1cnIuaWQuY2xvY2sgLSBkZWMyLmN1cnIuaWQuY2xvY2s7XG4gICAgICAgICAgaWYgKGNsb2NrRGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlYzEuY3Vyci5jb25zdHJ1Y3RvciA9PT0gZGVjMi5jdXJyLmNvbnN0cnVjdG9yID8gMCA6IChcbiAgICAgICAgICAgICAgZGVjMS5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwID8gMSA6IC0xXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9ja0RpZmZcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlYzIuY3Vyci5pZC5jbGllbnQgLSBkZWMxLmN1cnIuaWQuY2xpZW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChsYXp5U3RydWN0RGVjb2RlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjb25zdCBjdXJyRGVjb2RlciA9IGxhenlTdHJ1Y3REZWNvZGVyc1swXTtcbiAgICAvLyB3cml0ZSBmcm9tIGN1cnJEZWNvZGVyIHVudGlsIHRoZSBuZXh0IG9wZXJhdGlvbiBpcyBmcm9tIGFub3RoZXIgY2xpZW50IG9yIGlmIGZpbGxlci1zdHJ1Y3RcbiAgICAvLyB0aGVuIHdlIG5lZWQgdG8gcmVvcmRlciB0aGUgZGVjb2RlcnMgYW5kIGZpbmQgdGhlIG5leHQgb3BlcmF0aW9uIHRvIHdyaXRlXG4gICAgY29uc3QgZmlyc3RDbGllbnQgPSAvKiogQHR5cGUge0l0ZW0gfCBHQ30gKi8gKGN1cnJEZWNvZGVyLmN1cnIpLmlkLmNsaWVudDtcblxuICAgIGlmIChjdXJyV3JpdGUgIT09IG51bGwpIHtcbiAgICAgIGxldCBjdXJyID0gLyoqIEB0eXBlIHtJdGVtIHwgR0MgfCBudWxsfSAqLyAoY3VyckRlY29kZXIuY3Vycik7XG5cbiAgICAgIC8vIGl0ZXJhdGUgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdGhhdCB3ZSBoYXZlbid0IHdyaXR0ZW4gYWxyZWFkeVxuICAgICAgLy8gcmVtZW1iZXI6IGZpcnN0IHRoZSBoaWdoIGNsaWVudC1pZHMgYXJlIHdyaXR0ZW5cbiAgICAgIHdoaWxlIChjdXJyICE9PSBudWxsICYmIGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCA8PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggJiYgY3Vyci5pZC5jbGllbnQgPj0gY3VycldyaXRlLnN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICAgICAgY3VyciA9IGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyID09PSBudWxsIHx8IGN1cnIuaWQuY2xpZW50ICE9PSBmaXJzdENsaWVudCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDbGllbnQgIT09IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IGN1cnIsIG9mZnNldDogMCB9O1xuICAgICAgICBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIDwgY3Vyci5pZC5jbG9jaykge1xuICAgICAgICAgIC8vIEB0b2RvIHdyaXRlIGN1cnJTdHJ1Y3QgJiBzZXQgY3VyclN0cnVjdCA9IFNraXAoY2xvY2sgPSBjdXJyU3RydWN0LmlkLmNsb2NrICsgY3VyclN0cnVjdC5sZW5ndGgsIGxlbmd0aCA9IGN1cnIuaWQuY2xvY2sgLSBzZWxmLmNsb2NrKVxuICAgICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgICAgICAvLyBleHRlbmQgZXhpc3Rpbmcgc2tpcFxuICAgICAgICAgICAgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gY3Vyci5pZC5jbG9jayAtIGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgLSBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge1NraXB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBTa2lwKGNyZWF0ZUlEKGZpcnN0Q2xpZW50LCBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGgpLCBkaWZmKTtcbiAgICAgICAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0LCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGlmIChjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPj0gY3Vyci5pZC5jbG9jaykge1xuICAgICAgICAgIGNvbnN0IGRpZmYgPSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggLSBjdXJyLmlkLmNsb2NrO1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgICAgICAgLy8gcHJlZmVyIHRvIHNsaWNlIFNraXAgYmVjYXVzZSB0aGUgb3RoZXIgc3RydWN0IG1pZ2h0IGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAtPSBkaWZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyciA9IHNsaWNlU3RydWN0KGN1cnIsIGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWN1cnJXcml0ZS5zdHJ1Y3QubWVyZ2VXaXRoKC8qKiBAdHlwZSB7YW55fSAqLyAoY3VycikpKSB7XG4gICAgICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH07XG4gICAgICAgICAgICBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiAvKiogQHR5cGUge0l0ZW0gfCBHQ30gKi8gKGN1cnJEZWNvZGVyLmN1cnIpLCBvZmZzZXQ6IDAgfTtcbiAgICAgIGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICB9XG4gICAgZm9yIChcbiAgICAgIGxldCBuZXh0ID0gY3VyckRlY29kZXIuY3VycjtcbiAgICAgIG5leHQgIT09IG51bGwgJiYgbmV4dC5pZC5jbGllbnQgPT09IGZpcnN0Q2xpZW50ICYmIG5leHQuaWQuY2xvY2sgPT09IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAmJiBuZXh0LmNvbnN0cnVjdG9yICE9PSBTa2lwO1xuICAgICAgbmV4dCA9IGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICkge1xuICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IG5leHQsIG9mZnNldDogMCB9O1xuICAgIH1cbiAgfVxuICBpZiAoY3VycldyaXRlICE9PSBudWxsKSB7XG4gICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgIGN1cnJXcml0ZSA9IG51bGw7XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVN0cnVjdEVuY29kZXIpO1xuXG4gIGNvbnN0IGRzcyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IHJlYWREZWxldGVTZXQoZGVjb2RlcikpO1xuICBjb25zdCBkcyA9IG1lcmdlRGVsZXRlU2V0cyhkc3MpO1xuICB3cml0ZURlbGV0ZVNldCh1cGRhdGVFbmNvZGVyLCBkcyk7XG4gIHJldHVybiB1cGRhdGVFbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHN2XG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRW5jb2RlclYyfSBbWUVuY29kZXJdXG4gKi9cbmNvbnN0IGRpZmZVcGRhdGVWMiA9ICh1cGRhdGUsIHN2LCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBkZWNvZGVTdGF0ZVZlY3Rvcihzdik7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgWUVuY29kZXIoKTtcbiAgY29uc3QgbGF6eVN0cnVjdFdyaXRlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKGVuY29kZXIpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFlEZWNvZGVyKGNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKGRlY29kZXIsIGZhbHNlKTtcbiAgd2hpbGUgKHJlYWRlci5jdXJyKSB7XG4gICAgY29uc3QgY3VyciA9IHJlYWRlci5jdXJyO1xuICAgIGNvbnN0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICBjb25zdCBzdkNsb2NrID0gc3RhdGUuZ2V0KGN1cnJDbGllbnQpIHx8IDA7XG4gICAgaWYgKHJlYWRlci5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAvLyB0aGUgZmlyc3Qgd3JpdHRlbiBzdHJ1Y3Qgc2hvdWxkbid0IGJlIGEgc2tpcFxuICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggPiBzdkNsb2NrKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0V3JpdGVyLCBjdXJyLCBtYXgoc3ZDbG9jayAtIGN1cnIuaWQuY2xvY2ssIDApKTtcbiAgICAgIHJlYWRlci5uZXh0KCk7XG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RXcml0ZXIsIHJlYWRlci5jdXJyLCAwKTtcbiAgICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhZCB1bnRpbCBzb21ldGhpbmcgbmV3IGNvbWVzIHVwXG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50ICYmIHJlYWRlci5jdXJyLmlkLmNsb2NrICsgcmVhZGVyLmN1cnIubGVuZ3RoIDw9IHN2Q2xvY2spIHtcbiAgICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVN0cnVjdFdyaXRlcik7XG4gIC8vIHdyaXRlIGRzXG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldChkZWNvZGVyKTtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzdlxuICovXG5jb25zdCBkaWZmVXBkYXRlID0gKHVwZGF0ZSwgc3YpID0+IGRpZmZVcGRhdGVWMih1cGRhdGUsIHN2LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKi9cbmNvbnN0IGZsdXNoTGF6eVN0cnVjdFdyaXRlciA9IGxhenlXcml0ZXIgPT4ge1xuICBpZiAobGF6eVdyaXRlci53cml0dGVuID4gMCkge1xuICAgIGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5wdXNoKHsgd3JpdHRlbjogbGF6eVdyaXRlci53cml0dGVuLCByZXN0RW5jb2RlcjogdG9VaW50OEFycmF5KGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlcikgfSk7XG4gICAgbGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIGxhenlXcml0ZXIud3JpdHRlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKiBAcGFyYW0ge0l0ZW0gfCBHQ30gc3RydWN0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyID0gKGxhenlXcml0ZXIsIHN0cnVjdCwgb2Zmc2V0KSA9PiB7XG4gIC8vIGZsdXNoIGN1cnIgaWYgd2Ugc3RhcnQgYW5vdGhlciBjbGllbnRcbiAgaWYgKGxhenlXcml0ZXIud3JpdHRlbiA+IDAgJiYgbGF6eVdyaXRlci5jdXJyQ2xpZW50ICE9PSBzdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgZmx1c2hMYXp5U3RydWN0V3JpdGVyKGxhenlXcml0ZXIpO1xuICB9XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPT09IDApIHtcbiAgICBsYXp5V3JpdGVyLmN1cnJDbGllbnQgPSBzdHJ1Y3QuaWQuY2xpZW50O1xuICAgIC8vIHdyaXRlIG5leHQgY2xpZW50XG4gICAgbGF6eVdyaXRlci5lbmNvZGVyLndyaXRlQ2xpZW50KHN0cnVjdC5pZC5jbGllbnQpO1xuICAgIC8vIHdyaXRlIHN0YXJ0Q2xvY2tcbiAgICB3cml0ZVZhclVpbnQobGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyLCBzdHJ1Y3QuaWQuY2xvY2sgKyBvZmZzZXQpO1xuICB9XG4gIHN0cnVjdC53cml0ZShsYXp5V3JpdGVyLmVuY29kZXIsIG9mZnNldCk7XG4gIGxhenlXcml0ZXIud3JpdHRlbisrO1xufTtcbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gd2UgY29sbGVjdGVkIGFsbCBwYXJ0cyBhbmQgd2FudCB0b1xuICogcHV0IGFsbCB0aGUgcGFydHMgdG9nZXRoZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gKiB5b3UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBVcGRhdGVFbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICovXG5jb25zdCBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyA9IChsYXp5V3JpdGVyKSA9PiB7XG4gIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKTtcblxuICAvLyB0aGlzIGlzIGEgZnJlc2ggZW5jb2RlciBiZWNhdXNlIHdlIGNhbGxlZCBmbHVzaEN1cnJcbiAgY29uc3QgcmVzdEVuY29kZXIgPSBsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXI7XG5cbiAgLyoqXG4gICAqIE5vdyB3ZSBwdXQgYWxsIHRoZSBmcmFnbWVudHMgdG9nZXRoZXIuXG4gICAqIFRoaXMgd29ya3Mgc2ltaWxhcmx5IHRvIGB3cml0ZUNsaWVudHNTdHJ1Y3RzYFxuICAgKi9cblxuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZCAtIGkuZS4gdGhlIGNsaWVudHNcbiAgd3JpdGVWYXJVaW50KHJlc3RFbmNvZGVyLCBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHMubGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcnRTdHJ1Y3RzID0gbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzW2ldO1xuICAgIC8qKlxuICAgICAqIFdvcmtzIHNpbWlsYXJseSB0byBgd3JpdGVTdHJ1Y3RzYFxuICAgICAqL1xuICAgIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gICAgd3JpdGVWYXJVaW50KHJlc3RFbmNvZGVyLCBwYXJ0U3RydWN0cy53cml0dGVuKTtcbiAgICAvLyB3cml0ZSB0aGUgcmVzdCBvZiB0aGUgZnJhZ21lbnRcbiAgICB3cml0ZVVpbnQ4QXJyYXkocmVzdEVuY29kZXIsIHBhcnRTdHJ1Y3RzLnJlc3RFbmNvZGVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBZRXZlbnQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVR5cGUuXG4gKi9cbmNsYXNzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0YXJnZXQgVGhlIGNoYW5nZWQgdHlwZS5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHRyYW5zYWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb24gd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdGFyZ2V0IG9uIHdoaWNoIHRoZSBvYnNlcnZlIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX2NoYW5nZXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgTWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueSwgbmV3VmFsdWU6IGFueSB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9rZXlzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEFycmF5PHsgaW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2RlbHRhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgcGF0aCBmcm9tIGB5YCB0byB0aGUgY2hhbmdlZCB0eXBlLlxuICAgKlxuICAgKiBAdG9kbyB2MTQgc2hvdWxkIHN0YW5kYXJkaXplIG9uIHBhdGg6IEFycmF5PHtwYXJlbnQsIGluZGV4fT4gYmVjYXVzZSB0aGF0IGlzIGVhc2llciB0byB3b3JrIHdpdGguXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydHkgaG9sZHM6XG4gICAqIEBleGFtcGxlXG4gICAqICAgbGV0IHR5cGUgPSB5XG4gICAqICAgZXZlbnQucGF0aC5mb3JFYWNoKGRpciA9PiB7XG4gICAqICAgICB0eXBlID0gdHlwZS5nZXQoZGlyKVxuICAgKiAgIH0pXG4gICAqICAgdHlwZSA9PT0gZXZlbnQudGFyZ2V0IC8vID0+IHRydWVcbiAgICovXG4gIGdldCBwYXRoICgpIHtcbiAgICAvLyBAdHMtaWdub3JlIF9pdGVtIGlzIGRlZmluZWQgYmVjYXVzZSB0YXJnZXQgaXMgaW50ZWdyYXRlZFxuICAgIHJldHVybiBnZXRQYXRoVG8odGhpcy5jdXJyZW50VGFyZ2V0LCB0aGlzLnRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBkZWxldGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGRlbGV0ZXMgKHN0cnVjdCkge1xuICAgIHJldHVybiBpc0RlbGV0ZWQodGhpcy50cmFuc2FjdGlvbi5kZWxldGVTZXQsIHN0cnVjdC5pZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueSwgbmV3VmFsdWU6IGFueSB9Pn1cbiAgICovXG4gIGdldCBrZXlzICgpIHtcbiAgICBpZiAodGhpcy5fa2V5cyA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgY29uc3QgY2hhbmdlZCA9IC8qKiBAdHlwZSBTZXQ8c3RyaW5nfG51bGw+ICovICh0aGlzLnRyYW5zYWN0aW9uLmNoYW5nZWQuZ2V0KHRhcmdldCkpO1xuICAgICAgY2hhbmdlZC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAodGFyZ2V0Ll9tYXAuZ2V0KGtleSkpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHsnZGVsZXRlJyB8ICdhZGQnIHwgJ3VwZGF0ZSd9XG4gICAgICAgICAgICovXG4gICAgICAgICAgbGV0IGFjdGlvbjtcbiAgICAgICAgICBsZXQgb2xkVmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBpdGVtLmxlZnQ7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmFkZHMocHJldikpIHtcbiAgICAgICAgICAgICAgcHJldiA9IHByZXYubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwgJiYgdGhpcy5kZWxldGVzKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBsYXN0KHByZXYuY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmRlbGV0ZXMocHJldikpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAndXBkYXRlJztcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGxhc3QocHJldi5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2FkZCc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgb2xkVmFsdWUgPSBsYXN0KC8qKiBAdHlwZSB7SXRlbX0gKi8gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gLy8gbm9wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleXMuc2V0KGtleSwgeyBhY3Rpb24sIG9sZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2V5c1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+fT59XG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZXMuZGVsdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBhZGRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhZGRzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gc3RydWN0LmlkLmNsb2NrID49ICh0aGlzLnRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChzdHJ1Y3QuaWQuY2xpZW50KSB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ/OkFycmF5PGFueT58c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXJ9Pn19XG4gICAqL1xuICBnZXQgY2hhbmdlcyAoKSB7XG4gICAgbGV0IGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzO1xuICAgIGlmIChjaGFuZ2VzID09PSBudWxsKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIGNvbnN0IGFkZGVkID0gY3JlYXRlJDEoKTtcbiAgICAgIGNvbnN0IGRlbGV0ZWQgPSBjcmVhdGUkMSgpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydDpBcnJheTxhbnk+fXx7ZGVsZXRlOm51bWJlcn18e3JldGFpbjpudW1iZXJ9Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICAgIGNoYW5nZXMgPSB7XG4gICAgICAgIGFkZGVkLFxuICAgICAgICBkZWxldGVkLFxuICAgICAgICBkZWx0YSxcbiAgICAgICAga2V5czogdGhpcy5rZXlzXG4gICAgICB9O1xuICAgICAgY29uc3QgY2hhbmdlZCA9IC8qKiBAdHlwZSBTZXQ8c3RyaW5nfG51bGw+ICovICh0aGlzLnRyYW5zYWN0aW9uLmNoYW5nZWQuZ2V0KHRhcmdldCkpO1xuICAgICAgaWYgKGNoYW5nZWQuaGFzKG51bGwpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGxhc3RPcCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhY2tPcCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAobGFzdE9wKSB7XG4gICAgICAgICAgICBkZWx0YS5wdXNoKGxhc3RPcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpdGVtID0gdGFyZ2V0Ll9zdGFydDsgaXRlbSAhPT0gbnVsbDsgaXRlbSA9IGl0ZW0ucmlnaHQpIHtcbiAgICAgICAgICBpZiAoaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pICYmICF0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AuZGVsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IGRlbGV0ZTogMCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5kZWxldGUgKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIGRlbGV0ZWQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfSAvLyBlbHNlIG5vcFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLmluc2VydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKCk7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyBpbnNlcnQ6IFtdIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLmluc2VydCA9IGxhc3RPcC5pbnNlcnQuY29uY2F0KGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICBhZGRlZC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5yZXRhaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgcmV0YWluOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLnJldGFpbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RPcCAhPT0gbnVsbCAmJiBsYXN0T3AucmV0YWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNoYW5nZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwYXRoIGZyb20gdGhpcyB0eXBlIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIGBjaGlsZGAgc2hvdWxkIGJlIGFjY2Vzc2libGUgdmlhIGB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSkuLmBcbiAqICAgY29uc3QgcGF0aCA9IHR5cGUuZ2V0UGF0aFRvKGNoaWxkKVxuICogICAvLyBhc3N1bWluZyBgdHlwZSBpbnN0YW5jZW9mIFlBcnJheWBcbiAqICAgY29uc29sZS5sb2cocGF0aCkgLy8gbWlnaHQgbG9vayBsaWtlID0+IFsyLCAna2V5MSddXG4gKiAgIGNoaWxkID09PSB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSlcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IGNoaWxkIHRhcmdldFxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG51bWJlcj59IFBhdGggdG8gdGhlIHRhcmdldFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0UGF0aFRvID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICB3aGlsZSAoY2hpbGQuX2l0ZW0gIT09IG51bGwgJiYgY2hpbGQgIT09IHBhcmVudCkge1xuICAgIGlmIChjaGlsZC5faXRlbS5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBtYXAtaXNoXG4gICAgICBwYXRoLnVuc2hpZnQoY2hpbGQuX2l0ZW0ucGFyZW50U3ViKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIGFycmF5LWlzaFxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IGMgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQuX2l0ZW0ucGFyZW50KS5fc3RhcnQ7XG4gICAgICB3aGlsZSAoYyAhPT0gY2hpbGQuX2l0ZW0gJiYgYyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWMuZGVsZXRlZCkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBjID0gYy5yaWdodDtcbiAgICAgIH1cbiAgICAgIHBhdGgudW5zaGlmdChpKTtcbiAgICB9XG4gICAgY2hpbGQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQuX2l0ZW0ucGFyZW50KTtcbiAgfVxuICByZXR1cm4gcGF0aFxufTtcblxuY29uc3QgbWF4U2VhcmNoTWFya2VyID0gODA7XG5cbi8qKlxuICogQSB1bmlxdWUgdGltZXN0YW1wIHRoYXQgaWRlbnRpZmllcyBlYWNoIG1hcmtlci5cbiAqXG4gKiBUaW1lIGlzIHJlbGF0aXZlLC4uIHRoaXMgaXMgbW9yZSBsaWtlIGFuIGV2ZXItaW5jcmVhc2luZyBjbG9jay5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5sZXQgZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wID0gMDtcblxuY2xhc3MgQXJyYXlTZWFyY2hNYXJrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfSBwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHAsIGluZGV4KSB7XG4gICAgcC5tYXJrZXIgPSB0cnVlO1xuICAgIHRoaXMucCA9IHA7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5U2VhcmNoTWFya2VyfSBtYXJrZXJcbiAqL1xuY29uc3QgcmVmcmVzaE1hcmtlclRpbWVzdGFtcCA9IG1hcmtlciA9PiB7IG1hcmtlci50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArKzsgfTtcblxuLyoqXG4gKiBUaGlzIGlzIHJhdGhlciBjb21wbGV4IHNvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9ubHkgdGhpbmcgdGhhdCBzaG91bGQgb3ZlcndyaXRlIGEgbWFya2VyXG4gKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKiBAcGFyYW0ge0l0ZW19IHBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBvdmVyd3JpdGVNYXJrZXIgPSAobWFya2VyLCBwLCBpbmRleCkgPT4ge1xuICBtYXJrZXIucC5tYXJrZXIgPSBmYWxzZTtcbiAgbWFya2VyLnAgPSBwO1xuICBwLm1hcmtlciA9IHRydWU7XG4gIG1hcmtlci5pbmRleCA9IGluZGV4O1xuICBtYXJrZXIudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG1hcmtQb3NpdGlvbiA9IChzZWFyY2hNYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIGlmIChzZWFyY2hNYXJrZXIubGVuZ3RoID49IG1heFNlYXJjaE1hcmtlcikge1xuICAgIC8vIG92ZXJyaWRlIG9sZGVzdCBtYXJrZXIgKHdlIGRvbid0IHdhbnQgdG8gY3JlYXRlIG1vcmUgb2JqZWN0cylcbiAgICBjb25zdCBtYXJrZXIgPSBzZWFyY2hNYXJrZXIucmVkdWNlKChhLCBiKSA9PiBhLnRpbWVzdGFtcCA8IGIudGltZXN0YW1wID8gYSA6IGIpO1xuICAgIG92ZXJ3cml0ZU1hcmtlcihtYXJrZXIsIHAsIGluZGV4KTtcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICBjb25zdCBwbSA9IG5ldyBBcnJheVNlYXJjaE1hcmtlcihwLCBpbmRleCk7XG4gICAgc2VhcmNoTWFya2VyLnB1c2gocG0pO1xuICAgIHJldHVybiBwbVxuICB9XG59O1xuXG4vKipcbiAqIFNlYXJjaCBtYXJrZXIgaGVscCB1cyB0byBmaW5kIHBvc2l0aW9ucyBpbiB0aGUgYXNzb2NpYXRpdmUgYXJyYXkgZmFzdGVyLlxuICpcbiAqIFRoZXkgc3BlZWQgdXAgdGhlIHByb2Nlc3Mgb2YgZmluZGluZyBhIHBvc2l0aW9uIHdpdGhvdXQgbXVjaCBib29ra2VlcGluZy5cbiAqXG4gKiBBIG1heGltdW0gb2YgYG1heFNlYXJjaE1hcmtlcmAgb2JqZWN0cyBhcmUgY3JlYXRlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgcmVmcmVzaGVkIG1hcmtlciAodXBkYXRlZCB0aW1lc3RhbXApXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0geWFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3QgZmluZE1hcmtlciA9ICh5YXJyYXksIGluZGV4KSA9PiB7XG4gIGlmICh5YXJyYXkuX3N0YXJ0ID09PSBudWxsIHx8IGluZGV4ID09PSAwIHx8IHlhcnJheS5fc2VhcmNoTWFya2VyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBtYXJrZXIgPSB5YXJyYXkuX3NlYXJjaE1hcmtlci5sZW5ndGggPT09IDAgPyBudWxsIDogeWFycmF5Ll9zZWFyY2hNYXJrZXIucmVkdWNlKChhLCBiKSA9PiBhYnMoaW5kZXggLSBhLmluZGV4KSA8IGFicyhpbmRleCAtIGIuaW5kZXgpID8gYSA6IGIpO1xuICBsZXQgcCA9IHlhcnJheS5fc3RhcnQ7XG4gIGxldCBwaW5kZXggPSAwO1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgcCA9IG1hcmtlci5wO1xuICAgIHBpbmRleCA9IG1hcmtlci5pbmRleDtcbiAgICByZWZyZXNoTWFya2VyVGltZXN0YW1wKG1hcmtlcik7IC8vIHdlIHVzZWQgaXQsIHdlIG1pZ2h0IG5lZWQgdG8gdXNlIGl0IGFnYWluXG4gIH1cbiAgLy8gaXRlcmF0ZSB0byByaWdodCBpZiBwb3NzaWJsZVxuICB3aGlsZSAocC5yaWdodCAhPT0gbnVsbCAmJiBwaW5kZXggPCBpbmRleCkge1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBwaW5kZXggKyBwLmxlbmd0aCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGluZGV4ICs9IHAubGVuZ3RoO1xuICAgIH1cbiAgICBwID0gcC5yaWdodDtcbiAgfVxuICAvLyBpdGVyYXRlIHRvIGxlZnQgaWYgbmVjZXNzYXJ5IChtaWdodCBiZSB0aGF0IHBpbmRleCA+IGluZGV4KVxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHBpbmRleCA+IGluZGV4KSB7XG4gICAgcCA9IHAubGVmdDtcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgcGluZGV4IC09IHAubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHAgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggbGVmdCwgYmVjYXVzZSB0aGF0IHdvdWxkIHNjcmV3IHVwIGV2ZXJ5dGhpbmdcbiAgLy8gaW4gdGhhdCBjYXMganVzdCByZXR1cm4gd2hhdCB3ZSBoYXZlIChpdCBpcyBtb3N0IGxpa2VseSB0aGUgYmVzdCBtYXJrZXIgYW55d2F5KVxuICAvLyBpdGVyYXRlIHRvIGxlZnQgdW50aWwgcCBjYW4ndCBiZSBtZXJnZWQgd2l0aCBsZWZ0XG4gIHdoaWxlIChwLmxlZnQgIT09IG51bGwgJiYgcC5sZWZ0LmlkLmNsaWVudCA9PT0gcC5pZC5jbGllbnQgJiYgcC5sZWZ0LmlkLmNsb2NrICsgcC5sZWZ0Lmxlbmd0aCA9PT0gcC5pZC5jbG9jaykge1xuICAgIHAgPSBwLmxlZnQ7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIHBpbmRleCAtPSBwLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICAvLyBAdG9kbyByZW1vdmUhXG4gIC8vIGFzc3VyZSBwb3NpdGlvblxuICAvLyB7XG4gIC8vICAgbGV0IHN0YXJ0ID0geWFycmF5Ll9zdGFydFxuICAvLyAgIGxldCBwb3MgPSAwXG4gIC8vICAgd2hpbGUgKHN0YXJ0ICE9PSBwKSB7XG4gIC8vICAgICBpZiAoIXN0YXJ0LmRlbGV0ZWQgJiYgc3RhcnQuY291bnRhYmxlKSB7XG4gIC8vICAgICAgIHBvcyArPSBzdGFydC5sZW5ndGhcbiAgLy8gICAgIH1cbiAgLy8gICAgIHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RhcnQucmlnaHQpXG4gIC8vICAgfVxuICAvLyAgIGlmIChwb3MgIT09IHBpbmRleCkge1xuICAvLyAgICAgZGVidWdnZXJcbiAgLy8gICAgIHRocm93IG5ldyBFcnJvcignR290Y2hhIHBvc2l0aW9uIGZhaWwhJylcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy8gaWYgKG1hcmtlcikge1xuICAvLyAgIGlmICh3aW5kb3cubGVuZ3RoZXMgPT0gbnVsbCkge1xuICAvLyAgICAgd2luZG93Lmxlbmd0aGVzID0gW11cbiAgLy8gICAgIHdpbmRvdy5nZXRMZW5ndGhlcyA9ICgpID0+IHdpbmRvdy5sZW5ndGhlcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgLy8gICB9XG4gIC8vICAgd2luZG93Lmxlbmd0aGVzLnB1c2gobWFya2VyLmluZGV4IC0gcGluZGV4KVxuICAvLyAgIGNvbnNvbGUubG9nKCdkaXN0YW5jZScsIG1hcmtlci5pbmRleCAtIHBpbmRleCwgJ2xlbicsIHAgJiYgcC5wYXJlbnQubGVuZ3RoKVxuICAvLyB9XG4gIGlmIChtYXJrZXIgIT09IG51bGwgJiYgYWJzKG1hcmtlci5pbmRleCAtIHBpbmRleCkgPCAvKiogQHR5cGUge1lUZXh0fFlBcnJheTxhbnk+fSAqLyAocC5wYXJlbnQpLmxlbmd0aCAvIG1heFNlYXJjaE1hcmtlcikge1xuICAgIC8vIGFkanVzdCBleGlzdGluZyBtYXJrZXJcbiAgICBvdmVyd3JpdGVNYXJrZXIobWFya2VyLCBwLCBwaW5kZXgpO1xuICAgIHJldHVybiBtYXJrZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgbmV3IG1hcmtlclxuICAgIHJldHVybiBtYXJrUG9zaXRpb24oeWFycmF5Ll9zZWFyY2hNYXJrZXIsIHAsIHBpbmRleClcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgbWFya2VycyB3aGVuIGEgY2hhbmdlIGhhcHBlbmVkLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgZG9pbmcgYSBkZWxldGlvbiFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn0gc2VhcmNoTWFya2VyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gSWYgaW5zZXJ0aW9uLCBsZW4gaXMgcG9zaXRpdmUuIElmIGRlbGV0aW9uLCBsZW4gaXMgbmVnYXRpdmUuXG4gKi9cbmNvbnN0IHVwZGF0ZU1hcmtlckNoYW5nZXMgPSAoc2VhcmNoTWFya2VyLCBpbmRleCwgbGVuKSA9PiB7XG4gIGZvciAobGV0IGkgPSBzZWFyY2hNYXJrZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBtID0gc2VhcmNoTWFya2VyW2ldO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCBwID0gbS5wO1xuICAgICAgcC5tYXJrZXIgPSBmYWxzZTtcbiAgICAgIC8vIElkZWFsbHkgd2UganVzdCB3YW50IHRvIGRvIGEgc2ltcGxlIHBvc2l0aW9uIGNvbXBhcmlzb24sIGJ1dCB0aGlzIHdpbGwgb25seSB3b3JrIGlmXG4gICAgICAvLyBzZWFyY2ggbWFya2VycyBkb24ndCBwb2ludCB0byBkZWxldGVkIGl0ZW1zIGZvciBmb3JtYXRzLlxuICAgICAgLy8gSXRlcmF0ZSBtYXJrZXIgdG8gcHJldiB1bmRlbGV0ZWQgY291bnRhYmxlIHBvc2l0aW9uIHNvIHdlIGtub3cgd2hhdCB0byBkbyB3aGVuIHVwZGF0aW5nIGEgcG9zaXRpb25cbiAgICAgIHdoaWxlIChwICYmIChwLmRlbGV0ZWQgfHwgIXAuY291bnRhYmxlKSkge1xuICAgICAgICBwID0gcC5sZWZ0O1xuICAgICAgICBpZiAocCAmJiAhcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICAgICAgLy8gYWRqdXN0IHBvc2l0aW9uLiB0aGUgbG9vcCBzaG91bGQgYnJlYWsgbm93XG4gICAgICAgICAgbS5pbmRleCAtPSBwLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHAgPT09IG51bGwgfHwgcC5tYXJrZXIgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHNlYXJjaCBtYXJrZXIgaWYgdXBkYXRlZCBwb3NpdGlvbiBpcyBudWxsIG9yIGlmIHBvc2l0aW9uIGlzIGFscmVhZHkgbWFya2VkXG4gICAgICAgIHNlYXJjaE1hcmtlci5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBtLnAgPSBwO1xuICAgICAgcC5tYXJrZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCBtLmluZGV4IHx8IChsZW4gPiAwICYmIGluZGV4ID09PSBtLmluZGV4KSkgeyAvLyBhIHNpbXBsZSBpbmRleCA8PSBtLmluZGV4IGNoZWNrIHdvdWxkIGFjdHVhbGx5IHN1ZmZpY2VcbiAgICAgIG0uaW5kZXggPSBtYXgoaW5kZXgsIG0uaW5kZXggKyBsZW4pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlIGFsbCAobGlzdCkgY2hpbGRyZW4gb2YgYSB0eXBlIGFuZCByZXR1cm4gdGhlbSBhcyBhbiBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0XG4gKiBAcmV0dXJuIHtBcnJheTxJdGVtPn1cbiAqL1xuY29uc3QgZ2V0VHlwZUNoaWxkcmVuID0gdCA9PiB7XG4gIGxldCBzID0gdC5fc3RhcnQ7XG4gIGNvbnN0IGFyciA9IFtdO1xuICB3aGlsZSAocykge1xuICAgIGFyci5wdXNoKHMpO1xuICAgIHMgPSBzLnJpZ2h0O1xuICB9XG4gIHJldHVybiBhcnJcbn07XG5cbi8qKlxuICogQ2FsbCBldmVudCBsaXN0ZW5lcnMgd2l0aCBhbiBldmVudC4gVGhpcyB3aWxsIGFsc28gYWRkIGFuIGV2ZW50IHRvIGFsbFxuICogcGFyZW50cyAoZm9yIGAub2JzZXJ2ZURlZXBgIGhhbmRsZXJzKS5cbiAqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxFdmVudFR5cGU+fSB0eXBlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtFdmVudFR5cGV9IGV2ZW50XG4gKi9cbmNvbnN0IGNhbGxUeXBlT2JzZXJ2ZXJzID0gKHR5cGUsIHRyYW5zYWN0aW9uLCBldmVudCkgPT4ge1xuICBjb25zdCBjaGFuZ2VkVHlwZSA9IHR5cGU7XG4gIGNvbnN0IGNoYW5nZWRQYXJlbnRUeXBlcyA9IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2V0SWZVbmRlZmluZWQoY2hhbmdlZFBhcmVudFR5cGVzLCB0eXBlLCAoKSA9PiBbXSkucHVzaChldmVudCk7XG4gICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodHlwZS5faXRlbS5wYXJlbnQpO1xuICB9XG4gIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMoY2hhbmdlZFR5cGUuX2VILCBldmVudCwgdHJhbnNhY3Rpb24pO1xufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBBYnN0cmFjdCBZanMgVHlwZSBjbGFzc1xuICovXG5jbGFzcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXJzXG4gICAgICogQHR5cGUge0V2ZW50SGFuZGxlcjxFdmVudFR5cGUsVHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX2VIID0gY3JlYXRlRXZlbnRIYW5kbGVyKCk7XG4gICAgLyoqXG4gICAgICogRGVlcCBldmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8QXJyYXk8WUV2ZW50PixUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fZEVIID0gY3JlYXRlRXZlbnRIYW5kbGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59XG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoTWFya2VyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8YW55PnxudWxsfVxuICAgKi9cbiAgZ2V0IHBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW0gPyAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5faXRlbS5wYXJlbnQpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgdGhpcy5kb2MgPSB5O1xuICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0VHlwZTxFdmVudFR5cGU+fVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0VHlwZTxFdmVudFR5cGU+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHsgfVxuXG4gIC8qKlxuICAgKiBUaGUgZmlyc3Qgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IF9maXJzdCAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gblxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWUV2ZW50IGFuZCBjYWxscyBhbGwgdHlwZSBvYnNlcnZlcnMuXG4gICAqIE11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRoaXMuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdGhpcy5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIG9uIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudFR5cGUsIFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlIChmKSB7XG4gICAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIGJ5IHRoaXMgdHlwZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudD4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIG9ic2VydmVEZWVwIChmKSB7XG4gICAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZEVILCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50VHlwZSxUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgdW5vYnNlcnZlIChmKSB7XG4gICAgcmVtb3ZlRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQXJyYXk8WUV2ZW50PixUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgdW5vYnNlcnZlRGVlcCAoZikge1xuICAgIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHRvSlNPTiAoKSB7fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0U2xpY2UgPSAodHlwZSwgc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0eXBlLl9sZW5ndGggKyBzdGFydDtcbiAgfVxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IHR5cGUuX2xlbmd0aCArIGVuZDtcbiAgfVxuICBsZXQgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsICYmIGxlbiA+IDApIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBpZiAoYy5sZW5ndGggPD0gc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgLT0gYy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjLmxlbmd0aCAmJiBsZW4gPiAwOyBpKyspIHtcbiAgICAgICAgICBjcy5wdXNoKGNbaV0pO1xuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFRvQXJyYXkgPSB0eXBlID0+IHtcbiAgY29uc3QgY3MgPSBbXTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3MucHVzaChjW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RUb0FycmF5U25hcHNob3QgPSAodHlwZSwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgY3MgPSBbXTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3MucHVzaChjW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNzXG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBvdmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LG51bWJlcixhbnkpOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEZvckVhY2ggPSAodHlwZSwgZikgPT4ge1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmKGNbaV0sIGluZGV4KyssIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgQyxSXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEMsbnVtYmVyLEFic3RyYWN0VHlwZTxhbnk+KTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0TWFwID0gKHR5cGUsIGYpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHR5cGVMaXN0Rm9yRWFjaCh0eXBlLCAoYywgaSkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKGYoYywgaSwgdHlwZSkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdENyZWF0ZUl0ZXJhdG9yID0gdHlwZSA9PiB7XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55PnxudWxsfVxuICAgKi9cbiAgbGV0IGN1cnJlbnRDb250ZW50ID0gbnVsbDtcbiAgbGV0IGN1cnJlbnRDb250ZW50SW5kZXggPSAwO1xuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAvLyBmaW5kIHNvbWUgY29udGVudFxuICAgICAgaWYgKGN1cnJlbnRDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgICAgIG4gPSBuLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCwgbm8gbmVlZCB0byBjaGVjayBjdXJyZW50Q29udGVudCwgYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdFxuICAgICAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBmb3VuZCBuLCBzbyB3ZSBjYW4gc2V0IGN1cnJlbnRDb250ZW50XG4gICAgICAgIGN1cnJlbnRDb250ZW50ID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgICAgY3VycmVudENvbnRlbnRJbmRleCA9IDA7XG4gICAgICAgIG4gPSBuLnJpZ2h0OyAvLyB3ZSB1c2VkIHRoZSBjb250ZW50IG9mIG4sIG5vdyBpdGVyYXRlIHRvIG5leHRcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudENvbnRlbnRbY3VycmVudENvbnRlbnRJbmRleCsrXTtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZW1wdHkgY3VycmVudENvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudC5sZW5ndGggPD0gY3VycmVudENvbnRlbnRJbmRleCkge1xuICAgICAgICBjdXJyZW50Q29udGVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHthbnl9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEdldCA9ICh0eXBlLCBpbmRleCkgPT4ge1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHR5cGUsIGluZGV4KTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IG4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuLmNvbnRlbnQuZ2V0Q29udGVudCgpW2luZGV4XVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbT99IHJlZmVyZW5jZUl0ZW1cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgcmVmZXJlbmNlSXRlbSwgY29udGVudCkgPT4ge1xuICBsZXQgbGVmdCA9IHJlZmVyZW5jZUl0ZW07XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCByaWdodCA9IHJlZmVyZW5jZUl0ZW0gPT09IG51bGwgPyBwYXJlbnQuX3N0YXJ0IDogcmVmZXJlbmNlSXRlbS5yaWdodDtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3R8QXJyYXk8YW55PnxudW1iZXI+fVxuICAgKi9cbiAgbGV0IGpzb25Db250ZW50ID0gW107XG4gIGNvbnN0IHBhY2tKc29uQ29udGVudCA9ICgpID0+IHtcbiAgICBpZiAoanNvbkNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50QW55KGpzb25Db250ZW50KSk7XG4gICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICBqc29uQ29udGVudCA9IFtdO1xuICAgIH1cbiAgfTtcbiAgY29udGVudC5mb3JFYWNoKGMgPT4ge1xuICAgIHN3aXRjaCAoYy5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICBjYXNlIE9iamVjdDpcbiAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAganNvbkNvbnRlbnQucHVzaChjKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBhY2tKc29uQ29udGVudCgpO1xuICAgICAgICBzd2l0Y2ggKGMuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgICAgY2FzZSBBcnJheUJ1ZmZlcjpcbiAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEJpbmFyeShuZXcgVWludDhBcnJheSgvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovIChjKSkpKTtcbiAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBEb2M6XG4gICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovIChjKSkpO1xuICAgICAgICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50VHlwZShjKSk7XG4gICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IHR5cGUgaW4gaW5zZXJ0IG9wZXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBwYWNrSnNvbkNvbnRlbnQoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fG51bWJlcnxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3MgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGNvbnRlbnQpID0+IHtcbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBpbmRleCwgY29udGVudC5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG51bGwsIGNvbnRlbnQpXG4gIH1cbiAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHBhcmVudCwgaW5kZXgpO1xuICBsZXQgbiA9IHBhcmVudC5fc3RhcnQ7XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnA7XG4gICAgaW5kZXggLT0gbWFya2VyLmluZGV4O1xuICAgIC8vIHdlIG5lZWQgdG8gaXRlcmF0ZSBvbmUgdG8gdGhlIGxlZnQgc28gdGhhdCB0aGUgYWxnb3JpdGhtIHdvcmtzXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAvLyBAdG9kbyByZWZhY3RvciB0aGlzIGFzIGl0IGFjdHVhbGx5IGRvZXNuJ3QgY29uc2lkZXIgZm9ybWF0c1xuICAgICAgbiA9IG4ucHJldjsgLy8gaW1wb3J0YW50ISBnZXQgdGhlIGxlZnQgdW5kZWxldGVkIGl0ZW0gc28gdGhhdCB3ZSBjYW4gYWN0dWFsbHkgZGVjcmVhc2UgaW5kZXhcbiAgICAgIGluZGV4ICs9IChuICYmIG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpID8gbi5sZW5ndGggOiAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDw9IG4ubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbmRleCA8IG4ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gaW5zZXJ0IGluLWJldHdlZW5cbiAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQobi5pZC5jbGllbnQsIG4uaWQuY2xvY2sgKyBpbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgc3RhcnRJbmRleCwgY29udGVudC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbiwgY29udGVudClcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4gIGlmIChsZW5ndGggPT09IDApIHsgcmV0dXJuIH1cbiAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuICBjb25zdCBzdGFydExlbmd0aCA9IGxlbmd0aDtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KTtcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0O1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgbiA9IG1hcmtlci5wO1xuICAgIGluZGV4IC09IG1hcmtlci5pbmRleDtcbiAgfVxuICAvLyBjb21wdXRlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIGRlbGV0ZWRcbiAgZm9yICg7IG4gIT09IG51bGwgJiYgaW5kZXggPiAwOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQobi5pZC5jbGllbnQsIG4uaWQuY2xvY2sgKyBpbmRleCkpO1xuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG4gIC8vIGRlbGV0ZSBhbGwgaXRlbXMgdW50aWwgZG9uZVxuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBuICE9PSBudWxsKSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgIGlmIChsZW5ndGggPCBuLmxlbmd0aCkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQobi5pZC5jbGllbnQsIG4uaWQuY2xvY2sgKyBsZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIG4uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIGxlbmd0aCAtPSBuLmxlbmd0aDtcbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBjcmVhdGUkMignYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkJylcbiAgfVxuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBzdGFydEluZGV4LCAtc3RhcnRMZW5ndGggKyBsZW5ndGggLyogaW4gY2FzZSB3ZSByZW1vdmUgdGhlIGFib3ZlIGV4Y2VwdGlvbiAqLyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgYyA9IHBhcmVudC5fbWFwLmdldChrZXkpO1xuICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYy5kZWxldGUodHJhbnNhY3Rpb24pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcnxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fSB2YWx1ZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcFNldCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXksIHZhbHVlKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSBwYXJlbnQuX21hcC5nZXQoa2V5KSB8fCBudWxsO1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBsZXQgY29udGVudDtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBjb250ZW50ID0gbmV3IENvbnRlbnRBbnkoW3ZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICBjYXNlIE9iamVjdDpcbiAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50QW55KFt2YWx1ZV0pO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRCaW5hcnkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAodmFsdWUpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgRG9jOlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovICh2YWx1ZSkpO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50VHlwZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRlbnQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgbnVsbCwgbnVsbCwgcGFyZW50LCBrZXksIGNvbnRlbnQpLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXQgPSAocGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWQgPyB2YWwuY29udGVudC5nZXRDb250ZW50KClbdmFsLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXRBbGwgPSAocGFyZW50KSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzID0ge307XG4gIHBhcmVudC5fbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAoIXZhbHVlLmRlbGV0ZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsdWUuY29udGVudC5nZXRDb250ZW50KClbdmFsdWUubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwSGFzID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbCA9IHBhcmVudC5fbWFwLmdldChrZXkpO1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgIXZhbC5kZWxldGVkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwR2V0U25hcHNob3QgPSAocGFyZW50LCBrZXksIHNuYXBzaG90KSA9PiB7XG4gIGxldCB2ID0gcGFyZW50Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgd2hpbGUgKHYgIT09IG51bGwgJiYgKCFzbmFwc2hvdC5zdi5oYXModi5pZC5jbGllbnQpIHx8IHYuaWQuY2xvY2sgPj0gKHNuYXBzaG90LnN2LmdldCh2LmlkLmNsaWVudCkgfHwgMCkpKSB7XG4gICAgdiA9IHYubGVmdDtcbiAgfVxuICByZXR1cm4gdiAhPT0gbnVsbCAmJiBpc1Zpc2libGUodiwgc25hcHNob3QpID8gdi5jb250ZW50LmdldENvbnRlbnQoKVt2Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxJdGVtPn0gbWFwXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPEFycmF5PGFueT4+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlTWFwSXRlcmF0b3IgPSBtYXAgPT4gaXRlcmF0b3JGaWx0ZXIobWFwLmVudHJpZXMoKSwgLyoqIEBwYXJhbSB7YW55fSBlbnRyeSAqLyBlbnRyeSA9PiAhZW50cnlbMV0uZGVsZXRlZCk7XG5cbi8qKlxuICogQG1vZHVsZSBZQXJyYXlcbiAqL1xuXG4vKipcbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWUFycmF5XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBZQXJyYXlFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lBcnJheTxUPn0geWFycmF5IFRoZSBjaGFuZ2VkIHR5cGVcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHlhcnJheSwgdHJhbnNhY3Rpb24pIHtcbiAgICBzdXBlcih5YXJyYXksIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQSBzaGFyZWQgQXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlBcnJheUV2ZW50PFQ+PlxuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFQ+fVxuICovXG5jbGFzcyBZQXJyYXkgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pj99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgWUFycmF5IGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBpdGVtcy5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gaXRlbXNcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgc3RhdGljIGZyb20gKGl0ZW1zKSB7XG4gICAgY29uc3QgYSA9IG5ldyBZQXJyYXkoKTtcbiAgICBhLnB1c2goaXRlbXMpO1xuICAgIHJldHVybiBhXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKTtcbiAgICB0aGlzLmluc2VydCgwLCAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZQXJyYXkoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgWUFycmF5KCk7XG4gICAgYXJyLmluc2VydCgwLCB0aGlzLnRvQXJyYXkoKS5tYXAoZWwgPT5cbiAgICAgIGVsIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gZWwuY2xvbmUoKSA6IGVsXG4gICAgKSk7XG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWUFycmF5RXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgc3VwZXIuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3Vicyk7XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZQXJyYXlFdmVudCh0aGlzLCB0cmFuc2FjdGlvbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEltcG9ydGFudDogVGhpcyBmdW5jdGlvbiBleHBlY3RzIGFuIGFycmF5IG9mIGNvbnRlbnQuIE5vdCBqdXN0IGEgY29udGVudFxuICAgKiBvYmplY3QuIFRoZSByZWFzb24gZm9yIHRoaXMgXCJ3ZWlyZG5lc3NcIiBpcyB0aGF0IGluc2VydGluZyBzZXZlcmFsIGVsZW1lbnRzXG4gICAqIGlzIHZlcnkgZWZmaWNpZW50IHdoZW4gaXQgaXMgZG9uZSBhcyBhIHNpbmdsZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB5YXJyYXkuaW5zZXJ0KDAsIFsnYSddKVxuICAgKiAgLy8gSW5zZXJ0IG51bWJlcnMgMSwgMiBhdCBwb3NpdGlvbiAxXG4gICAqICB5YXJyYXkuaW5zZXJ0KDEsIFsxLCAyXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdC5cbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIGFwcGVuZC5cbiAgICovXG4gIHB1c2ggKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCh0aGlzLmxlbmd0aCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBwcmVwcGVuZC5cbiAgICovXG4gIHVuc2hpZnQgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCgwLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGVsZW1lbnRzIHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZyBlbGVtZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgZGVsZXRlIChpbmRleCwgbGVuZ3RoID0gMSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3REZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnNwbGljZShpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaS10aCBlbGVtZW50IGZyb20gYSBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIFlBcnJheVxuICAgKiBAcmV0dXJuIHtUfVxuICAgKi9cbiAgZ2V0IChpbmRleCkge1xuICAgIHJldHVybiB0eXBlTGlzdEdldCh0aGlzLCBpbmRleClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8VD59XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RUb0FycmF5KHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAgICovXG4gIHNsaWNlIChzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgU2hhcmVkIFR5cGUgdG8gYSBKU09OIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGMgPT4gYyBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGMudG9KU09OKCkgOiBjKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgd2l0aCB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeVxuICAgKiBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVCxNXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTpNfSBmIEZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gZWxlbWVudCBvZiB0aGUgbmV3IEFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5PE0+fSBBIG5ldyBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIG1hcCAoZikge1xuICAgIHJldHVybiB0eXBlTGlzdE1hcCh0aGlzLCAvKiogQHR5cGUge2FueX0gKi8gKGYpKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBvdmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsbnVtYmVyLFlBcnJheTxUPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgZik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RDcmVhdGVJdGVyYXRvcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZQXJyYXlSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlBcnJheSA9IGRlY29kZXIgPT4gbmV3IFlBcnJheSgpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBFdmVudCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlNYXAuXG4gKi9cbmNsYXNzIFlNYXBFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lNYXA8VD59IHltYXAgVGhlIFlBcnJheSB0aGF0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHltYXAsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeW1hcCwgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBzdWJzO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFQgbnVtYmVyfHN0cmluZ3xPYmplY3R8QXJyYXl8VWludDhBcnJheVxuICogQSBzaGFyZWQgTWFwIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZTWFwRXZlbnQ8VD4+XG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8VD59XG4gKi9cbmNsYXNzIFlNYXAgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCBhbnldPj19IGVudHJpZXMgLSBhbiBvcHRpb25hbCBpdGVyYWJsZSB0byBpbml0aWFsaXplIHRoZSBZTWFwXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW50cmllcykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsYW55Pj99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcblxuICAgIGlmIChlbnRyaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBuZXcgTWFwKGVudHJpZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgOy8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWU1hcCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WU1hcDxUPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgWU1hcCgpO1xuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgbWFwLnNldChrZXksIHZhbHVlIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZTWFwRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZTWFwRXZlbnQodGhpcywgdHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgU2hhcmVkIFR5cGUgdG8gYSBKU09OIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxUPn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsVD59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0ge307XG4gICAgdGhpcy5fbWFwLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgdiA9IGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXTtcbiAgICAgICAgbWFwW2tleV0gPSB2IGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gdi50b0pTT04oKSA6IHY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIFlNYXAgKGNvdW50IG9mIGtleS92YWx1ZSBwYWlycylcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiBbLi4uY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKV0ubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBZTWFwIFR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8c3RyaW5nPn1cbiAgICovXG4gIGtleXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiB2WzBdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBZTWFwIFR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8YW55Pn1cbiAgICovXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMV0uY29udGVudC5nZXRDb250ZW50KClbdlsxXS5sZW5ndGggLSAxXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEl0ZXJhdG9yIG9mIFtrZXksIHZhbHVlXSBwYWlyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gICAqL1xuICBlbnRyaWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gW3ZbMF0sIHZbMV0uY29udGVudC5nZXRDb250ZW50KClbdlsxXS5sZW5ndGggLSAxXV0pXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIGV2ZXJ5IGtleS12YWx1ZSBwYWlyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsc3RyaW5nLFlNYXA8VD4pOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsVD59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0ge307XG4gICAgdGhpcy5fbWFwLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgZihpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpW2l0ZW0ubGVuZ3RoIC0gMV0sIGtleSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqL1xuICBkZWxldGUgKGtleSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywga2V5KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoaXMgWU1hcFxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGRcbiAgICovXG4gIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcFNldCh0cmFuc2FjdGlvbiwgdGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgKGtleSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywga2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXMgKGtleSkge1xuICAgIHJldHVybiB0eXBlTWFwSGFzKHRoaXMsIGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWU1hcFJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWU1hcCA9IGRlY29kZXIgPT4gbmV3IFlNYXAoKTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsQXR0cnMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIgJiYgZXF1YWxGbGF0KGEsIGIpKTtcblxuY2xhc3MgSXRlbVRleHRMaXN0UG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGxlZnRcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCwgaW5kZXgsIGN1cnJlbnRBdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZXMgPSBjdXJyZW50QXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGwgdGhpcyBpZiB5b3Uga25vdyB0aGF0IHRoaXMucmlnaHQgaXMgZGVmaW5lZFxuICAgKi9cbiAgZm9yd2FyZCAoKSB7XG4gICAgaWYgKHRoaXMucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIHVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgaWYgKCF0aGlzLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ICs9IHRoaXMucmlnaHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXModGhpcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAodGhpcy5yaWdodC5jb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5yaWdodDtcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5yaWdodC5yaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBwb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBzdGVwcyB0byBtb3ZlIGZvcndhcmRcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZE5leHRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcG9zLCBjb3VudCkgPT4ge1xuICB3aGlsZSAocG9zLnJpZ2h0ICE9PSBudWxsICYmIGNvdW50ID4gMCkge1xuICAgIHN3aXRjaCAocG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgcG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcmlnaHRcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChwb3MucmlnaHQuaWQuY2xpZW50LCBwb3MucmlnaHQuaWQuY2xvY2sgKyBjb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MuaW5kZXggKz0gcG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBjb3VudCAtPSBwb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgIGlmICghcG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhwb3MuY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKHBvcy5yaWdodC5jb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcG9zLmxlZnQgPSBwb3MucmlnaHQ7XG4gICAgcG9zLnJpZ2h0ID0gcG9zLnJpZ2h0LnJpZ2h0O1xuICAgIC8vIHBvcy5mb3J3YXJkKCkgLSB3ZSBkb24ndCBmb3J3YXJkIGJlY2F1c2UgdGhhdCB3b3VsZCBoYWx2ZSB0aGUgcGVyZm9ybWFuY2UgYmVjYXVzZSB3ZSBhbHJlYWR5IGRvIHRoZSBjaGVja3MgYWJvdmVcbiAgfVxuICByZXR1cm4gcG9zXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kUG9zaXRpb24gPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGlmIChtYXJrZXIpIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obWFya2VyLnAubGVmdCwgbWFya2VyLnAsIG1hcmtlci5pbmRleCwgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBmaW5kTmV4dFBvc2l0aW9uKHRyYW5zYWN0aW9uLCBwb3MsIGluZGV4IC0gbWFya2VyLmluZGV4KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihudWxsLCBwYXJlbnQuX3N0YXJ0LCAwLCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXgpXG4gIH1cbn07XG5cbi8qKlxuICogTmVnYXRlIGFwcGxpZWQgZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBuZWdhdGVkQXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gY2hlY2sgaWYgd2UgcmVhbGx5IG5lZWQgdG8gcmVtb3ZlIGF0dHJpYnV0ZXNcbiAgd2hpbGUgKFxuICAgIGN1cnJQb3MucmlnaHQgIT09IG51bGwgJiYgKFxuICAgICAgY3VyclBvcy5yaWdodC5kZWxldGVkID09PSB0cnVlIHx8IChcbiAgICAgICAgY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmXG4gICAgICAgIGVxdWFsQXR0cnMobmVnYXRlZEF0dHJpYnV0ZXMuZ2V0KC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkua2V5KSwgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS52YWx1ZSlcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpO1xuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBsZXQgbmV4dEZvcm1hdCA9IGN1cnJQb3MubGVmdDtcbiAgY29uc3QgcmlnaHQgPSBjdXJyUG9zLnJpZ2h0O1xuICBuZWdhdGVkQXR0cmlidXRlcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgIG5leHRGb3JtYXQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBuZXh0Rm9ybWF0LCBuZXh0Rm9ybWF0ICYmIG5leHRGb3JtYXQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKTtcbiAgICBuZXh0Rm9ybWF0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgY3VyclBvcy5yaWdodCA9IG5leHRGb3JtYXQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7Q29udGVudEZvcm1hdH0gZm9ybWF0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyA9IChjdXJyZW50QXR0cmlidXRlcywgZm9ybWF0KSA9PiB7XG4gIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZm9ybWF0O1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyA9IChjdXJyUG9zLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIC8vIGdvIHJpZ2h0IHdoaWxlIGF0dHJpYnV0ZXNbcmlnaHQua2V5XSA9PT0gcmlnaHQudmFsdWUgKG9yIHJpZ2h0IGlzIGRlbGV0ZWQpXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgfHwgKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCAmJiBlcXVhbEF0dHJzKGF0dHJpYnV0ZXNbKC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkpLmtleV0gfHwgbnVsbCwgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS52YWx1ZSkpKSA7IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge01hcDxzdHJpbmcsYW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiovXG5jb25zdCBpbnNlcnRBdHRyaWJ1dGVzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIC8vIGluc2VydCBmb3JtYXQtc3RhcnQgaXRlbXNcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHZhbCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICBjb25zdCBjdXJyZW50VmFsID0gY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgIGlmICghZXF1YWxBdHRycyhjdXJyZW50VmFsLCB2YWwpKSB7XG4gICAgICAvLyBzYXZlIG5lZ2F0ZWQgYXR0cmlidXRlIChzZXQgbnVsbCBpZiBjdXJyZW50VmFsIHVuZGVmaW5lZClcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChrZXksIGN1cnJlbnRWYWwpO1xuICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gY3VyclBvcztcbiAgICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKTtcbiAgICAgIGN1cnJQb3MucmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVnYXRlZEF0dHJpYnV0ZXNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgdGV4dCwgYXR0cmlidXRlcykgPT4ge1xuICBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGVzW2tleV0gPSBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBpbnNlcnRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICAvLyBpbnNlcnQgY29udGVudFxuICBjb25zdCBjb250ZW50ID0gdGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gbmV3IENvbnRlbnRTdHJpbmcoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0ZXh0KSkgOiBuZXcgQ29udGVudEVtYmVkKHRleHQpO1xuICBsZXQgeyBsZWZ0LCByaWdodCwgaW5kZXggfSA9IGN1cnJQb3M7XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGN1cnJQb3MuaW5kZXgsIGNvbnRlbnQuZ2V0TGVuZ3RoKCkpO1xuICB9XG4gIHJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIGNvbnRlbnQpO1xuICByaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICBjdXJyUG9zLnJpZ2h0ID0gcmlnaHQ7XG4gIGN1cnJQb3MuaW5kZXggPSBpbmRleDtcbiAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZvcm1hdFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbGVuZ3RoLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBpbnNlcnRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICAvLyBpdGVyYXRlIHVudGlsIGZpcnN0IG5vbi1mb3JtYXQgb3IgbnVsbCBpcyBmb3VuZFxuICAvLyBkZWxldGUgYWxsIGZvcm1hdHMgd2l0aCBhdHRyaWJ1dGVzW2Zvcm1hdC5rZXldICE9IG51bGxcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgY3VyclBvcy5yaWdodCAhPT0gbnVsbCkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgY3VyclBvcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjdXJyUG9zLnJpZ2h0LmlkLmNsaWVudCwgY3VyclBvcy5yaWdodC5pZC5jbG9jayArIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgLy8gUXVpbGwganVzdCBhc3N1bWVzIHRoYXQgdGhlIGVkaXRvciBzdGFydHMgd2l0aCBhIG5ld2xpbmUgYW5kIHRoYXQgaXQgYWx3YXlzXG4gIC8vIGVuZHMgd2l0aCBhIG5ld2xpbmUuIFdlIG9ubHkgaW5zZXJ0IHRoYXQgbmV3bGluZSB3aGVuIGEgbmV3IG5ld2xpbmUgaXNcbiAgLy8gaW5zZXJ0ZWQgLSBpLmUgd2hlbiBsZW5ndGggaXMgYmlnZ2VyIHRoYW4gdHlwZS5sZW5ndGhcbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICBsZXQgbmV3bGluZXMgPSAnJztcbiAgICBmb3IgKDsgbGVuZ3RoID4gMDsgbGVuZ3RoLS0pIHtcbiAgICAgIG5ld2xpbmVzICs9ICdcXG4nO1xuICAgIH1cbiAgICBjdXJyUG9zLnJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgY3VyclBvcy5sZWZ0LCBjdXJyUG9zLmxlZnQgJiYgY3VyclBvcy5sZWZ0Lmxhc3RJZCwgY3VyclBvcy5yaWdodCwgY3VyclBvcy5yaWdodCAmJiBjdXJyUG9zLnJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50U3RyaW5nKG5ld2xpbmVzKSk7XG4gICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbn07XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIHN0cmluZyBjb250ZW50IGhhcyBiZWVuIGRlbGV0ZWQgaW4gb3JkZXIgdG9cbiAqIGNsZWFuIHVwIGZvcm1hdHRpbmcgSXRlbXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gc3RhcnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBlbmQgZXhjbHVzaXZlIGVuZCwgYXV0b21hdGljYWxseSBpdGVyYXRlcyB0byB0aGUgbmV4dCBDb250ZW50IEl0ZW1cbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBzdGFydEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBlbmRBdHRyaWJ1dGVzIFRoaXMgYXR0cmlidXRlIGlzIG1vZGlmaWVkIVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIGZvcm1hdHRpbmcgSXRlbXMgZGVsZXRlZC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY2xlYW51cEZvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIHN0YXJ0LCBlbmQsIHN0YXJ0QXR0cmlidXRlcywgZW5kQXR0cmlidXRlcykgPT4ge1xuICB3aGlsZSAoZW5kICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50U3RyaW5nICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50RW1iZWQpIHtcbiAgICBpZiAoIWVuZC5kZWxldGVkICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KSB7XG4gICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhlbmRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChlbmQuY29udGVudCkpO1xuICAgIH1cbiAgICBlbmQgPSBlbmQucmlnaHQ7XG4gIH1cbiAgbGV0IGNsZWFudXBzID0gMDtcbiAgd2hpbGUgKHN0YXJ0ICE9PSBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0LmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBzdGFydC5jb250ZW50O1xuICAgICAgc3dpdGNoIChjb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudCk7XG4gICAgICAgICAgaWYgKChlbmRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGwpICE9PSB2YWx1ZSB8fCAoc3RhcnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGwpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRWl0aGVyIHRoaXMgZm9ybWF0IGlzIG92ZXJ3cml0dGVuIG9yIGl0IGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYXR0cmlidXRlIGFscmVhZHkgZXhpc3RlZC5cbiAgICAgICAgICAgIHN0YXJ0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjbGVhbnVwcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RhcnQucmlnaHQpO1xuICB9XG4gIHJldHVybiBjbGVhbnVwc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gaXRlbVxuICovXG5jb25zdCBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwID0gKHRyYW5zYWN0aW9uLCBpdGVtKSA9PiB7XG4gIC8vIGl0ZXJhdGUgdW50aWwgaXRlbS5yaWdodCBpcyBudWxsIG9yIGNvbnRlbnRcbiAgd2hpbGUgKGl0ZW0gJiYgaXRlbS5yaWdodCAmJiAoaXRlbS5yaWdodC5kZWxldGVkIHx8IChpdGVtLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRTdHJpbmcgJiYgaXRlbS5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50RW1iZWQpKSkge1xuICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICB9XG4gIGNvbnN0IGF0dHJzID0gbmV3IFNldCgpO1xuICAvLyBpdGVyYXRlIGJhY2sgdW50aWwgYSBjb250ZW50IGl0ZW0gaXMgZm91bmRcbiAgd2hpbGUgKGl0ZW0gJiYgKGl0ZW0uZGVsZXRlZCB8fCAoaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50U3RyaW5nICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciAhPT0gQ29udGVudEVtYmVkKSkpIHtcbiAgICBpZiAoIWl0ZW0uZGVsZXRlZCAmJiBpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGl0ZW0uY29udGVudCkua2V5O1xuICAgICAgaWYgKGF0dHJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVtID0gaXRlbS5sZWZ0O1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSAvIGJlIHJlbW92ZWQuXG4gKlxuICogSWRlYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGZ1bmN0aW9uIGF0IGFsbC4gRm9ybWF0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBjbGVhbmVkIHVwXG4gKiBhdXRvbWF0aWNhbGx5IGFmdGVyIGVhY2ggY2hhbmdlLiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHR3aWNlIG92ZXIgdGhlIGNvbXBsZXRlIFlUZXh0IHR5cGVcbiAqIGFuZCByZW1vdmVzIHVubmVjZXNzYXJ5IGZvcm1hdHRpbmcgYXR0cmlidXRlcy4gVGhpcyBpcyBhbHNvIGhlbHBmdWwgZm9yIHRlc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBleHBvcnRlZCBhbnltb3JlIGFzIHNvb24gYXMgdGhlcmUgaXMgY29uZmlkZW5jZSB0aGF0IHRoZSBZVGV4dCB0eXBlIHdvcmtzIGFzIGludGVuZGVkLlxuICpcbiAqIEBwYXJhbSB7WVRleHR9IHR5cGVcbiAqIEByZXR1cm4ge251bWJlcn0gSG93IG1hbnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjbGVhbmVkIHVwLlxuICovXG5jb25zdCBjbGVhbnVwWVRleHRGb3JtYXR0aW5nID0gdHlwZSA9PiB7XG4gIGxldCByZXMgPSAwO1xuICB0cmFuc2FjdCgvKiogQHR5cGUge0RvY30gKi8gKHR5cGUuZG9jKSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHR5cGUuX3N0YXJ0KTtcbiAgICBsZXQgZW5kID0gdHlwZS5fc3RhcnQ7XG4gICAgbGV0IHN0YXJ0QXR0cmlidXRlcyA9IGNyZWF0ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gY29weShzdGFydEF0dHJpYnV0ZXMpO1xuICAgIHdoaWxlIChlbmQpIHtcbiAgICAgIGlmIChlbmQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3dpdGNoIChlbmQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChlbmQuY29udGVudCkpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgICByZXMgKz0gY2xlYW51cEZvcm1hdHRpbmdHYXAodHJhbnNhY3Rpb24sIHN0YXJ0LCBlbmQsIHN0YXJ0QXR0cmlidXRlcywgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgc3RhcnRBdHRyaWJ1dGVzID0gY29weShjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZC5yaWdodDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJuIHtJdGVtVGV4dExpc3RQb3NpdGlvbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGRlbGV0ZVRleHQgPSAodHJhbnNhY3Rpb24sIGN1cnJQb3MsIGxlbmd0aCkgPT4ge1xuICBjb25zdCBzdGFydExlbmd0aCA9IGxlbmd0aDtcbiAgY29uc3Qgc3RhcnRBdHRycyA9IGNvcHkoY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcyk7XG4gIGNvbnN0IHN0YXJ0ID0gY3VyclBvcy5yaWdodDtcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgY3VyclBvcy5yaWdodCAhPT0gbnVsbCkge1xuICAgIGlmIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgIGlmIChsZW5ndGggPCBjdXJyUG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGN1cnJQb3MucmlnaHQuaWQuY2xpZW50LCBjdXJyUG9zLnJpZ2h0LmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCAtPSBjdXJyUG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgaWYgKHN0YXJ0KSB7XG4gICAgY2xlYW51cEZvcm1hdHRpbmdHYXAodHJhbnNhY3Rpb24sIHN0YXJ0LCBjdXJyUG9zLnJpZ2h0LCBzdGFydEF0dHJzLCBjb3B5KGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpKTtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoLyoqIEB0eXBlIHtJdGVtfSAqLyAoY3VyclBvcy5sZWZ0IHx8IGN1cnJQb3MucmlnaHQpLnBhcmVudCk7XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGN1cnJQb3MuaW5kZXgsIC1zdGFydExlbmd0aCArIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGN1cnJQb3Ncbn07XG5cbi8qKlxuICogVGhlIFF1aWxsIERlbHRhIGZvcm1hdCByZXByZXNlbnRzIGNoYW5nZXMgb24gYSB0ZXh0IGRvY3VtZW50IHdpdGhcbiAqIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uIEZvciBtb3IgaW5mb3JtYXRpb24gdmlzaXQge0BsaW5rIGh0dHBzOi8vcXVpbGxqcy5jb20vZG9jcy9kZWx0YS98UXVpbGwgRGVsdGF9XG4gKlxuICogQGV4YW1wbGVcbiAqICAge1xuICogICAgIG9wczogW1xuICogICAgICAgeyBpbnNlcnQ6ICdHYW5kYWxmJywgYXR0cmlidXRlczogeyBib2xkOiB0cnVlIH0gfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnIHRoZSAnIH0sXG4gKiAgICAgICB7IGluc2VydDogJ0dyZXknLCBhdHRyaWJ1dGVzOiB7IGNvbG9yOiAnI2NjY2NjYycgfSB9XG4gKiAgICAgXVxuICogICB9XG4gKlxuICovXG5cbi8qKlxuICAqIEF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gYSBzZWxlY3Rpb24gb2YgdGV4dC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogICB7XG4gICogICAgIGJvbGQ6IHRydWUsXG4gICogICAgIGZvbnQtc2l6ZTogJzQwcHgnXG4gICogICB9XG4gICpcbiAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0QXR0cmlidXRlc1xuICAqL1xuXG4vKipcbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVRleHQgdHlwZS5cbiAqL1xuY2xhc3MgWVRleHRFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lUZXh0fSB5dGV4dFxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxhbnk+fSBzdWJzIFRoZSBrZXlzIHRoYXQgY2hhbmdlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHl0ZXh0LCB0cmFuc2FjdGlvbiwgc3Vicykge1xuICAgIHN1cGVyKHl0ZXh0LCB0cmFuc2FjdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmtleXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ/OkFycmF5PGFueT58c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXJ9Pn19XG4gICAqL1xuICBnZXQgY2hhbmdlcyAoKSB7XG4gICAgaWYgKHRoaXMuX2NoYW5nZXMgPT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHtcbiAgICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgYWRkZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgZGVsZXRlZDogbmV3IFNldCgpXG4gICAgICB9O1xuICAgICAgdGhpcy5fY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2NoYW5nZXMpXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY2hhbmdlcyBpbiB0aGUgZGVsdGEgZm9ybWF0LlxuICAgKiBBIHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfSkgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG9uIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyLCBhdHRyaWJ1dGVzPzogT2JqZWN0PHN0cmluZyxhbnk+fT59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCBkZWx0YSAoKSB7XG4gICAgaWYgKHRoaXMuX2RlbHRhID09PSBudWxsKSB7XG4gICAgICBjb25zdCB5ID0gLyoqIEB0eXBlIHtEb2N9ICovICh0aGlzLnRhcmdldC5kb2MpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydD86c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLGFueT59Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7IC8vIHNhdmVzIGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgZm9yIGluc2VydFxuICAgICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMudGFyZ2V0Ll9zdGFydDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmc/fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGFjdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9OyAvLyBjb3VudHMgYWRkZWQgb3IgcmVtb3ZlZCBuZXcgYXR0cmlidXRlcyBmb3IgcmV0YWluXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfG9iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBpbnNlcnQgPSAnJztcbiAgICAgICAgbGV0IHJldGFpbiA9IDA7XG4gICAgICAgIGxldCBkZWxldGVMZW4gPSAwO1xuICAgICAgICBjb25zdCBhZGRPcCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCBvcDtcbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgb3AgPSB7IGRlbGV0ZTogZGVsZXRlTGVuIH07XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuID0gMDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICAgICAgICAgIG9wID0geyBpbnNlcnQgfTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnNlcnQgPSAnJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdyZXRhaW4nOlxuICAgICAgICAgICAgICAgIG9wID0geyByZXRhaW4gfTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbHRhLnB1c2gob3ApO1xuICAgICAgICAgICAgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0JztcbiAgICAgICAgICAgICAgICAgIGluc2VydCA9IC8qKiBAdHlwZSB7Q29udGVudEVtYmVkfSAqLyAoaXRlbS5jb250ZW50KS5lbWJlZDtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5zZXJ0ICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKGl0ZW0uY29udGVudCkuc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3JldGFpbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXF1YWxBdHRycyh2YWx1ZSwgKG9sZEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhjdXJWYWwsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGN1clZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGF0dHIsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgd2hpbGUgKGRlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBsYXN0T3AgPSBkZWx0YVtkZWx0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdE9wLnJldGFpbiAhPT0gdW5kZWZpbmVkICYmIGxhc3RPcC5hdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHJldGFpbiBkZWx0YSdzIGlmIHRoZXkgZG9uJ3QgYXNzaWduIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGRlbHRhLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9kZWx0YSA9IGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0aGlzLl9kZWx0YSlcbiAgfVxufVxuXG4vKipcbiAqIFR5cGUgdGhhdCByZXByZXNlbnRzIHRleHQgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLlxuICpcbiAqIFRoaXMgdHlwZSByZXBsYWNlcyB5LXJpY2h0ZXh0IGFzIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYWJsZSB0byBoYW5kbGVcbiAqIGJsb2NrIGZvcm1hdHMgKGZvcm1hdCBpbmZvcm1hdGlvbiBvbiBhIHBhcmFncmFwaCksIGVtYmVkcyAoY29tcGxleCBlbGVtZW50c1xuICogbGlrZSBwaWN0dXJlcyBhbmQgdmlkZW9zKSwgYW5kIHRleHQgZm9ybWF0cyAoKipib2xkKiosICppdGFsaWMqKS5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WVRleHRFdmVudD5cbiAqL1xuY2xhc3MgWVRleHQgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzdHJpbmddIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBZVGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBlbmRpbmcgb3BlcmF0aW9ucyBvbiB0aGlzIHR5cGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oKTp2b2lkPj99XG4gICAgICovXG4gICAgdGhpcy5fcGVuZGluZyA9IHN0cmluZyAhPT0gdW5kZWZpbmVkID8gWygpID0+IHRoaXMuaW5zZXJ0KDAsIHN0cmluZyldIDogW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgY2hhcmFjdGVycyBvZiB0aGlzIHRleHQgdHlwZS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRyeSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLmZvckVhY2goZiA9PiBmKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZVGV4dEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IFlUZXh0RXZlbnQodGhpcywgdHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgZXZlbnQpO1xuICAgIC8vIElmIGEgcmVtb3RlIGNoYW5nZSBoYXBwZW5lZCwgd2UgdHJ5IHRvIGNsZWFudXAgcG90ZW50aWFsIGZvcm1hdHRpbmcgZHVwbGljYXRlcy5cbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsKSB7XG4gICAgICAvLyBjaGVjayBpZiBhbm90aGVyIGZvcm1hdHRpbmcgaXRlbSB3YXMgaW5zZXJ0ZWRcbiAgICAgIGxldCBmb3VuZEZvcm1hdHRpbmdJdGVtID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGFmdGVyQ2xvY2tdIG9mIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMDtcbiAgICAgICAgaWYgKGFmdGVyQ2xvY2sgPT09IGNsb2NrKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgLyoqIEB0eXBlIHtBcnJheTxJdGVtfEdDPn0gKi8gKGRvYy5zdG9yZS5jbGllbnRzLmdldChjbGllbnQpKSwgY2xvY2ssIGFmdGVyQ2xvY2ssIGl0ZW0gPT4ge1xuICAgICAgICAgIGlmICghaXRlbS5kZWxldGVkICYmIC8qKiBAdHlwZSB7SXRlbX0gKi8gKGl0ZW0pLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgICAgICAgIGZvdW5kRm9ybWF0dGluZ0l0ZW0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb3VuZEZvcm1hdHRpbmdJdGVtKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZEZvcm1hdHRpbmdJdGVtKSB7XG4gICAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpdGVtID0+IHtcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdDIHx8IGZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQgPT09IHRoaXMgJiYgaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KSB7XG4gICAgICAgICAgICBmb3VuZEZvcm1hdHRpbmdJdGVtID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJhbnNhY3QoZG9jLCAodCkgPT4ge1xuICAgICAgICBpZiAoZm91bmRGb3JtYXR0aW5nSXRlbSkge1xuICAgICAgICAgIC8vIElmIGEgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZCwgd2Ugc2ltcGx5IGNsZWFuIHRoZSB3aG9sZSB0eXBlLlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW55d2F5LlxuICAgICAgICAgIGNsZWFudXBZVGV4dEZvcm1hdHRpbmcodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbm8gZm9ybWF0dGluZyBhdHRyaWJ1dGUgd2FzIGluc2VydGVkLCB3ZSBjYW4gbWFrZSBkdWUgd2l0aCBjb250ZXh0bGVzc1xuICAgICAgICAgIC8vIGZvcm1hdHRpbmcgY2xlYW51cHMuXG4gICAgICAgICAgLy8gQ29udGV4dGxlc3M6IGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGFmZmVjdGVkIHBvc2l0aW9uLlxuICAgICAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0LCB0LmRlbGV0ZVNldCwgaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdDKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0ucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgIGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAodCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUgJiYgbi5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50U3RyaW5nKSB7XG4gICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgIH1cbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHtAbGluayBEZWx0YX0gb24gdGhpcyBzaGFyZWQgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRlbHRhIFRoZSBjaGFuZ2VzIHRvIGFwcGx5IG9uIHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0c11cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zYW5pdGl6ZV0gU2FuaXRpemUgaW5wdXQgZGVsdGEuIFJlbW92ZXMgZW5kaW5nIG5ld2xpbmVzIGlmIHNldCB0byB0cnVlLlxuICAgKlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhcHBseURlbHRhIChkZWx0YSwgeyBzYW5pdGl6ZSA9IHRydWUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjdXJyUG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG51bGwsIHRoaXMuX3N0YXJ0LCAwLCBuZXcgTWFwKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3AgPSBkZWx0YVtpXTtcbiAgICAgICAgICBpZiAob3AuaW5zZXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFF1aWxsIGFzc3VtZXMgdGhhdCB0aGUgY29udGVudCBzdGFydHMgd2l0aCBhbiBlbXB0eSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAvLyBZanMvWS5UZXh0IGFzc3VtZXMgdGhhdCBpdCBzdGFydHMgZW1wdHkuIFdlIGFsd2F5cyBoaWRlIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgbmV3bGluZSBhdCB0aGUgZW5kIG9mIHRoZSBjb250ZW50LlxuICAgICAgICAgICAgLy8gSWYgd2Ugb21pdCB0aGlzIHN0ZXAsIGNsaWVudHMgd2lsbCBzZWUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyBwYXJhZ3JhcGhzLCBidXQgbm90aGluZyBiYWQgd2lsbCBoYXBwZW4uXG4gICAgICAgICAgICBjb25zdCBpbnMgPSAoIXNhbml0aXplICYmIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIGkgPT09IGRlbHRhLmxlbmd0aCAtIDEgJiYgY3VyclBvcy5yaWdodCA9PT0gbnVsbCAmJiBvcC5pbnNlcnQuc2xpY2UoLTEpID09PSAnXFxuJykgPyBvcC5pbnNlcnQuc2xpY2UoMCwgLTEpIDogb3AuaW5zZXJ0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnMgIT09ICdzdHJpbmcnIHx8IGlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIGN1cnJQb3MsIGlucywgb3AuYXR0cmlidXRlcyB8fCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5yZXRhaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgb3AucmV0YWluLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wLmRlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGVUZXh0KHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBvcC5kZWxldGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRGVsdGEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbc25hcHNob3RdXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtwcmV2U25hcHNob3RdXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgSUQpOmFueX0gW2NvbXB1dGVZQ2hhbmdlXVxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRGVsdGEgKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIGNvbXB1dGVZQ2hhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGV7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMuZG9jKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICBmdW5jdGlvbiBwYWNrU3RyICgpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYWNrIHN0ciB3aXRoIGF0dHJpYnV0ZXMgdG8gb3BzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBsZXQgYWRkQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgYWRkQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG9wID0geyBpbnNlcnQ6IHN0ciB9O1xuICAgICAgICBpZiAoYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKG9wKTtcbiAgICAgICAgc3RyID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNuYXBzaG90cyBhcmUgbWVyZ2VkIGFnYWluIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgc28gd2UgbmVlZCB0byBrZWVwIHRoZVxuICAgIC8vIHRyYW5zYWxpdmUgdW50aWwgd2UgYXJlIGRvbmVcbiAgICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgICBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlNuYXBzaG90KSB7XG4gICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHByZXZTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSB8fCAocHJldlNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpKSB7XG4gICAgICAgICAgc3dpdGNoIChuLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzoge1xuICAgICAgICAgICAgICBjb25zdCBjdXIgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoJ3ljaGFuZ2UnKTtcbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgIWlzVmlzaWJsZShuLCBzbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSB1bmRlZmluZWQgfHwgY3VyLnVzZXIgIT09IG4uaWQuY2xpZW50IHx8IGN1ci5zdGF0ZSAhPT0gJ3JlbW92ZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoJ3ljaGFuZ2UnLCBjb21wdXRlWUNoYW5nZSA/IGNvbXB1dGVZQ2hhbmdlKCdyZW1vdmVkJywgbi5pZCkgOiB7IHR5cGU6ICdyZW1vdmVkJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgIWlzVmlzaWJsZShuLCBwcmV2U25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciA9PT0gdW5kZWZpbmVkIHx8IGN1ci51c2VyICE9PSBuLmlkLmNsaWVudCB8fCBjdXIuc3RhdGUgIT09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ2FkZGVkJywgbi5pZCkgOiB7IHR5cGU6ICdhZGRlZCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZSgneWNoYW5nZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOiB7XG4gICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjb25zdCBvcCA9IHtcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IC8qKiBAdHlwZSB7Q29udGVudEVtYmVkfSAqLyAobi5jb250ZW50KS5lbWJlZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fSAqLyAoe30pO1xuICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAobi5jb250ZW50KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICB9XG4gICAgICBwYWNrU3RyKCk7XG4gICAgfSwgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyk7XG4gICAgcmV0dXJuIG9wc1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgaW5zZXJ0aW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBpbnNlcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gW2F0dHJpYnV0ZXNdIE9wdGlvbmFsbHkgZGVmaW5lIHNvbWUgZm9ybWF0dGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZSBpbnNlcnRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4KTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBwb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodiwgaykgPT4geyBhdHRyaWJ1dGVzW2tdID0gdjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnQoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBlbWJlZCBhdCBhIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCB0aGUgZW1iZWQgYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbWJlZCBUaGUgT2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZW1iZWQuXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYmVkXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydEVtYmVkIChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIGlmIChlbWJlZC5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtYmVkIG11c3QgYmUgYW4gT2JqZWN0JylcbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpO1xuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGVtYmVkLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0ZXh0IHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpLCBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmRlbGV0ZShpbmRleCwgbGVuZ3RoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgcHJvcGVydGllcyB0byBhIHJhbmdlIG9mIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvcm1hdCAoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCk7XG4gICAgICAgIGlmIChwb3MucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBmb3JtYXRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZm9ybWF0KGluZGV4LCBsZW5ndGgsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqIEBwYXJhbSB7YW55fSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBxdWVyaWVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBhdHRyaWJ1dGVOYW1lKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBpbiBhIEpTT04gT2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzIChzbmFwc2hvdCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVRleHQoKTtcblxuLyoqXG4gKiBAbW9kdWxlIFlYbWxcbiAqL1xuXG4vKipcbiAqIERlZmluZSB0aGUgZWxlbWVudHMgdG8gd2hpY2ggYSBzZXQgb2YgQ1NTIHF1ZXJpZXMgYXBwbHkuXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19TZWxlY3RvcnN8Q1NTX1NlbGVjdG9yc31cbiAqXG4gKiBAZXhhbXBsZVxuICogICBxdWVyeSA9ICcuY2xhc3NTZWxlY3RvcidcbiAqICAgcXVlcnkgPSAnbm9kZVNlbGVjdG9yJ1xuICogICBxdWVyeSA9ICcjaWRTZWxlY3RvcidcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBDU1NfU2VsZWN0b3JcbiAqL1xuXG4vKipcbiAqIERvbSBmaWx0ZXIgZnVuY3Rpb24uXG4gKlxuICogQGNhbGxiYWNrIGRvbUZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtNYXB9IGF0dHJpYnV0ZXMgVGhlIG1hcCBvZiBhdHRyaWJ1dGVzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBEb20gbm9kZSBpbiB0aGUgWVhtbEVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3Vic2V0IG9mIHRoZSBub2RlcyBvZiBhIFlYbWxFbGVtZW50IC8gWVhtbEZyYWdtZW50IGFuZCBhXG4gKiBwb3NpdGlvbiB3aXRoaW4gdGhlbS5cbiAqXG4gKiBDYW4gYmUgY3JlYXRlZCB3aXRoIHtAbGluayBZWG1sRnJhZ21lbnQjY3JlYXRlVHJlZVdhbGtlcn1cbiAqXG4gKiBAcHVibGljXG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEVsZW1lbnR8WVhtbEhvb2s+fVxuICovXG5jbGFzcyBZWG1sVHJlZVdhbGtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxGcmFnbWVudCB8IFlYbWxFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQWJzdHJhY3RUeXBlPGFueT4pOmJvb2xlYW59IFtmXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb3QsIGYgPSAoKSA9PiB0cnVlKSB7XG4gICAgdGhpcy5fZmlsdGVyID0gZjtcbiAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbX1cbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHJvb3QuX3N0YXJ0KTtcbiAgICB0aGlzLl9maXJzdENhbGwgPSB0cnVlO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yUmVzdWx0PFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rPn0gVGhlIG5leHQgbm9kZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbmV4dCAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgbiA9IHRoaXMuX2N1cnJlbnROb2RlO1xuICAgIGxldCB0eXBlID0gbiAmJiBuLmNvbnRlbnQgJiYgLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGU7XG4gICAgaWYgKG4gIT09IG51bGwgJiYgKCF0aGlzLl9maXJzdENhbGwgfHwgbi5kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIodHlwZSkpKSB7IC8vIGlmIGZpcnN0IGNhbGwsIHdlIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIGRvIHtcbiAgICAgICAgdHlwZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlO1xuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiAodHlwZS5jb25zdHJ1Y3RvciA9PT0gWVhtbEVsZW1lbnQgfHwgdHlwZS5jb25zdHJ1Y3RvciA9PT0gWVhtbEZyYWdtZW50KSAmJiB0eXBlLl9zdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdhbGsgZG93biBpbiB0aGUgdHJlZVxuICAgICAgICAgIG4gPSB0eXBlLl9zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3YWxrIHJpZ2h0IG9yIHVwIGluIHRoZSB0cmVlXG4gICAgICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG4gPSBuLnJpZ2h0O1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudCA9PT0gdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICBuID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobi5wYXJlbnQpLl9pdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobiAhPT0gbnVsbCAmJiAobi5kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkpKVxuICAgIH1cbiAgICB0aGlzLl9maXJzdENhbGwgPSBmYWxzZTtcbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gbjtcbiAgICByZXR1cm4geyB2YWx1ZTogLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGUsIGRvbmU6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsaXN0IG9mIHtAbGluayBZWG1sRWxlbWVudH0uYW5kIHtAbGluayBZWG1sVGV4dH0gdHlwZXMuXG4gKiBBIFl4bWxGcmFnbWVudCBpcyBzaW1pbGFyIHRvIGEge0BsaW5rIFlYbWxFbGVtZW50fSwgYnV0IGl0IGRvZXMgbm90IGhhdmUgYVxuICogbm9kZU5hbWUgYW5kIGl0IGRvZXMgbm90IGhhdmUgYXR0cmlidXRlcy4gVGhvdWdoIGl0IGNhbiBiZSBib3VuZCB0byBhIERPTVxuICogZWxlbWVudCAtIGluIHRoaXMgY2FzZSB0aGUgYXR0cmlidXRlcyBhbmQgdGhlIG5vZGVOYW1lIGFyZSBub3Qgc2hhcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZWG1sRXZlbnQ+XG4gKi9cbmNsYXNzIFlYbWxGcmFnbWVudCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IGZpcnN0Q2hpbGQgKCkge1xuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fZmlyc3Q7XG4gICAgcmV0dXJuIGZpcnN0ID8gZmlyc3QuY29udGVudC5nZXRDb250ZW50KClbMF0gOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKTtcbiAgICB0aGlzLmluc2VydCgwLCAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRnJhZ21lbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sRnJhZ21lbnQoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIGVsLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgKiAgIC8vIGBub2RlYCBpcyBhIGRpdiBub2RlXG4gICAqICAgbm9wKG5vZGUpXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJ0cmVlLlxuICAgKiBAcmV0dXJuIHtZWG1sVHJlZVdhbGtlcn0gQSBzdWJ0cmVlIGFuZCBhIHBvc2l0aW9uIHdpdGhpbiBpdC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlVHJlZVdhbGtlciAoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgWVhtbEVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAqXG4gICAqIFF1ZXJ5IHN1cHBvcnQ6XG4gICAqICAgLSB0YWduYW1lXG4gICAqIFRPRE86XG4gICAqICAgLSBpZFxuICAgKiAgIC0gYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuLlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsfSBUaGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IG9yIG51bGwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3IgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSk7XG4gICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRG9tJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKlxuICAgKiBAdG9kbyBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbD59IFRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3JBbGwgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gcXVlcnkpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVhtbEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWVhtbEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIFlYbWxGcmFnbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjaGlsZHJlbi5cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RNYXAodGhpcywgeG1sID0+IHhtbC50b1N0cmluZygpKS5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihmcmFnbWVudCwgdGhpcyk7XG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB4bWxUeXBlID0+IHtcbiAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZSh4bWxUeXBlLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpLCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bGx8SXRlbXxZWG1sRWxlbWVudHxZWG1sVGV4dH0gcmVmIFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKHJlZiwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IChyZWYgJiYgcmVmIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSA/IHJlZi5faXRlbSA6IHJlZjtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCB0aGlzLCByZWZJdGVtLCBjb250ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYyA9IC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpO1xuICAgICAgY29uc3QgaW5kZXggPSByZWYgPT09IG51bGwgPyAwIDogcGMuZmluZEluZGV4KGVsID0+IGVsID09PSByZWYpICsgMTtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiByZWYgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlJDIoJ1JlZmVyZW5jZSBpdGVtIG5vdCBmb3VuZCcpXG4gICAgICB9XG4gICAgICBwYy5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGVsZW1lbnRzIHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZyBlbGVtZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCA9IDEpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0RGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlIF9wcmVsaW1Db250ZW50IGlzIGRlZmluZWQgYmVjYXVzZSB0aGlzIGlzIG5vdCB5ZXQgaW50ZWdyYXRlZFxuICAgICAgdGhpcy5fcHJlbGltQ29udGVudC5zcGxpY2UoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9vaz59XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RUb0FycmF5KHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIGFwcGVuZC5cbiAgICovXG4gIHB1c2ggKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCh0aGlzLmxlbmd0aCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gcHJlcHBlbmQuXG4gICAqL1xuICB1bnNoaWZ0IChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQoMCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaS10aCBlbGVtZW50IGZyb20gYSBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIFlBcnJheVxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59XG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0eXBlTGlzdFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxGcmFnbWVudFJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbEZyYWdtZW50ID0gZGVjb2RlciA9PiBuZXcgWVhtbEZyYWdtZW50KCk7XG5cbi8qKlxuICogQW4gWVhtbEVsZW1lbnQgaW1pdGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGFcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH0uXG4gKlxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgYXR0cmlidXRlcyAoa2V5IHZhbHVlIHBhaXJzKVxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgY2hpbGRFbGVtZW50cyB0aGF0IG11c3QgaW5oZXJpdCBmcm9tIFlYbWxFbGVtZW50XG4gKi9cbmNsYXNzIFlYbWxFbGVtZW50IGV4dGVuZHMgWVhtbEZyYWdtZW50IHtcbiAgY29uc3RydWN0b3IgKG5vZGVOYW1lID0gJ1VOREVGSU5FRCcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgYW55PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IG5leHRTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ubmV4dCA6IG51bGw7XG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgcHJldlNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5wcmV2IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgOygvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEl0ZW0gd2l0aCB0aGUgc2FtZSBlZmZlY3QgYXMgdGhpcyBJdGVtICh3aXRob3V0IHBvc2l0aW9uIGVmZmVjdClcbiAgICpcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRWxlbWVudCh0aGlzLm5vZGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGVsID0gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIGVsLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFhNTCBzZXJpYWxpemF0aW9uIG9mIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqIFRoZSBhdHRyaWJ1dGVzIGFyZSBvcmRlcmVkIGJ5IGF0dHJpYnV0ZS1uYW1lLCBzbyB5b3UgY2FuIGVhc2lseSB1c2UgdGhpc1xuICAgKiBtZXRob2QgdG8gY29tcGFyZSBZWG1sRWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgY29uc3Qgc3RyaW5nQnVpbGRlciA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMuc29ydCgpO1xuICAgIGNvbnN0IGtleXNMZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChrZXkgKyAnPVwiJyArIGF0dHJzW2tleV0gKyAnXCInKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYXR0cnNTdHJpbmcgPSBzdHJpbmdCdWlsZGVyLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJpbmdCdWlsZGVyLmpvaW4oJyAnKSA6ICcnO1xuICAgIHJldHVybiBgPCR7bm9kZU5hbWV9JHthdHRyc1N0cmluZ30+JHtzdXBlci50b1N0cmluZygpfTwvJHtub2RlTmFtZX0+YFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5kZWxldGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykuc2V0KGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllZCB2YWx1ZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzIChzbmFwc2hvdCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgIH1cbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgeXhtbCA9PiB7XG4gICAgICBkb20uYXBwZW5kQ2hpbGQoeXhtbC50b0RPTShfZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSk7XG4gICAgfSk7XG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRWxlbWVudFJlZklEKTtcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMubm9kZU5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbEVsZW1lbnQgPSBkZWNvZGVyID0+IG5ldyBZWG1sRWxlbWVudChkZWNvZGVyLnJlYWRLZXkoKSk7XG5cbi8qKlxuICogQW4gRXZlbnQgdGhhdCBkZXNjcmliZXMgY2hhbmdlcyBvbiBhIFlYbWwgRWxlbWVudCBvciBZeG1sIEZyYWdtZW50XG4gKi9cbmNsYXNzIFlYbWxFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxGcmFnbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgb24gd2hpY2ggdGhlIGV2ZW50IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U2V0PHN0cmluZ3xudWxsPn0gc3VicyBUaGUgc2V0IG9mIGNoYW5nZWQgYXR0cmlidXRlcy4gYG51bGxgIGlzIGluY2x1ZGVkIGlmIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICBjaGlsZCBsaXN0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoIHdpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHN1YnMsIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIodGFyZ2V0LCB0cmFuc2FjdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogWW91IGNhbiBtYW5hZ2UgYmluZGluZyB0byBhIGN1c3RvbSB0eXBlIHdpdGggWVhtbEhvb2suXG4gKlxuICogQGV4dGVuZHMge1lNYXA8YW55Pn1cbiAqL1xuY2xhc3MgWVhtbEhvb2sgZXh0ZW5kcyBZTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rTmFtZSBub2RlTmFtZSBvZiB0aGUgRG9tIE5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaG9va05hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5ob29rTmFtZSA9IGhvb2tOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZWG1sSG9va31cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGVsLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBob29rID0gaG9va3NbdGhpcy5ob29rTmFtZV07XG4gICAgbGV0IGRvbTtcbiAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb20gPSBob29rLmNyZWF0ZURvbSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmhvb2tOYW1lKTtcbiAgICB9XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycsIHRoaXMuaG9va05hbWUpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEhvb2tSZWZJRCk7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmhvb2tOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sSG9va31cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sSG9vayA9IGRlY29kZXIgPT5cbiAgbmV3IFlYbWxIb29rKGRlY29kZXIucmVhZEtleSgpKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gKi9cbmNsYXNzIFlYbWxUZXh0IGV4dGVuZHMgWVRleHQge1xuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbFRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVhtbFRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxUZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcywgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMudG9EZWx0YSgpLm1hcChkZWx0YSA9PiB7XG4gICAgICBjb25zdCBuZXN0ZWROb2RlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBub2RlTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgYXR0cnMucHVzaCh7IGtleSwgdmFsdWU6IGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdW2tleV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBhdHRyaWJ1dGVzIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgICBhdHRycy5zb3J0KChhLCBiKSA9PiBhLmtleSA8IGIua2V5ID8gLTEgOiAxKTtcbiAgICAgICAgbmVzdGVkTm9kZXMucHVzaCh7IG5vZGVOYW1lLCBhdHRycyB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgbm9kZSBvcmRlciB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgIG5lc3RlZE5vZGVzLnNvcnQoKGEsIGIpID0+IGEubm9kZU5hbWUgPCBiLm5vZGVOYW1lID8gLTEgOiAxKTtcbiAgICAgIC8vIG5vdyBjb252ZXJ0IHRvIGRvbSBzdHJpbmdcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5lc3RlZE5vZGVzW2ldO1xuICAgICAgICBzdHIgKz0gYDwke25vZGUubm9kZU5hbWV9YDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IG5vZGUuYXR0cnNbal07XG4gICAgICAgICAgc3RyICs9IGAgJHthdHRyLmtleX09XCIke2F0dHIudmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnPic7XG4gICAgICB9XG4gICAgICBzdHIgKz0gZGVsdGEuaW5zZXJ0O1xuICAgICAgZm9yIChsZXQgaSA9IG5lc3RlZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0ciArPSBgPC8ke25lc3RlZE5vZGVzW2ldLm5vZGVOYW1lfT5gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH0pLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVhtbFRleHQoKTtcblxuY2xhc3MgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdGhpcyBzdHJ1Y3Qgd2l0aCB0aGUgaXRlbSB0byB0aGUgcmlnaHQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFscmVhZHkgYXNzdW1pbmcgdGhhdCBgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSB0aGlzLmlkLmNsb2NrYC5cbiAgICogQWxzbyB0aGlzIG1ldGhvZCBkb2VzICpub3QqIHJlbW92ZSByaWdodCBmcm9tIFN0cnVjdFN0b3JlIVxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3ZXRoZXIgdGhpcyBtZXJnZWQgd2l0aCByaWdodFxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuY29kaW5nUmVmXG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0LCBlbmNvZGluZ1JlZikge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG59XG5cbmNvbnN0IHN0cnVjdEdDUmVmTnVtYmVyID0gMDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBHQyBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtHQ30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXQ7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBvZmZzZXQ7XG4gICAgfVxuICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RHQ1JlZk51bWJlcik7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbmd0aCAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgQ29udGVudEJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb250ZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5jb250ZW50XVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50QmluYXJ5KHRoaXMuY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEJpbmFyeX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUJ1Zih0aGlzLmNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyIH0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRCaW5hcnkgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50QmluYXJ5KGRlY29kZXIucmVhZEJ1ZigpKTtcblxuY2xhc3MgQ29udGVudERlbGV0ZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlbikge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuIC0gb2Zmc2V0KTtcbiAgICB0aGlzLmxlbiA9IG9mZnNldDtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnREZWxldGVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMubGVuICs9IHJpZ2h0LmxlbjtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIGFkZFRvRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgaXRlbS5pZC5jbGllbnQsIGl0ZW0uaWQuY2xvY2ssIHRoaXMubGVuKTtcbiAgICBpdGVtLm1hcmtEZWxldGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVMZW4odGhpcy5sZW4gLSBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIgfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnREZWxldGVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERlbGV0ZWQoZGVjb2Rlci5yZWFkTGVuKCkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnREb2Mge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIGlmIChkb2MuX2l0ZW0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoaXMgZG9jdW1lbnQgd2FzIGFscmVhZHkgaW50ZWdyYXRlZCBhcyBhIHN1Yi1kb2N1bWVudC4gWW91IHNob3VsZCBjcmVhdGUgYSBzZWNvbmQgaW5zdGFuY2UgaW5zdGVhZCB3aXRoIHRoZSBzYW1lIGd1aWQuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEb2N9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICBpZiAoIWRvYy5nYykge1xuICAgICAgb3B0cy5nYyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZG9jLmF1dG9Mb2FkKSB7XG4gICAgICBvcHRzLmF1dG9Mb2FkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRvYy5tZXRhICE9PSBudWxsKSB7XG4gICAgICBvcHRzLm1ldGEgPSBkb2MubWV0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZG9jXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RG9jKHRoaXMuZG9jKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudERvY31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50RG9jfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgcmVmbGVjdGVkIGluIGRvYy5kZXN0cm95IGFzIHdlbGxcbiAgICB0aGlzLmRvYy5faXRlbSA9IGl0ZW07XG4gICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZCh0aGlzLmRvYyk7XG4gICAgaWYgKHRoaXMuZG9jLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQuYWRkKHRoaXMuZG9jKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmhhcyh0aGlzLmRvYykpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5kZWxldGUodGhpcy5kb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5hZGQodGhpcy5kb2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7IH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVTdHJpbmcodGhpcy5kb2MuZ3VpZCk7XG4gICAgZW5jb2Rlci53cml0ZUFueSh0aGlzLm9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDlcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RG9jID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERvYyhuZXcgRG9jKHsgZ3VpZDogZGVjb2Rlci5yZWFkU3RyaW5nKCksIC4uLmRlY29kZXIucmVhZEFueSgpIH0pKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50RW1iZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVtYmVkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW1iZWQpIHtcbiAgICB0aGlzLmVtYmVkID0gZW1iZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZW1iZWRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEVtYmVkKHRoaXMuZW1iZWQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEVtYmVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLmVtYmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA1XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RW1iZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RW1iZWQoZGVjb2Rlci5yZWFkSlNPTigpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50Rm9ybWF0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEZvcm1hdCh0aGlzLmtleSwgdGhpcy52YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEZvcm1hdH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICAvLyBAdG9kbyBzZWFyY2htYXJrZXIgYXJlIGN1cnJlbnRseSB1bnN1cHBvcnRlZCBmb3IgcmljaCB0ZXh0IGRvY3VtZW50c1xuICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX3NlYXJjaE1hcmtlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5rZXkpO1xuICAgIGVuY29kZXIud3JpdGVKU09OKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDZcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICovXG5jb25zdCByZWFkQ29udGVudEZvcm1hdCA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRGb3JtYXQoZGVjb2Rlci5yZWFkU3RyaW5nKCksIGRlY29kZXIucmVhZEpTT04oKSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudEpTT04ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcnIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50SlNPTih0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50SlNPTih0aGlzLmFyci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50SlNPTn0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLmNvbmNhdChyaWdodC5hcnIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aDtcbiAgICBlbmNvZGVyLndyaXRlTGVuKGxlbiAtIG9mZnNldCk7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5hcnJbaV07XG4gICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGMgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAyXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRKU09OID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICBjb25zdCBjcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYyA9IGRlY29kZXIucmVhZFN0cmluZygpO1xuICAgIGlmIChjID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcy5wdXNoKEpTT04ucGFyc2UoYykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IENvbnRlbnRKU09OKGNzKVxufTtcblxuY2xhc3MgQ29udGVudEFueSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGFycikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEFueX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEFueSh0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRBbnkodGhpcy5hcnIuc2xpY2Uob2Zmc2V0KSk7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5zbGljZSgwLCBvZmZzZXQpO1xuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEFueX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLmNvbmNhdChyaWdodC5hcnIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aDtcbiAgICBlbmNvZGVyLndyaXRlTGVuKGxlbiAtIG9mZnNldCk7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5hcnJbaV07XG4gICAgICBlbmNvZGVyLndyaXRlQW55KGMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA4XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEFueX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRBbnkgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKCk7XG4gIGNvbnN0IGNzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjcy5wdXNoKGRlY29kZXIucmVhZEFueSgpKTtcbiAgfVxuICByZXR1cm4gbmV3IENvbnRlbnRBbnkoY3MpXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRTdHJpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdHIgPSBzdHI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5zcGxpdCgnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0cilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRTdHJpbmcodGhpcy5zdHIuc2xpY2Uob2Zmc2V0KSk7XG4gICAgdGhpcy5zdHIgPSB0aGlzLnN0ci5zbGljZSgwLCBvZmZzZXQpO1xuXG4gICAgLy8gUHJldmVudCBlbmNvZGluZyBpbnZhbGlkIGRvY3VtZW50cyBiZWNhdXNlIG9mIHNwbGl0dGluZyBvZiBzdXJyb2dhdGUgcGFpcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy8yNDhcbiAgICBjb25zdCBmaXJzdENoYXJDb2RlID0gdGhpcy5zdHIuY2hhckNvZGVBdChvZmZzZXQgLSAxKTtcbiAgICBpZiAoZmlyc3RDaGFyQ29kZSA+PSAweEQ4MDAgJiYgZmlyc3RDaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIC8vIExhc3QgY2hhcmFjdGVyIG9mIHRoZSBsZWZ0IHNwbGl0IGlzIHRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSB1dGYxNi91Y3MyIHBhaXIuXG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHNwbGl0dGluZyBvZiBzdXJyb2dhdGUgcGFpcnMgYmVjYXVzZSB0aGlzIG1heSBsZWFkIHRvIGludmFsaWQgZG9jdW1lbnRzLlxuICAgICAgLy8gUmVwbGFjZSB0aGUgaW52YWxpZCBjaGFyYWN0ZXIgd2l0aCBhIHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyICjvv70gLyBVK0ZGRkQpXG4gICAgICB0aGlzLnN0ciA9IHRoaXMuc3RyLnNsaWNlKDAsIG9mZnNldCAtIDEpICsgJ++/vSc7XG4gICAgICAvLyByZXBsYWNlIHJpZ2h0IGFzIHdlbGxcbiAgICAgIHJpZ2h0LnN0ciA9ICfvv70nICsgcmlnaHQuc3RyLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRTdHJpbmd9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5zdHIgKz0gcmlnaHQuc3RyO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVTdHJpbmcob2Zmc2V0ID09PSAwID8gdGhpcy5zdHIgOiB0aGlzLnN0ci5zbGljZShvZmZzZXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA0XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICovXG5jb25zdCByZWFkQ29udGVudFN0cmluZyA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRTdHJpbmcoZGVjb2Rlci5yZWFkU3RyaW5nKCkpO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIpOkFic3RyYWN0VHlwZTxhbnk+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHR5cGVSZWZzID0gW1xuICByZWFkWUFycmF5LFxuICByZWFkWU1hcCxcbiAgcmVhZFlUZXh0LFxuICByZWFkWVhtbEVsZW1lbnQsXG4gIHJlYWRZWG1sRnJhZ21lbnQsXG4gIHJlYWRZWG1sSG9vayxcbiAgcmVhZFlYbWxUZXh0XG5dO1xuXG5jb25zdCBZQXJyYXlSZWZJRCA9IDA7XG5jb25zdCBZTWFwUmVmSUQgPSAxO1xuY29uc3QgWVRleHRSZWZJRCA9IDI7XG5jb25zdCBZWG1sRWxlbWVudFJlZklEID0gMztcbmNvbnN0IFlYbWxGcmFnbWVudFJlZklEID0gNDtcbmNvbnN0IFlYbWxIb29rUmVmSUQgPSA1O1xuY29uc3QgWVhtbFRleHRSZWZJRCA9IDY7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8WUV2ZW50Pn0gdHlwZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy50eXBlXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudFR5cGUodGhpcy50eXBlLl9jb3B5KCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50VHlwZX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICB0aGlzLnR5cGUuX2ludGVncmF0ZSh0cmFuc2FjdGlvbi5kb2MsIGl0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnR5cGUuX3N0YXJ0O1xuICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGlzIHdpbGwgYmUgZ2MnZCBsYXRlciBhbmQgd2Ugd2FudCB0byBtZXJnZSBpdCBpZiBwb3NzaWJsZVxuICAgICAgICAvLyBXZSB0cnkgdG8gbWVyZ2UgYWxsIGRlbGV0ZWQgaXRlbXMgYWZ0ZXIgZWFjaCB0cmFuc2FjdGlvbixcbiAgICAgICAgLy8gYnV0IHdlIGhhdmUgbm8ga25vd2xlZGdlIGFib3V0IHRoYXQgdGhpcyBuZWVkcyB0byBiZSBtZXJnZWRcbiAgICAgICAgLy8gc2luY2UgaXQgaXMgbm90IGluIHRyYW5zYWN0aW9uLmRzLiBIZW5jZSB3ZSBhZGQgaXQgdG8gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0c1xuICAgICAgICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICB9XG4gICAgdGhpcy50eXBlLl9tYXAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNhbWUgYXMgYWJvdmVcbiAgICAgICAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZGVsZXRlKHRoaXMudHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge1xuICAgIGxldCBpdGVtID0gdGhpcy50eXBlLl9zdGFydDtcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaXRlbS5nYyhzdG9yZSwgdHJ1ZSk7XG4gICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICB9XG4gICAgdGhpcy50eXBlLl9zdGFydCA9IG51bGw7XG4gICAgdGhpcy50eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtIHwgbnVsbH0gaXRlbSAqLyAoaXRlbSkgPT4ge1xuICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgaXRlbS5nYyhzdG9yZSwgdHJ1ZSk7XG4gICAgICAgIGl0ZW0gPSBpdGVtLmxlZnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy50eXBlLl9tYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIHRoaXMudHlwZS5fd3JpdGUoZW5jb2Rlcik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gN1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50VHlwZSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRUeXBlKHR5cGVSZWZzW2RlY29kZXIucmVhZFR5cGVSZWYoKV0oZGVjb2RlcikpO1xuXG4vKipcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHJldHVybiBzZXZlcmFsIGl0ZW1zXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHt7aXRlbTpJdGVtLCBkaWZmOm51bWJlcn19XG4gKi9cbmNvbnN0IGZvbGxvd1JlZG9uZSA9IChzdG9yZSwgaWQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtJRHxudWxsfVxuICAgKi9cbiAgbGV0IG5leHRJRCA9IGlkO1xuICBsZXQgZGlmZiA9IDA7XG4gIGxldCBpdGVtO1xuICBkbyB7XG4gICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICBuZXh0SUQgPSBjcmVhdGVJRChuZXh0SUQuY2xpZW50LCBuZXh0SUQuY2xvY2sgKyBkaWZmKTtcbiAgICB9XG4gICAgaXRlbSA9IGdldEl0ZW0oc3RvcmUsIG5leHRJRCk7XG4gICAgZGlmZiA9IG5leHRJRC5jbG9jayAtIGl0ZW0uaWQuY2xvY2s7XG4gICAgbmV4dElEID0gaXRlbS5yZWRvbmU7XG4gIH0gd2hpbGUgKG5leHRJRCAhPT0gbnVsbCAmJiBpdGVtIGluc3RhbmNlb2YgSXRlbSlcbiAgcmV0dXJuIHtcbiAgICBpdGVtLCBkaWZmXG4gIH1cbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgbmVpdGhlciBpdGVtIG5vciBhbnkgb2YgaXRzIHBhcmVudHMgaXMgZXZlciBkZWxldGVkLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgZG9lcyBub3QgcGVyc2lzdCB3aGVuIHN0b3JpbmcgaXQgaW50byBhIGRhdGFiYXNlIG9yIHdoZW5cbiAqIHNlbmRpbmcgaXQgdG8gb3RoZXIgcGVlcnNcbiAqXG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICogQHBhcmFtIHtib29sZWFufSBrZWVwXG4gKi9cbmNvbnN0IGtlZXBJdGVtID0gKGl0ZW0sIGtlZXApID0+IHtcbiAgd2hpbGUgKGl0ZW0gIT09IG51bGwgJiYgaXRlbS5rZWVwICE9PSBrZWVwKSB7XG4gICAgaXRlbS5rZWVwID0ga2VlcDtcbiAgICBpdGVtID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5faXRlbTtcbiAgfVxufTtcblxuLyoqXG4gKiBTcGxpdCBsZWZ0SXRlbSBpbnRvIHR3byBpdGVtc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gbGVmdEl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc3BsaXRJdGVtID0gKHRyYW5zYWN0aW9uLCBsZWZ0SXRlbSwgZGlmZikgPT4ge1xuICAvLyBjcmVhdGUgcmlnaHRJdGVtXG4gIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdEl0ZW0uaWQ7XG4gIGNvbnN0IHJpZ2h0SXRlbSA9IG5ldyBJdGVtKFxuICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSxcbiAgICBsZWZ0SXRlbSxcbiAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiAtIDEpLFxuICAgIGxlZnRJdGVtLnJpZ2h0LFxuICAgIGxlZnRJdGVtLnJpZ2h0T3JpZ2luLFxuICAgIGxlZnRJdGVtLnBhcmVudCxcbiAgICBsZWZ0SXRlbS5wYXJlbnRTdWIsXG4gICAgbGVmdEl0ZW0uY29udGVudC5zcGxpY2UoZGlmZilcbiAgKTtcbiAgaWYgKGxlZnRJdGVtLmRlbGV0ZWQpIHtcbiAgICByaWdodEl0ZW0ubWFya0RlbGV0ZWQoKTtcbiAgfVxuICBpZiAobGVmdEl0ZW0ua2VlcCkge1xuICAgIHJpZ2h0SXRlbS5rZWVwID0gdHJ1ZTtcbiAgfVxuICBpZiAobGVmdEl0ZW0ucmVkb25lICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJlZG9uZSA9IGNyZWF0ZUlEKGxlZnRJdGVtLnJlZG9uZS5jbGllbnQsIGxlZnRJdGVtLnJlZG9uZS5jbG9jayArIGRpZmYpO1xuICB9XG4gIC8vIHVwZGF0ZSBsZWZ0IChkbyBub3Qgc2V0IGxlZnRJdGVtLnJpZ2h0T3JpZ2luIGFzIGl0IHdpbGwgbGVhZCB0byBwcm9ibGVtcyB3aGVuIHN5bmNpbmcpXG4gIGxlZnRJdGVtLnJpZ2h0ID0gcmlnaHRJdGVtO1xuICAvLyB1cGRhdGUgcmlnaHRcbiAgaWYgKHJpZ2h0SXRlbS5yaWdodCAhPT0gbnVsbCkge1xuICAgIHJpZ2h0SXRlbS5yaWdodC5sZWZ0ID0gcmlnaHRJdGVtO1xuICB9XG4gIC8vIHJpZ2h0IGlzIG1vcmUgc3BlY2lmaWMuXG4gIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChyaWdodEl0ZW0pO1xuICAvLyB1cGRhdGUgcGFyZW50Ll9tYXBcbiAgaWYgKHJpZ2h0SXRlbS5wYXJlbnRTdWIgIT09IG51bGwgJiYgcmlnaHRJdGVtLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0SXRlbS5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0SXRlbS5wYXJlbnRTdWIsIHJpZ2h0SXRlbSk7XG4gIH1cbiAgbGVmdEl0ZW0ubGVuZ3RoID0gZGlmZjtcbiAgcmV0dXJuIHJpZ2h0SXRlbVxufTtcblxuLyoqXG4gKiBSZWRvZXMgdGhlIGVmZmVjdCBvZiB0aGlzIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBUaGUgWWpzIGluc3RhbmNlLlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1NldDxJdGVtPn0gcmVkb2l0ZW1zXG4gKlxuICogQHJldHVybiB7SXRlbXxudWxsfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHJlZG9JdGVtID0gKHRyYW5zYWN0aW9uLCBpdGVtLCByZWRvaXRlbXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgY29uc3Qgb3duQ2xpZW50SUQgPSBkb2MuY2xpZW50SUQ7XG4gIGNvbnN0IHJlZG9uZSA9IGl0ZW0ucmVkb25lO1xuICBpZiAocmVkb25lICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCByZWRvbmUpXG4gIH1cbiAgbGV0IHBhcmVudEl0ZW0gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9pdGVtO1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCBsZWZ0O1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCByaWdodDtcbiAgaWYgKGl0ZW0ucGFyZW50U3ViID09PSBudWxsKSB7XG4gICAgLy8gSXMgYW4gYXJyYXkgaXRlbS4gSW5zZXJ0IGF0IHRoZSBvbGQgcG9zaXRpb25cbiAgICBsZWZ0ID0gaXRlbS5sZWZ0O1xuICAgIHJpZ2h0ID0gaXRlbTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyBhIG1hcCBpdGVtLiBJbnNlcnQgYXMgY3VycmVudCB2YWx1ZVxuICAgIGxlZnQgPSBpdGVtO1xuICAgIHdoaWxlIChsZWZ0LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICBsZWZ0ID0gbGVmdC5yaWdodDtcbiAgICAgIGlmIChsZWZ0LmlkLmNsaWVudCAhPT0gb3duQ2xpZW50SUQpIHtcbiAgICAgICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlZG8gdGhpcyBpdGVtIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGggYVxuICAgICAgICAvLyBjaGFuZ2UgZnJvbSBhbm90aGVyIGNsaWVudFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdC5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgbGVmdCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX21hcC5nZXQoaXRlbS5wYXJlbnRTdWIpKTtcbiAgICB9XG4gICAgcmlnaHQgPSBudWxsO1xuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGF0IHBhcmVudCBpcyByZWRvbmVcbiAgaWYgKHBhcmVudEl0ZW0gIT09IG51bGwgJiYgcGFyZW50SXRlbS5kZWxldGVkID09PSB0cnVlICYmIHBhcmVudEl0ZW0ucmVkb25lID09PSBudWxsKSB7XG4gICAgLy8gdHJ5IHRvIHVuZG8gcGFyZW50IGlmIGl0IHdpbGwgYmUgdW5kb25lIGFueXdheVxuICAgIGlmICghcmVkb2l0ZW1zLmhhcyhwYXJlbnRJdGVtKSB8fCByZWRvSXRlbSh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbSwgcmVkb2l0ZW1zKSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmVudEl0ZW0gIT09IG51bGwgJiYgcGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICB3aGlsZSAocGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudEl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbS5yZWRvbmUpO1xuICAgIH1cbiAgICAvLyBmaW5kIG5leHQgY2xvbmVkX3JlZG8gaXRlbXNcbiAgICB3aGlsZSAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgbGVmdFRyYWNlID0gbGVmdDtcbiAgICAgIC8vIHRyYWNlIHJlZG9uZSB1bnRpbCBwYXJlbnQgbWF0Y2hlc1xuICAgICAgd2hpbGUgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gIT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdFRyYWNlID0gbGVmdFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgbGVmdFRyYWNlLnJlZG9uZSk7XG4gICAgICB9XG4gICAgICBpZiAobGVmdFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChsZWZ0VHJhY2UucGFyZW50KS5faXRlbSA9PT0gcGFyZW50SXRlbSkge1xuICAgICAgICBsZWZ0ID0gbGVmdFRyYWNlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbGVmdCA9IGxlZnQubGVmdDtcbiAgICB9XG4gICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCByaWdodFRyYWNlID0gcmlnaHQ7XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChyaWdodFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodFRyYWNlLnBhcmVudCkuX2l0ZW0gIT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgcmlnaHRUcmFjZSA9IHJpZ2h0VHJhY2UucmVkb25lID09PSBudWxsID8gbnVsbCA6IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCByaWdodFRyYWNlLnJlZG9uZSk7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtID09PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0ID0gcmlnaHRUcmFjZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHJpZ2h0ID0gcmlnaHQucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5leHRDbG9jayA9IGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJRCk7XG4gIGNvbnN0IG5leHRJZCA9IGNyZWF0ZUlEKG93bkNsaWVudElELCBuZXh0Q2xvY2spO1xuICBjb25zdCByZWRvbmVJdGVtID0gbmV3IEl0ZW0oXG4gICAgbmV4dElkLFxuICAgIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsXG4gICAgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLFxuICAgIHBhcmVudEl0ZW0gPT09IG51bGwgPyBpdGVtLnBhcmVudCA6IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGUsXG4gICAgaXRlbS5wYXJlbnRTdWIsXG4gICAgaXRlbS5jb250ZW50LmNvcHkoKVxuICApO1xuICBpdGVtLnJlZG9uZSA9IG5leHRJZDtcbiAga2VlcEl0ZW0ocmVkb25lSXRlbSwgdHJ1ZSk7XG4gIHJlZG9uZUl0ZW0uaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgcmV0dXJuIHJlZG9uZUl0ZW1cbn07XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCByZXByZXNlbnRzIGFueSBjb250ZW50LlxuICovXG5jbGFzcyBJdGVtIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gbGVmdFxuICAgKiBAcGFyYW0ge0lEIHwgbnVsbH0gb3JpZ2luXG4gICAqIEBwYXJhbSB7SXRlbSB8IG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSByaWdodE9yaWdpblxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9IHBhcmVudCBJcyBhIHR5cGUgaWYgaW50ZWdyYXRlZCwgaXMgbnVsbCBpZiBpdCBpcyBwb3NzaWJsZSB0byBjb3B5IHBhcmVudCBmcm9tIGxlZnQgb3IgcmlnaHQsIGlzIElEIGJlZm9yZSBpbnRlZ3JhdGlvbiB0byBzZWFyY2ggZm9yIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHBhcmVudFN1YlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udGVudH0gY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZWZ0LCBvcmlnaW4sIHJpZ2h0LCByaWdodE9yaWdpbiwgcGFyZW50LCBwYXJlbnRTdWIsIGNvbnRlbnQpIHtcbiAgICBzdXBlcihpZCwgY29udGVudC5nZXRMZW5ndGgoKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0l0ZW0gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SXRlbSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmlnaHRPcmlnaW4gPSByaWdodE9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT58SUR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcGFyZW50IHJlZmVycyB0byB0aGlzIGl0ZW0gd2l0aCBzb21lIGtpbmQgb2Yga2V5IChlLmcuIFlNYXAsIHRoZVxuICAgICAqIGtleSBpcyBzcGVjaWZpZWQgaGVyZS4gVGhlIGtleSBpcyB0aGVuIHVzZWQgdG8gcmVmZXIgdG8gdGhlIGxpc3QgaW4gd2hpY2hcbiAgICAgKiB0byBpbnNlcnQgdGhpcyBpdGVtLiBJZiBgcGFyZW50U3ViID0gbnVsbGAgdHlwZS5fc3RhcnQgaXMgdGhlIGxpc3QgaW5cbiAgICAgKiB3aGljaCB0byBpbnNlcnQgdG8uIE90aGVyd2lzZSBpdCBpcyBgcGFyZW50Ll9tYXBgLlxuICAgICAqIEB0eXBlIHtTdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50U3ViID0gcGFyZW50U3ViO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgdHlwZSdzIGVmZmVjdCBpcyByZXVuZG9uZSB0aGlzIHR5cGUgcmVmZXJzIHRvIHRoZSB0eXBlIHRoYXQgdW5kaWRcbiAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVkb25lID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RDb250ZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgLyoqXG4gICAgICogYml0MToga2VlcFxuICAgICAqIGJpdDI6IGNvdW50YWJsZVxuICAgICAqIGJpdDM6IGRlbGV0ZWRcbiAgICAgKiBiaXQ0OiBtYXJrIC0gbWFyayBub2RlIGFzIGZhc3Qtc2VhcmNoLW1hcmtlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IGJ5dGVcbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB0aGlzLmNvbnRlbnQuaXNDb3VudGFibGUoKSA/IEJJVDIgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBtYXJrIHRoZSBpdGVtIGFzIGFuIGluZGV4ZWQgZmFzdC1zZWFyY2ggbWFya2VyXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2V0IG1hcmtlciAoaXNNYXJrZWQpIHtcbiAgICBpZiAoKCh0aGlzLmluZm8gJiBCSVQ0KSA+IDApICE9PSBpc01hcmtlZCkge1xuICAgICAgdGhpcy5pbmZvIF49IEJJVDQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1hcmtlciAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBCSVQ0KSA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBkbyBub3QgZ2FyYmFnZSBjb2xsZWN0IHRoaXMgSXRlbS5cbiAgICovXG4gIGdldCBrZWVwICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIEJJVDEpID4gMFxuICB9XG5cbiAgc2V0IGtlZXAgKGRvS2VlcCkge1xuICAgIGlmICh0aGlzLmtlZXAgIT09IGRvS2VlcCkge1xuICAgICAgdGhpcy5pbmZvIF49IEJJVDE7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBCSVQyKSA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgaXRlbSB3YXMgZGVsZXRlZCBvciBub3QuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgQklUMykgPiAwXG4gIH1cblxuICBzZXQgZGVsZXRlZCAoZG9EZWxldGUpIHtcbiAgICBpZiAodGhpcy5kZWxldGVkICE9PSBkb0RlbGV0ZSkge1xuICAgICAgdGhpcy5pbmZvIF49IEJJVDM7XG4gICAgfVxuICB9XG5cbiAgbWFya0RlbGV0ZWQgKCkge1xuICAgIHRoaXMuaW5mbyB8PSBCSVQzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3JlYXRvciBjbGllbnRJRCBvZiB0aGUgbWlzc2luZyBvcCBvciBkZWZpbmUgbWlzc2luZyBpdGVtcyBhbmQgcmV0dXJuIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gJiYgdGhpcy5vcmlnaW4uY2xpZW50ICE9PSB0aGlzLmlkLmNsaWVudCAmJiB0aGlzLm9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5vcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLmNsaWVudFxuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbiAmJiB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5yaWdodE9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodE9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCAmJiB0aGlzLmlkLmNsaWVudCAhPT0gdGhpcy5wYXJlbnQuY2xpZW50ICYmIHRoaXMucGFyZW50LmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLnBhcmVudC5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2xpZW50XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBhbGwgbWlzc2luZyBpZHMsIG5vdyBmaW5kIHRoZSBpdGVtc1xuXG4gICAgaWYgKHRoaXMub3JpZ2luKSB7XG4gICAgICB0aGlzLmxlZnQgPSBnZXRJdGVtQ2xlYW5FbmQodHJhbnNhY3Rpb24sIHN0b3JlLCB0aGlzLm9yaWdpbik7XG4gICAgICB0aGlzLm9yaWdpbiA9IHRoaXMubGVmdC5sYXN0SWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnJpZ2h0T3JpZ2luKSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHRoaXMucmlnaHRPcmlnaW4pO1xuICAgICAgdGhpcy5yaWdodE9yaWdpbiA9IHRoaXMucmlnaHQuaWQ7XG4gICAgfVxuICAgIGlmICgodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gR0MpIHx8ICh0aGlzLnJpZ2h0ICYmIHRoaXMucmlnaHQuY29uc3RydWN0b3IgPT09IEdDKSkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBvbmx5IHNldCBwYXJlbnQgaWYgdGhpcyBzaG91bGRuJ3QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gSXRlbSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMubGVmdC5wYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50U3ViID0gdGhpcy5sZWZ0LnBhcmVudFN1YjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICYmIHRoaXMucmlnaHQuY29uc3RydWN0b3IgPT09IEl0ZW0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnJpZ2h0LnBhcmVudDtcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLnJpZ2h0LnBhcmVudFN1YjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCkge1xuICAgICAgY29uc3QgcGFyZW50SXRlbSA9IGdldEl0ZW0oc3RvcmUsIHRoaXMucGFyZW50KTtcbiAgICAgIGlmIChwYXJlbnRJdGVtLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudCA9IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIHRoaXMuaWQuY2xvY2sgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrIC0gMSkpO1xuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkO1xuICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb250ZW50LnNwbGljZShvZmZzZXQpO1xuICAgICAgdGhpcy5sZW5ndGggLT0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKCghdGhpcy5sZWZ0ICYmICghdGhpcy5yaWdodCB8fCB0aGlzLnJpZ2h0LmxlZnQgIT09IG51bGwpKSB8fCAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5yaWdodCAhPT0gdGhpcy5yaWdodCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBvO1xuICAgICAgICAvLyBzZXQgbyB0byB0aGUgZmlyc3QgY29uZmxpY3RpbmcgaXRlbVxuICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSBsZWZ0LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5nZXQodGhpcy5wYXJlbnRTdWIpIHx8IG51bGw7XG4gICAgICAgICAgd2hpbGUgKG8gIT09IG51bGwgJiYgby5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gby5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXNlIHNvbWV0aGluZyBsaWtlIERlbGV0ZVNldCBoZXJlIChhIHRyZWUgaW1wbGVtZW50YXRpb24gd291bGQgYmUgYmVzdClcbiAgICAgICAgLy8gQHRvZG8gdXNlIGdsb2JhbCBzZXQgZGVmaW5pdGlvbnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb25mbGljdGluZ0l0ZW1zID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGl0ZW1zQmVmb3JlT3JpZ2luID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBMZXQgYyBpbiBjb25mbGljdGluZ0l0ZW1zLCBiIGluIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIC8vICoqKntvcmlnaW59YmJiYnt0aGlzfXtjLGJ9e2MsYn17b30qKipcbiAgICAgICAgLy8gTm90ZSB0aGF0IGNvbmZsaWN0aW5nSXRlbXMgaXMgYSBzdWJzZXQgb2YgaXRlbXNCZWZvcmVPcmlnaW5cbiAgICAgICAgd2hpbGUgKG8gIT09IG51bGwgJiYgbyAhPT0gdGhpcy5yaWdodCkge1xuICAgICAgICAgIGl0ZW1zQmVmb3JlT3JpZ2luLmFkZChvKTtcbiAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmFkZChvKTtcbiAgICAgICAgICBpZiAoY29tcGFyZUlEcyh0aGlzLm9yaWdpbiwgby5vcmlnaW4pKSB7XG4gICAgICAgICAgICAvLyBjYXNlIDFcbiAgICAgICAgICAgIGlmIChvLmlkLmNsaWVudCA8IHRoaXMuaWQuY2xpZW50KSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgby5yaWdodE9yaWdpbikpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBhbmQgbyBhcmUgY29uZmxpY3RpbmcgYW5kIHBvaW50IHRvIHRoZSBzYW1lIGludGVncmF0aW9uIHBvaW50cy4gVGhlIGlkIGRlY2lkZXMgd2hpY2ggaXRlbSBjb21lcyBmaXJzdC5cbiAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyB0byB0aGUgbGVmdCBvZiBvLCB3ZSBjYW4gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSAvLyBlbHNlLCBvIG1pZ2h0IGJlIGludGVncmF0ZWQgYmVmb3JlIGFuIGl0ZW0gdGhhdCB0aGlzIGNvbmZsaWN0cyB3aXRoLiBJZiBzbywgd2Ugd2lsbCBmaW5kIGl0IGluIHRoZSBuZXh0IGl0ZXJhdGlvbnNcbiAgICAgICAgICB9IGVsc2UgaWYgKG8ub3JpZ2luICE9PSBudWxsICYmIGl0ZW1zQmVmb3JlT3JpZ2luLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkgeyAvLyB1c2UgZ2V0SXRlbSBpbnN0ZWFkIG9mIGdldEl0ZW1DbGVhbkVuZCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgLyBuZWVkIHRvIHNwbGl0IGl0ZW1zLlxuICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICBpZiAoIWNvbmZsaWN0aW5nSXRlbXMuaGFzKGdldEl0ZW0odHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBvLm9yaWdpbikpKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIG8gPSBvLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICB9XG4gICAgICAvLyByZWNvbm5lY3QgbGVmdC9yaWdodCArIHVwZGF0ZSBwYXJlbnQgbWFwL3N0YXJ0IGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMubGVmdC5yaWdodDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmxlZnQucmlnaHQgPSB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHI7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuZ2V0KHRoaXMucGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgIHdoaWxlIChyICE9PSBudWxsICYmIHIubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgciA9IHIubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgciA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0XG4gICAgICAgICAgOy8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJpZ2h0ID0gcjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHNldCBhcyBjdXJyZW50IHBhcmVudCB2YWx1ZSBpZiByaWdodCA9PT0gbnVsbCBhbmQgdGhpcyBpcyBwYXJlbnRTdWJcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLnNldCh0aGlzLnBhcmVudFN1YiwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZSBvZiBwYXJlbnQuIGRlbGV0ZSByaWdodFxuICAgICAgICAgIHRoaXMubGVmdC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMucGFyZW50U3ViID09PSBudWxsICYmIHRoaXMuY291bnRhYmxlICYmICF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbGVuZ3RoICs9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgYWRkU3RydWN0KHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdGhpcyk7XG4gICAgICB0aGlzLmNvbnRlbnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCB0aGlzKTtcbiAgICAgIC8vIGFkZCBwYXJlbnQgdG8gdHJhbnNhY3Rpb24uY2hhbmdlZFxuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLCB0aGlzLnBhcmVudFN1Yik7XG4gICAgICBpZiAoKC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2l0ZW0gIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5faXRlbS5kZWxldGVkKSB8fCAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwgJiYgdGhpcy5yaWdodCAhPT0gbnVsbCkpIHtcbiAgICAgICAgLy8gZGVsZXRlIGlmIHBhcmVudCBpcyBkZWxldGVkIG9yIGlmIHRoaXMgaXMgbm90IHRoZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZSBvZiBwYXJlbnRcbiAgICAgICAgdGhpcy5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGRlZmluZWQuIEludGVncmF0ZSBHQyBzdHJ1Y3QgaW5zdGVhZFxuICAgICAgbmV3IEdDKHRoaXMuaWQsIHRoaXMubGVuZ3RoKS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBuZXh0ICgpIHtcbiAgICBsZXQgbiA9IHRoaXMucmlnaHQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgcHJldiAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLmxlZnQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gblxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBsYXN0IGNvbnRlbnQgYWRkcmVzcyBvZiB0aGlzIEl0ZW0uXG4gICAqL1xuICBnZXQgbGFzdElkICgpIHtcbiAgICAvLyBhbGxvY2F0aW5nIGlkcyBpcyBwcmV0dHkgY29zdGx5IGJlY2F1c2Ugb2YgdGhlIGFtb3VudCBvZiBpZHMgY3JlYXRlZCwgc28gd2UgdHJ5IHRvIHJldXNlIHdoZW5ldmVyIHBvc3NpYmxlXG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxID8gdGhpcy5pZCA6IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggLSAxKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBtZXJnZSB0d28gaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIHtJdGVtfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnN0cnVjdG9yICYmXG4gICAgICBjb21wYXJlSURzKHJpZ2h0Lm9yaWdpbiwgdGhpcy5sYXN0SWQpICYmXG4gICAgICB0aGlzLnJpZ2h0ID09PSByaWdodCAmJlxuICAgICAgY29tcGFyZUlEcyh0aGlzLnJpZ2h0T3JpZ2luLCByaWdodC5yaWdodE9yaWdpbikgJiZcbiAgICAgIHRoaXMuaWQuY2xpZW50ID09PSByaWdodC5pZC5jbGllbnQgJiZcbiAgICAgIHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCA9PT0gcmlnaHQuaWQuY2xvY2sgJiZcbiAgICAgIHRoaXMuZGVsZXRlZCA9PT0gcmlnaHQuZGVsZXRlZCAmJlxuICAgICAgdGhpcy5yZWRvbmUgPT09IG51bGwgJiZcbiAgICAgIHJpZ2h0LnJlZG9uZSA9PT0gbnVsbCAmJlxuICAgICAgdGhpcy5jb250ZW50LmNvbnN0cnVjdG9yID09PSByaWdodC5jb250ZW50LmNvbnN0cnVjdG9yICYmXG4gICAgICB0aGlzLmNvbnRlbnQubWVyZ2VXaXRoKHJpZ2h0LmNvbnRlbnQpXG4gICAgKSB7XG4gICAgICBpZiAocmlnaHQua2VlcCkge1xuICAgICAgICB0aGlzLmtlZXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhpcyBJdGVtIGFzIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCk7XG4gICAgICAvLyBhZGp1c3QgdGhlIGxlbmd0aCBvZiBwYXJlbnRcbiAgICAgIGlmICh0aGlzLmNvdW50YWJsZSAmJiB0aGlzLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuX2xlbmd0aCAtPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya0RlbGV0ZWQoKTtcbiAgICAgIGFkZFRvRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgdGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2ssIHRoaXMubGVuZ3RoKTtcbiAgICAgIGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgcGFyZW50LCB0aGlzLnBhcmVudFN1Yik7XG4gICAgICB0aGlzLmNvbnRlbnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJlbnRHQ2RcbiAgICovXG4gIGdjIChzdG9yZSwgcGFyZW50R0NkKSB7XG4gICAgaWYgKCF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgdGhpcy5jb250ZW50LmdjKHN0b3JlKTtcbiAgICBpZiAocGFyZW50R0NkKSB7XG4gICAgICByZXBsYWNlU3RydWN0KHN0b3JlLCB0aGlzLCBuZXcgR0ModGhpcy5pZCwgdGhpcy5sZW5ndGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9mZnNldCA+IDAgPyBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayArIG9mZnNldCAtIDEpIDogdGhpcy5vcmlnaW47XG4gICAgY29uc3QgcmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0T3JpZ2luO1xuICAgIGNvbnN0IHBhcmVudFN1YiA9IHRoaXMucGFyZW50U3ViO1xuICAgIGNvbnN0IGluZm8gPSAodGhpcy5jb250ZW50LmdldFJlZigpICYgQklUUzUpIHxcbiAgICAgIChvcmlnaW4gPT09IG51bGwgPyAwIDogQklUOCkgfCAvLyBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHJpZ2h0T3JpZ2luID09PSBudWxsID8gMCA6IEJJVDcpIHwgLy8gcmlnaHQgb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIChwYXJlbnRTdWIgPT09IG51bGwgPyAwIDogQklUNik7IC8vIHBhcmVudFN1YiBpcyBub24tbnVsbFxuICAgIGVuY29kZXIud3JpdGVJbmZvKGluZm8pO1xuICAgIGlmIChvcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQob3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0T3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlUmlnaHRJRChyaWdodE9yaWdpbik7XG4gICAgfVxuICAgIGlmIChvcmlnaW4gPT09IG51bGwgJiYgcmlnaHRPcmlnaW4gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCk7XG4gICAgICBpZiAocGFyZW50Ll9pdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50SXRlbSA9IHBhcmVudC5faXRlbTtcbiAgICAgICAgaWYgKHBhcmVudEl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBwYXJlbnQgdHlwZSBvbiB5Ll9tYXBcbiAgICAgICAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IGtleVxuICAgICAgICAgIGNvbnN0IHlrZXkgPSBmaW5kUm9vdFR5cGVLZXkocGFyZW50KTtcbiAgICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyh0cnVlKTsgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoeWtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpOyAvLyB3cml0ZSBwYXJlbnQgaWRcbiAgICAgICAgICBlbmNvZGVyLndyaXRlTGVmdElEKHBhcmVudEl0ZW0uaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7IC8vIHRoaXMgZWRnZSBjYXNlIHdhcyBhZGRlZCBieSBkaWZmZXJlbnRpYWwgdXBkYXRlc1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyh0cnVlKTsgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpOyAvLyB3cml0ZSBwYXJlbnQgaWRcbiAgICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChwYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5leHBlY3RlZENhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhwYXJlbnRTdWIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQud3JpdGUoZW5jb2Rlciwgb2Zmc2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5mb1xuICovXG5jb25zdCByZWFkSXRlbUNvbnRlbnQgPSAoZGVjb2RlciwgaW5mbykgPT4gY29udGVudFJlZnNbaW5mbyAmIEJJVFM1XShkZWNvZGVyKTtcblxuLyoqXG4gKiBBIGxvb2t1cCBtYXAgZm9yIHJlYWRpbmcgSXRlbSBjb250ZW50LlxuICpcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIpOkFic3RyYWN0Q29udGVudD59XG4gKi9cbmNvbnN0IGNvbnRlbnRSZWZzID0gW1xuICAoKSA9PiB7IHVuZXhwZWN0ZWRDYXNlKCk7IH0sIC8vIEdDIGlzIG5vdCBJdGVtQ29udGVudFxuICByZWFkQ29udGVudERlbGV0ZWQsIC8vIDFcbiAgcmVhZENvbnRlbnRKU09OLCAvLyAyXG4gIHJlYWRDb250ZW50QmluYXJ5LCAvLyAzXG4gIHJlYWRDb250ZW50U3RyaW5nLCAvLyA0XG4gIHJlYWRDb250ZW50RW1iZWQsIC8vIDVcbiAgcmVhZENvbnRlbnRGb3JtYXQsIC8vIDZcbiAgcmVhZENvbnRlbnRUeXBlLCAvLyA3XG4gIHJlYWRDb250ZW50QW55LCAvLyA4XG4gIHJlYWRDb250ZW50RG9jLCAvLyA5XG4gICgpID0+IHsgdW5leHBlY3RlZENhc2UoKTsgfSAvLyAxMCAtIFNraXAgaXMgbm90IEl0ZW1Db250ZW50XG5dO1xuXG5jb25zdCBzdHJ1Y3RTa2lwUmVmTnVtYmVyID0gMTA7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU2tpcCBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtTa2lwfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIC8vIHNraXAgc3RydWN0cyBjYW5ub3QgYmUgaW50ZWdyYXRlZFxuICAgIHVuZXhwZWN0ZWRDYXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVJbmZvKHN0cnVjdFNraXBSZWZOdW1iZXIpO1xuICAgIC8vIHdyaXRlIGFzIFZhclVpbnQgYmVjYXVzZSBTa2lwcyBjYW4ndCBtYWtlIHVzZSBvZiBwcmVkaWN0YWJsZSBsZW5ndGgtZW5jb2RpbmdcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgdGhpcy5sZW5ndGggLSBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydCB7IEFic3RyYWN0Q29ubmVjdG9yLCBBYnN0cmFjdFN0cnVjdCwgQWJzdHJhY3RUeXBlLCBZQXJyYXkgYXMgQXJyYXksIENvbnRlbnRBbnksIENvbnRlbnRCaW5hcnksIENvbnRlbnREZWxldGVkLCBDb250ZW50RW1iZWQsIENvbnRlbnRGb3JtYXQsIENvbnRlbnRKU09OLCBDb250ZW50U3RyaW5nLCBDb250ZW50VHlwZSwgRG9jLCBHQywgSUQsIEl0ZW0sIFlNYXAgYXMgTWFwLCBQZXJtYW5lbnRVc2VyRGF0YSwgUmVsYXRpdmVQb3NpdGlvbiwgU25hcHNob3QsIFlUZXh0IGFzIFRleHQsIFRyYW5zYWN0aW9uLCBVbmRvTWFuYWdlciwgWVhtbEVsZW1lbnQgYXMgWG1sRWxlbWVudCwgWVhtbEZyYWdtZW50IGFzIFhtbEZyYWdtZW50LCBZWG1sSG9vayBhcyBYbWxIb29rLCBZWG1sVGV4dCBhcyBYbWxUZXh0LCBZQXJyYXlFdmVudCwgWUV2ZW50LCBZTWFwRXZlbnQsIFlUZXh0RXZlbnQsIFlYbWxFdmVudCwgYXBwbHlVcGRhdGUsIGFwcGx5VXBkYXRlVjIsIGNvbXBhcmVJRHMsIGNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucywgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uLCBjcmVhdGVEZWxldGVTZXQsIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSwgY3JlYXRlRG9jRnJvbVNuYXBzaG90LCBjcmVhdGVJRCwgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OLCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCwgY3JlYXRlU25hcHNob3QsIGRlY29kZVJlbGF0aXZlUG9zaXRpb24sIGRlY29kZVNuYXBzaG90LCBkZWNvZGVTbmFwc2hvdFYyLCBkZWNvZGVTdGF0ZVZlY3RvciwgZGlmZlVwZGF0ZSwgZGlmZlVwZGF0ZVYyLCBlbXB0eVNuYXBzaG90LCBlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uLCBlbmNvZGVTbmFwc2hvdCwgZW5jb2RlU25hcHNob3RWMiwgZW5jb2RlU3RhdGVBc1VwZGF0ZSwgZW5jb2RlU3RhdGVBc1VwZGF0ZVYyLCBlbmNvZGVTdGF0ZVZlY3RvciwgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlLCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMiwgZXF1YWxTbmFwc2hvdHMsIGZpbmRSb290VHlwZUtleSwgZ2V0SXRlbSwgZ2V0U3RhdGUsIGdldFR5cGVDaGlsZHJlbiwgaXNEZWxldGVkLCBpc1BhcmVudE9mLCBpdGVyYXRlRGVsZXRlZFN0cnVjdHMsIGxvZ1R5cGUsIGxvZ1VwZGF0ZSwgbG9nVXBkYXRlVjIsIG1lcmdlVXBkYXRlcywgbWVyZ2VVcGRhdGVzVjIsIHBhcnNlVXBkYXRlTWV0YSwgcGFyc2VVcGRhdGVNZXRhVjIsIHJlYWRVcGRhdGUsIHJlYWRVcGRhdGVWMiwgcmVsYXRpdmVQb3NpdGlvblRvSlNPTiwgc25hcHNob3QsIHRyYW5zYWN0LCB0cnlHYywgdHlwZUxpc3RUb0FycmF5U25hcHNob3QsIHR5cGVNYXBHZXRTbmFwc2hvdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eWpzLm1qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/yjs/dist/yjs.mjs\n")}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(e.exports,e,e.exports,__webpack_require__),e.exports}__webpack_require__.n=n=>{var t=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{var n;__webpack_require__.g.importScripts&&(n=__webpack_require__.g.location+"");var t=__webpack_require__.g.document;if(!n&&t&&(t.currentScript&&(n=t.currentScript.src),!n)){var e=t.getElementsByTagName("script");e.length&&(n=e[e.length-1].src)}if(!n)throw new Error("Automatic publicPath is not supported in this browser");n=n.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=n})();var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));